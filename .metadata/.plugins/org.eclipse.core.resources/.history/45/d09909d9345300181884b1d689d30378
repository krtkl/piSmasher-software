/*
 * Copyright (C) 2007 NXP N.V., All Rights Reserved.
 * This source code and any compilation or derivative thereof is the proprietary
 * information of NXP N.V. and is confidential in nature. Under no circumstances
 * is this software to be  exposed to or placed under an Open Source License of
 * any type without the expressed written permission of NXP N.V.
 *
 * \file          tmdlHdmiCEC_IW_EA3250.c
 *
 * \version       $Revision: 2 $
 *
 * \date          $Date: 16/11/11 $
 *
 * \brief         EA3250 IW wrapper
 *
 * \section info  Change Information
 *
 * \verbatim

   $History: tmdlHdmiCEC_IW_EA3250.c $
 * *****************  Version 2  *****************
 * User: Vrignaud     Date: 16/11/11
 *
 * *****************  Version 1  *****************
 * User: Vrignaud     Date: 28/10/11   Time: 8:32
 * initial version
 *

   \endverbatim
 *
*/

/*============================================================================*/
/*                       INCLUDE FILES                                        */
/*============================================================================*/

#include <fcntl.h>
#include <pthread.h>
#include <sys/stat.h>
#include <semaphore.h>
#include <mqueue.h>
#include <string.h>
#include <stdio.h>
#include <unistd.h>

#include "tmNxTypes.h"
#include "tmdlHdmiCEC_Types.h"
#include "tmdlHdmiCEC_cfg.h"
#include "tmdlHdmiCEC_IW.h"

#include "tmNxCompid.h"
//#include "unistd.h"

#ifdef __cplusplus
extern "C" {
#endif

/*============================================================================*/
/*                       DEFINES                                              */
/*============================================================================*/

/* maximum number of tasks that can be handled by the wrapper */
#define MAX_TASKS  4
/* maximum number of message queues that can be handled by the wrapper */
#define MAX_QUEUES 4
/* maximum number of semaphores that can be handled by the wrapper */
#define MAX_SEMA   8

/*============================================================================*/
/*                                MACRO                                       */
/*============================================================================*/

/* macro for quick error handling */
#define RETIF(cond, rslt) if ((cond)){return (rslt);}

/*============================================================================*/
/*                       TYPE DEFINITIONS                                     */
/*============================================================================*/

/* structure describing each task handled by the wrapper */
typedef struct
{
    Bool                    created;
    Bool                    started;
    UInt8                   priority;
    size_t                  stackSize;
    int						threadID;
	pthread_attr_t			threadAttr;
    struct sched_param      threadParm;
    pthread_t               threadHandle;
    tmdlHdmiTxIWFuncPtr_t   associatedTask;
} tmdlHdmiCecIWTcb_t;

/* structure describing each message queue handled by the wrapper */
typedef struct
{
    Bool    created;
    sem_t  	accessSemaphore;
    sem_t  	countSemaphore;
    UInt16  queueSize;
    mqd_t   queueHandle;
} tmdlHdmiCecIWQueue_t;

/* structure describing each semaphore handled by the wrapper */
typedef struct
{
    Bool	created;
    sem_t 	semHandle;
} tmdlHdmiCecIWSem_t;

//http://mij.oltrelinux.com/devel/unixprg/
/* name of the POSIX object referencing the queue */
char *MSGQOBJ_NAME_CEC[] =
{
	"/hdmicec0",
	"/hdmicec1",
	"/hdmicec2",
	"/hdmicec3",
	"/hdmicec4",
	"/hdmicec5",
	"/hdmicec6",
	"/hdmicec7",
};
#define MAX_MSG_LEN 10000

/* Threads */
char *sched_typeCec[] = {
    "SCHED_OTHER",
    "SCHED_FIFO",
    "SCHED_RR"
};

/*============================================================================*/
/*                       FUNCTION PROTOTYPES                                  */
/*============================================================================*/

/*============================================================================*/
/*                       VARIABLES                                            */
/*============================================================================*/

/* table storing all tasks descriptions */
tmdlHdmiCecIWTcb_t taskTableCec[MAX_TASKS] =
{
    {False, False, 0, 0, 0, {{0,0}}, {0}, 0, Null},
    {False, False, 0, 0, 0, {{0,0}}, {0}, 0, Null},
    {False, False, 0, 0, 0, {{0,0}}, {0}, 0, Null},
    {False, False, 0, 0, 0, {{0,0}}, {0}, 0, Null}
};

/* table storing all message queues descriptions */
tmdlHdmiCecIWQueue_t queueTableCec[MAX_QUEUES] =
{
    {False, {{0,0}}, {{0,0}}, 0, (int)0},
    {False, {{0,0}}, {{0,0}}, 0, (int)0},
    {False, {{0,0}}, {{0,0}}, 0, (int)0},
    {False, {{0,0}}, {{0,0}}, 0, (int)0}
};

/* table storing all semaphores descriptions */
tmdlHdmiCecIWSem_t semTableCec[MAX_SEMA] =
{
    {False, {{0,0}}},
    {False, {{0,0}}},
    {False, {{0,0}}},
    {False, {{0,0}}},
    {False, {{0,0}}},
    {False, {{0,0}}},
    {False, {{0,0}}},
    {False, {{0,0}}}
};


/*============================================================================*/
/*                       FUNCTION                                                */
/*============================================================================*/

/**
    \brief  This function creates a task and allocates all the necessary resources.
            Note that creating a task do not start it automatically, 
            an explicit call to tmdlHdmiCecIWTaskStart must be made.

    \param pFunc        Pointer to the function that will be executed in the task context.
    \param Priority     Priority of the task. The minimum priority is 0, the maximum is 255.
    \param StackSize    Size of the stack to allocate for this task.
    \param pHandle      Pointer to the handle buffer.

    \return The call result:
            - TM_OK: the call was successful
            - TMDL_ERR_DLHDMICEC_NO_RESOURCES: the resource is not available
            - TMDL_ERR_DLHDMICEC_INCONSISTENT_PARAMS: an input parameter is
              inconsistent

******************************************************************************/
tmErrorCode_t tmdlHdmiCecIWTaskCreate
(
    tmdlHdmiTxIWFuncPtr_t       pFunc,
    UInt8                       priority,
    UInt16                      stackSize,
    tmdlHdmiTxIWTaskHandle_t    *pHandle
)
{
    UInt8 i;

    /* check that input pointer is not NULL */
    RETIF(pFunc == Null, TMDL_ERR_DLHDMICEC_INCONSISTENT_PARAMS)

    /* check that input pointer is not NULL */
    RETIF(pHandle == Null, TMDL_ERR_DLHDMICEC_INCONSISTENT_PARAMS)

    /* search for available task slot */
    for(i = 0; i < MAX_TASKS; i++)
    {
        if (taskTableCec[i].created == False)
            break;

    }
    RETIF(i >= MAX_TASKS, TMDL_ERR_DLHDMICEC_NO_RESOURCES)

    /* store task parameters into the dedicated structure */
    taskTableCec[i].priority = priority;
    taskTableCec[i].stackSize = stackSize;
    taskTableCec[i].associatedTask = pFunc;
    taskTableCec[i].created = True;

    *pHandle = (tmdlHdmiTxIWTaskHandle_t)i;

    return(TM_OK);
}

/*============================================================================*/

/**
    \brief    This function destroys an existing task and frees resources used by it.

    \param Handle        Handle of the task to be destroyed, as returned by IWTaskCreate.

    \return The call result:
            - TM_OK: the call was successful
            - TMDL_ERR_DLHDMICEC_RESOURCE_NOT_OWNED: the caller does not own 
              the resource
            - TMDL_ERR_DLHDMICEC_BAD_HANDLE: the handle number is wrong

******************************************************************************/
tmErrorCode_t tmdlHdmiCecIWTaskDestroy
(
    tmdlHdmiTxIWTaskHandle_t handle
)
{
    /* check if handle number is in range */
    RETIF(handle >= MAX_TASKS, TMDL_ERR_DLHDMICEC_BAD_HANDLE)

    /* check if handle corresponding to task is created */
    RETIF(taskTableCec[handle].created == False, TMDL_ERR_DLHDMICEC_RESOURCE_NOT_OWNED)

    if (taskTableCec[handle].started == True)
    {
    	/* destroy requested thread */
		//rc = pthread_join(taskTableCec[handle].threadHandle, NULL);
        taskTableCec[handle].started = False;
    }
    taskTableCec[handle].created = False;

    return(TM_OK);
}

/*============================================================================*/

/**
    \brief This function start an existing task.

    \param Handle        Handle of the task to be started.

    \return The call result:
            - TM_OK: the call was successful
            - TMDL_ERR_DLHDMICEC_ALREADY_STARTED: the function is already started
            - TMDL_ERR_DLHDMICEC_NOT_STARTED: the function is not started
            - TMDL_ERR_DLHDMICEC_BAD_HANDLE: the handle number is wrong

******************************************************************************/
tmErrorCode_t tmdlHdmiCecIWTaskStart(tmdlHdmiTxIWTaskHandle_t handle)
{
	int rc;

    /* check if handle number is in range */
    RETIF(handle >= MAX_TASKS, TMDL_ERR_DLHDMICEC_BAD_HANDLE)

    /* check if task is already started */
    RETIF(taskTableCec[handle].started == True, TMDL_ERR_DLHDMICEC_ALREADY_STARTED)

	/* set stack size */
	pthread_attr_init(&(taskTableCec[handle].threadAttr));

//	PRNT_ARGS("CEC_IW: stack needed per thread = %li\n",taskTableCec[handle].stackSize);
	pthread_attr_setstacksize(&(taskTableCec[handle].threadAttr), taskTableCec[handle].stackSize);

    /* set the priority task */
	taskTableCec[handle].threadParm.sched_priority=taskTableCec[handle].priority;
//	PRNT_ARGS("CEC_IW: priority of thread = %li\n",taskTableCec[handle].priority);
    pthread_attr_setschedpolicy(&(taskTableCec[handle].threadAttr),SCHED_FIFO);
    pthread_attr_setschedparam(&(taskTableCec[handle].threadAttr),&(taskTableCec[handle].threadParm));

    /* start thread associated to the task */
//	PRNT_ARGS("CEC_IW: creating thread %d\n", handle);
	rc = pthread_create(&(taskTableCec[handle].threadHandle),
		&(taskTableCec[handle].threadAttr),
		(void*)(taskTableCec[handle].associatedTask),
		(void *) &(taskTableCec[handle].threadID));

    /* check return code for errors */
    RETIF(!(taskTableCec[handle].threadHandle), TMDL_ERR_DLHDMICEC_NOT_STARTED)

    /* update task status */
    taskTableCec[handle].started = True;

    return(TM_OK);
}

/*============================================================================*/

/**
    \brief This function blocks the current task for the specified amount time. This is a passive wait.

    \param Duration    Duration of the task blocking in milliseconds.

    \return The call result:
            - TM_OK: the call was successful
            - TMDL_ERR_DLHDMICEC_NO_RESOURCES: the resource is not available

******************************************************************************/
tmErrorCode_t tmdlHdmiCecIWWait(UInt16 duration)
{
	usleep (duration*1000);

    return(TM_OK);
}

/*============================================================================*/

/**
    \brief This function creates a message queue.

    \param QueueSize    Maximum number of messages in the message queue.
    \param pHandle        Pointer to the handle buffer.
    
    \return The call result:
            - TM_OK: the call was successful
            - TMDL_ERR_DLHDMICEC_INCONSISTENT_PARAMS: an input parameter is
              inconsistent
            - TMDL_ERR_DLHDMICEC_NO_RESOURCES: the resource is not available

******************************************************************************/
tmErrorCode_t tmdlHdmiCecIWQueueCreate(UInt8 queueSize, tmdlHdmiTxIWQueueHandle_t *pHandle)
{
    UInt8 i;

    /* check that input pointer is not NULL */
    RETIF(pHandle == Null, TMDL_ERR_DLHDMICEC_INCONSISTENT_PARAMS)

    /* search for available queue slot */
    for(i = 0; i < MAX_QUEUES; i++)
    {
        if (queueTableCec[i].created == False)
            break;

    }
    
    RETIF(i >= MAX_QUEUES, TMDL_ERR_DLHDMICEC_NO_RESOURCES)

    /* create a new queue (using default attributes) */
    queueTableCec[i].queueHandle = mq_open(MSGQOBJ_NAME_CEC[i], O_RDWR | O_CREAT | O_EXCL, S_IRWXU | S_IRWXG, NULL);
    if (queueTableCec[i].queueHandle == (mqd_t)-1)
    {
		/* open an existing queue */
    	queueTableCec[i].queueHandle = mq_open(MSGQOBJ_NAME_CEC[i], O_RDWR);
    }

    /* check queue handle */
    if (queueTableCec[i].queueHandle == (mqd_t)-1) {
    	PRNT_ARGS("/!\\ CEC_IW: message queue %s creation failed\n", MSGQOBJ_NAME_CEC[i]);
    	perror("In mq_open()");
        return(TMDL_ERR_DLHDMICEC_NO_RESOURCES);
    }
//	PRNT_ARGS("CEC_IW: message queue %s created\n", MSGQOBJ_NAME_CEC[i]);

	/* allocate semaphores for the queue */
//	sem_init(&queueTableCec[i].countSemaphore, 0, 0);
//    RETIF(queueTableCec[i].countSemaphore == Null, TMDL_ERR_DLHDMICEC_NO_RESOURCES)
	
//	sem_init(&queueTableCec[i].accessSemaphore, 0, 1);
//    RETIF(queueTableCec[i].accessSemaphore == NULL, TMDL_ERR_DLHDMICEC_NO_RESOURCES)

    /* update status of the queue table */
    queueTableCec[i].created = True;
    queueTableCec[i].queueSize = queueSize;
	*pHandle = (tmdlHdmiTxIWQueueHandle_t)i;

    return(TM_OK);
}

/*============================================================================*/

/**
    \brief This function destroys an existing message queue.

    \param    Handle        Handle of the queue to be destroyed.

    \return The call result:
            - TM_OK: the call was successful
            - TMDL_ERR_DLHDMICEC_BAD_HANDLE: the handle number is wrong
            - TMDL_ERR_DLHDMICEC_RESOURCE_NOT_OWNED: the caller does not own 
              the resource

******************************************************************************/
tmErrorCode_t tmdlHdmiCecIWQueueDestroy( handle)
{
    RETIF(handle > MAX_QUEUES, TMDL_ERR_DLHDMICEC_BAD_HANDLE)

    RETIF(queueTableCec[handle].created == False, TMDL_ERR_DLHDMICEC_RESOURCE_NOT_OWNED)

	 /* close queue */
    mq_close(queueTableCec[handle].queueHandle);
	
	/* release semaphores for the queue */
//	sem_destroy(&queueTableCec[handle].countSemaphore);
//	sem_destroy(&queueTableCec[handle].accessSemaphore);

    queueTableCec[handle].created = False;

    return(TM_OK);
}

/*============================================================================*/

/**
    \brief This function sends a message into the specified message queue.

    \param Handle    Handle of the queue that will receive the message.
    \param Message   Message to be sent.
    
    \return The call result:
            - TM_OK: the call was successful
            - TMDL_ERR_DLHDMICEC_BAD_HANDLE: the handle number is wrong
            - TMDL_ERR_DLHDMICEC_RESOURCE_NOT_OWNED: the caller does not own 
              the resource
            - TMDL_ERR_DLHDMICEC_FULL: the queue is full

******************************************************************************/
tmErrorCode_t tmdlHdmiCecIWQueueSend(tmdlHdmiTxIWQueueHandle_t handle, UInt8 message)
{
	char msgcontent[1];

    /* check that handle is correct */
    RETIF(handle > MAX_QUEUES, TMDL_ERR_DLHDMICEC_BAD_HANDLE)

    RETIF(queueTableCec[handle].created != True, TMDL_ERR_DLHDMICEC_RESOURCE_NOT_OWNED)

    /* ask for exclusive access to this queue */
//    sem_wait(&queueTableCec[handle].accessSemaphore);

	/* build the message */
	msgcontent[0] = message;
	
	/* send the message */
	mq_send(queueTableCec[handle].queueHandle, msgcontent, strlen(msgcontent)+1, 0);
//	PRNT_ARGS("Cec_IW: message queue %s sent message %s\n", MSGQOBJ_NAME_CEC[handle], msgcontent);

   /* release the counting semaphore */
//    sem_post(&queueTableCec[handle].countSemaphore);


    /* release access to this queue */
//    sem_post(&queueTableCec[handle].accessSemaphore);

    return(TM_OK);
}
/*============================================================================*/

/**
    \brief This function reads a message from the specified message queue.

    \param    Handle        Handle of the queue from which to read the message.
    \param    pMessage      Pointer to the message buffer.

    \return The call result:
            - TM_OK: the call was successful
            - TMDL_ERR_DLHDMICEC_BAD_HANDLE: the handle number is wrong
            - TMDL_ERR_DLHDMICEC_RESOURCE_NOT_OWNED: the caller does not own 
              the resource
            - TMDL_ERR_DLHDMICEC_INCONSISTENT_PARAMS: an input parameter is
              inconsistent

******************************************************************************/
tmErrorCode_t tmdlHdmiCecIWQueueReceive(tmdlHdmiTxIWQueueHandle_t handle, UInt8 *pMessage)
{
	char msgcontent[1];
	int msgsz;
	unsigned int sender;
//	struct mq_attr msgq_attr;

    /* check that handle is correct */
    RETIF(handle > MAX_QUEUES, TMDL_ERR_DLHDMICEC_BAD_HANDLE)
    
    RETIF(queueTableCec[handle].created != True, TMDL_ERR_DLHDMICEC_RESOURCE_NOT_OWNED)

    /* check that input pointer is not NULL */
    RETIF(pMessage == Null, TMDL_ERR_DLHDMICEC_INCONSISTENT_PARAMS)

    /* ask for a new message by acquiring the counting semaphore */
//    sem_wait(&queueTableCec[handle].countSemaphore);


    /* if we reach this point, this means that we got a message */
    /* ask for exclusive access to this queue */
//	sem_wait(&queueTableCec[handle].accessSemaphore);

	/* check existing queue */
	if (queueTableCec[handle].queueHandle == (mqd_t)-1) {
		PRNT_ARGS("/!\\ Cec_IW: message queue %s doesn't exist\n", MSGQOBJ_NAME_CEC[handle]);
		return(TM_ERR_BAD_HANDLE);
	}

//        /* getting the attributes from the queue        --  mq_getattr() */
//        mq_getattr(queueTableCec[handle].queueHandle, &msgq_attr);
//        printf("Queue \"%s\":\n\t- stores at most %ld messages\n\t- large at most %ld bytes each\n\t- currently holds %ld messages\n", MSGQOBJ_NAME_CEC, msgq_attr.mq_maxmsg, msgq_attr.mq_msgsize, msgq_attr.mq_curmsgs);

	/* getting a message */
	msgsz = mq_receive(queueTableCec[handle].queueHandle, msgcontent, MAX_MSG_LEN, &sender);
	if (msgsz == -1) {
		perror("/!\\ Cec_IW: message queue reception failed\n");
	}
//	PRNT_ARGS("Cec_IW: message queue %s received message (%d bytes) from %d: %s\n", MSGQOBJ_NAME_CEC[handle], msgsz, sender, msgcontent);
	*pMessage = msgcontent[0];

    /* release access to this queue */
//    sem_post(&queueTableCec[handle].accessSemaphore);

    return(TM_OK);
}

/*============================================================================*/

/**
    \brief This function creates a semaphore.

    \param     pHandle    Pointer to the handle buffer.

    \return The call result:
            - TM_OK: the call was successful
            - TMDL_ERR_DLHDMICEC_NO_RESOURCES: the resource is not available
            - TMDL_ERR_DLHDMICEC_INCONSISTENT_PARAMS: an input parameter is
              inconsistent

******************************************************************************/
tmErrorCode_t tmdlHdmiCecIWSemaphoreCreate(tmdlHdmiTxIWSemHandle_t *pHandle)
{
    UInt8   i;

    /* check that input pointer is not NULL */
    RETIF(pHandle == Null, TMDL_ERR_DLHDMICEC_INCONSISTENT_PARAMS)

    /* search for available semaphore slot */
    for(i = 0; i < MAX_SEMA; i++)
    {
        if (semTableCec[i].created == False)
            break;

    }
    
    RETIF(i >= MAX_SEMA, TMDL_ERR_DLHDMICEC_NO_RESOURCES)

	sem_init(&semTableCec[i].semHandle, 0, 1);
//    RETIF(semTableCec[i].semHandle == NULL, TMDL_ERR_DLHDMICEC_NO_RESOURCES)

    *pHandle = (tmdlHdmiTxIWSemHandle_t) i;

    semTableCec[i].created = True;

    return(TM_OK);
}

/*============================================================================*/

/**
    \brief This function destroys an existing semaphore.

    \param    Handle        Handle of the semaphore to be destroyed.

    \return The call result:
            - TM_OK: the call was successful
            - TMDL_ERR_DLHDMICEC_BAD_HANDLE: the handle number is wrong

******************************************************************************/
tmErrorCode_t tmdlHdmiCecIWSemaphoreDestroy(tmdlHdmiTxIWSemHandle_t handle)
{
    UInt8  i;

    for(i=0;i<MAX_SEMA;i++)
    {
        if(i == handle)
        {
            break;
        }
    }
    if(i >= MAX_SEMA) return(TM_ERR_NO_RESOURCES);


    sem_destroy(&semTableCec[i].semHandle);

    semTableCec[i].created = False;

    return(TM_OK);
}

/*============================================================================*/

/**
    \brief This function acquires the specified semaphore.

    \param Handle        Handle of the semaphore to be acquired.

    \return The call result:
            - TM_OK: the call was successful
            - TMDL_ERR_DLHDMICEC_BAD_HANDLE: the handle number is wrong

******************************************************************************/
tmErrorCode_t tmdlHdmiCecIWSemaphoreP(tmdlHdmiTxIWSemHandle_t handle)
{
    sem_wait(&semTableCec[handle].semHandle);

    return(TM_OK);
}

/*============================================================================*/

/**
    \brief This function releases the specified semaphore.

    \param    Handle        Handle of the semaphore to be released.

    \return The call result:
            - TM_OK: the call was successful
            - TMDL_ERR_DLHDMICEC_BAD_HANDLE: the handle number is wrong

******************************************************************************/
tmErrorCode_t tmdlHdmiCecIWSemaphoreV(tmdlHdmiTxIWSemHandle_t handle)
{
    sem_post(&semTableCec[handle].semHandle);

    return(TM_OK);
}

/*============================================================================*/

/**
    \brief  This function disables the interrupts for a specific device.

    \param  device  Device on which the interrupts are disabled.

    \return The call result:
            - TM_OK: the call was successful

******************************************************************************/
void tmdlHdmiCecIWDisableInterrupts(tmdlHdmiIWDeviceInterrupt_t device)
{

}

/*============================================================================*/

/**
    \brief  This function enables the interrupts for a specific device.

    \param  device  Device on which the interrupts are enabled.

    \return The call result:
            - TM_OK: the call was successful

******************************************************************************/
void tmdlHdmiCecIWEnableInterrupts(tmdlHdmiIWDeviceInterrupt_t device)
{

}


#ifdef __cplusplus
}
#endif

/*============================================================================*/
/*                            END OF FILE                                     */
/*============================================================================*/



/**
 *******************************************************************************
 *******************************************************************************
 *
 * @file	tda998x.c
 * @author	R. Bush
 * @email	bush@krtkl.com
 * @version	v1.0
 * @date	2017 November 10
 * @brief	TDA998x HDMI Transmitter
 * @license	FreeBSD
 *
 *******************************************************************************
 *
 * Copyright (c) 2017, krtkl inc.
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 * 1. Redistributions of source code must retain the above copyright notice,
 *	  this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright notice,
 *	  this list of conditions and the following disclaimer in the documentation
 *	  and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
 * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
 * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
 * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
 * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
 * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
 * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
 * POSSIBILITY OF SUCH DAMAGE.
 *
 * The views and conclusions contained in the software and documentation are
 * those of the authors and should not be interpreted as representing official
 * policies, either expressed or implied, of the FreeBSD Project.
 *
 *******************************************************************************
 */

#include <stdio.h>
#include <stdint.h>
#include <stdbool.h>
#include <unistd.h>


#include "tda998x.h"


/**
 * @defgroup	NXP_TDA998X NXP TDA998x HDMI Transmitter
 * @{
 */


#define PAGE_ADDR(__PAGE__, __ADDR__)		(((__PAGE__) << 8) | ((__ADDR__) & 0xFFU))
#define PAGE_OF(__REG__)			((uint8_t)(((__REG__) >> 8) & 0xFFU))

/**
 * @addtogroup	NXP_TDA998X_CEC_Core
 * @{
 */
#define INTERRUPTSTATUS_CEC			(1 << 0)
#define INTERRUPTSTATUS_HDMI			(1 << 1)

#define RXSHPDINTENA_ENA_RXS_INT		(1 << 0)
#define RXSHPDINTENA_ENA_HPD_INT		(1 << 1)

#define RXSHPDINT_RXS_INT			(1 << 0)
#define RXSHPDINT_HPD_INT			(1 << 1)

#define RXSHPDLEV_RXS_LEVEL			(1 << 0)
#define RXSHPDLEV_HPD_LEVEL			(1 << 1)

#define ENAMODS_ENA_CEC				(1 << 0)
#define ENAMODS_ENA_HDMI			(1 << 1)
#define ENAMODS_ENA_RXS				(1 << 2)
#define ENAMODS_DIS_CCLK			(1 << 5)
#define ENAMODS_DIS_FRO				(1 << 6)

#define FRO_IM_CLK_CTRL_FRO_DIV			(1 << 0)
#define FRO_IM_CLK_CTRL_IMCLK_SEL		(1 << 1)
#define FRO_IM_CLK_CTRL_ENA_OTP			(1 << 6)
#define FRO_IM_CLK_CTRL_GHOST_DIS		(1 << 7)

/**
 * @brief	CEC Core Registers
 */
enum tda998x_cec_reg {
	INTERRUPTSTATUS = 0xEE,
	RXSHPDINTENA = 0xFC,
	RXSHPDINT = 0xFD,
	RXSHPDLEV = 0xFE,
	ENAMODS = 0xFF,
	FRO_IM_CLK_CTRL = 0xFB,
};
/**
 * @}
 */

/**
 * @addtogroup	NXP_TDA998X_HDMI_Core
 * @{
 */

/**
 * @addtogroup	NXP_TDA998X_HDMI_Core_Registers
 * @{
 */

/**
 * @brief	HDMI Core Register Pages
 */
enum tda998x_hdmi_page {
	PAGE_00 = 0x00,
	PAGE_01 = 0x01,
	PAGE_02 = 0x02,
	PAGE_09 = 0x09,
	PAGE_10 = 0x10,
	PAGE_11 = 0x11,
	PAGE_12 = 0x12,
	PAGE_13 = 0x13,
	PAGE_INVALID = 0xFF
};

#define VERSION_NOT_SCALER			(1 << 4)
#define VERSION_NOT_HDCP			(1 << 5)

#define MAIN_CNTRL0_SR				(1 << 0)
#define MAIN_CNTRL0_DECS			(1 << 1)
#define MAIN_CNTRL0_DEHS			(1 << 2)
#define MAIN_CNTRL0_CECS			(1 << 3)
#define MAIN_CNTRL0_CEHS			(1 << 4)
#define MAIN_CNTRL0_SCALER			(1 << 7)

#define SR_REG_SR_AUDIO				(1 << 0)
#define SR_REG_SR_I2C_MS			(1 << 1)

#define DDC_DISABLE_DDC_DIS			(1 << 0)

#define CCLK_ON_CCLK_DDC_ON			(1 << 0)

#define I2C_MASTER_DIS_MM			(1 << 0)
#define I2C_MASTER_DIS_FILT			(1 << 1)
#define I2C_MASTER_APP_STRT_LAT			(1 << 2)

#define INT_FLAGS_0_ENCRYPT			(1 << 0)
#define INT_FLAGS_0_HPD				(1 << 1)
#define INT_FLAGS_0_T0				(1 << 2)
#define INT_FLAGS_0_BCAPS			(1 << 3)
#define INT_FLAGS_0_BSTATUS			(1 << 4)
#define INT_FLAGS_0_SHA_1			(1 << 5)
#define INT_FLAGS_0_PJ				(1 << 6)
#define INT_FLAGS_0_R0				(1 << 7)

#define INT_FLAGS_1_VS_RPT			(1 << 0)
#define INT_FLAGS_1_OTP				(1 << 1)
#define INT_FLAGS_1_SC_IN			(1 << 2)
#define INT_FLAGS_1_SC_OUT			(1 << 3)
#define INT_FLAGS_1_SC_VID			(1 << 4)
#define INT_FLAGS_1_SC_DEIL			(1 << 5)
#define INT_FLAGS_1_SW_INT			(1 << 6)
#define INT_FLAGS_1_HPD_IN			(1 << 7)

#define INT_FLAGS_2_RX_SENSE			(1 << 0)
#define INT_FLAGS_2_EDID_BLK_RD			(1 << 1)

#define INT_FLAGS_3_RXS_FIL			(1 << 0)

#define SW_INT_SW_INT				(1 << 0)

#define ENA_ACLK_ENA_ACLK			(1 << 0)
#define GND_ACLK_GND_ACLK			(1 << 0)

#define ENA_VP_0_ENA_VP0			(1 << 0)
#define ENA_VP_0_ENA_VP1			(1 << 1)
#define ENA_VP_0_ENA_VP2			(1 << 2)
#define ENA_VP_0_ENA_VP3			(1 << 3)
#define ENA_VP_0_ENA_VP4			(1 << 4)
#define ENA_VP_0_ENA_VP5			(1 << 5)
#define ENA_VP_0_ENA_VP6			(1 << 6)
#define ENA_VP_0_ENA_VP7			(1 << 7)

#define ENA_VP_1_ENA_VP8			(1 << 0)
#define ENA_VP_1_ENA_VP9			(1 << 1)
#define ENA_VP_1_ENA_VP10			(1 << 2)
#define ENA_VP_1_ENA_VP11			(1 << 3)
#define ENA_VP_1_ENA_VP12			(1 << 4)
#define ENA_VP_1_ENA_VP13			(1 << 5)
#define ENA_VP_1_ENA_VP14			(1 << 6)
#define ENA_VP_1_ENA_VP15			(1 << 7)

#define ENA_VP_2_ENA_VP16			(1 << 0)
#define ENA_VP_2_ENA_VP17			(1 << 1)
#define ENA_VP_2_ENA_VP18			(1 << 2)
#define ENA_VP_2_ENA_VP19			(1 << 3)
#define ENA_VP_2_ENA_VP20			(1 << 4)
#define ENA_VP_2_ENA_VP21			(1 << 5)
#define ENA_VP_2_ENA_VP22			(1 << 6)
#define ENA_VP_2_ENA_VP23			(1 << 7)

#define ENA_AP_ENA_AP0				(1 << 0)
#define ENA_AP_ENA_AP1				(1 << 1)
#define ENA_AP_ENA_AP2				(1 << 2)
#define ENA_AP_ENA_AP3				(1 << 3)
#define ENA_AP_ENA_AP4				(1 << 4)
#define ENA_AP_ENA_AP5				(1 << 5)
#define ENA_AP_ENA_AP6				(1 << 6)
#define ENA_AP_ENA_AP7				(1 << 7)

#define VIP_CNTRL_SWAP_L_SHIFT			(0)
#define VIP_CNTRL_MIRR_L			(1 << 3)
#define VIP_CNTRL_SWAP_H_SHIFT			(4)
#define VIP_CNTRL_MIRR_H			(1 << 7)

#define VIP_CNTRL_SWAP_MASK			(0x77U)

enum tda998x_vip_cntrl_swap {
	VIP_CNTRL_VP23_20 = 0x00,
	VIP_CNTRL_VP19_16 = 0x01,
	VIP_CNTRL_VP15_12 = 0x02,
	VIP_CNTRL_VP11_8 = 0x03,
	VIP_CNTRL_VP7_4 = 0x04,
	VIP_CNTRL_VP3_0 = 0x05
};

enum tda998x_vip_cntrl_mirr {
	VIP_CNTRL_NOT_MIRRORED = 0,		/**< No action */
	VIP_CNTRL_MIRRORED = 1			/**< Mirrored (i.e. In[a:b] -> Out[b:a]) */
};

#define VIP_CNTRL_3_X_TGL			(1 << 0)
#define VIP_CNTRL_3_H_TGL			(1 << 1)
#define VIP_CNTRL_3_V_TGL			(1 << 2)
#define VIP_CNTRL_3_EMB				(1 << 3)
#define VIP_CNTRL_3_SP_SYNC_MASK		(0x30U)
#define VIP_CNTRL_3_DE_INT			(1 << 6)
#define VIP_CNTRL_3_EDGE			(1 << 7)

#define VIP_CNTRL_4_BLC_MASK			(0x03U)
#define VIP_CNTRL_4_BLANKIT_MASK		(0x0CU)
#define VIP_CNTRL_4_CCIR656			(1 << 4)
#define VIP_CNTRL_4_656_ALT			(1 << 5)
#define VIP_CNTRL_4_TST_656			(1 << 6)
#define VIP_CNTRL_4_TST_PAT			(1 << 7)

#ifdef TMFL_TDA19989
# define VIDFORMAT_3D_NEG_VS			(1 << 6)
# define VIDFORMAT_3D				(1 << 7)
#endif
#define VIDFORMAT_VIDFORMAT_MASK		(0x1FU)

enum tda998x_vidformat {
	VIDFORMAT_640x480p_60Hz = 0x00,
	VIDFORMAT_720x480p_60Hz = 0x01,
	VIDFORMAT_1280x720p_60Hz = 0x02,
	VIDFORMAT_1920x1080i_60Hz = 0x03,
	VIDFORMAT_720x480i_60Hz = 0x04,
	VIDFORMAT_720x240p_60Hz = 0x05,
	VIDFORMAT_1920x1080p_60Hz = 0x06,
	VIDFORMAT_720x576p_50Hz = 0x07,
	VIDFORMAT_1280x720p_50Hz = 0x08,
	VIDFORMAT_1920x1080i_50Hz = 0x09,
	VIDFORMAT_720x576i_50Hz = 0x0A,
	VIDFORMAT_720x288p_50Hz = 0x0B,
	VIDFORMAT_1920x1080p_50Hz = 0x0C
};

#define VIP_CNTRL_5_CKCASE			(1 << 0)
#define VIP_CNTRL_5_SP_CNT_MASK			(0x06U)

#define MAT_CONTRL_MAT_SC			(0x03U)
#define MAT_CONTRL_MAT_BP			(1 << 2)

#define TBG_CNTRL_0_SYNC_ONCE			(1 << 7)
#define TBG_CNTRL_0_SYNC_MTHD			(1 << 6)
#define TBG_CNTRL_0_FRAME_DIS			(1 << 5)

#define TBG_CNTRL_1_VH_TGL_MASK			(0x07U)
#define TBG_CNTRL_1_VH_TGL_0			(1 << 0)
#define TBG_CNTRL_1_VH_TGL_1			(1 << 1)
#define TBG_CNTRL_1_VH_TGL_2			(1 << 2)
#define TBG_CNTRL_1_VHX_EXT_MASK		(0x38U)
#define TBG_CNTRL_1_VHX_EXT_DE			(1 << 3)
#define TBG_CNTRL_1_VHX_EXT_HS			(1 << 4)
#define TBG_CNTRL_1_VHX_EXT_VS			(1 << 5)
#define TBG_CNTRL_1_DWIN_DIS			(1 << 6)

#define I2C_TIMER_RI_MASK			(0x0FU)
#define I2C_TIMER_PJ_MASK			(0xF0U)

#define HVF_CNTRL_0_INTPOL_MASK			(0x03U)
#define HVF_CNTRL_0_PREFIL_MASK			(0x0CU)
#define HVF_CNTRL_0_RWB				(1 << 6)
#define HVF_CNTRL_0_SM				(1 << 7)

#define HVF_CNTRL_1_FOR				(1 << 0)
#define HVF_CNTRL_1_YUVBLK			(1 << 1)
#define HVF_CNTRL_1_VQR_MASK			(0x0CU)
#define HVF_CNTRL_1_PAD_MASK			(0x30U)
#define HVF_CNTRL_1_SEMI_PLANAR			(1 << 6)

#define TIMER_H_TIM_H_MASK			(0x03U)
#define TIMER_H_WD_CLKSEL			(1 << 6)

#define DEBUG_PROBE_WOO_EN			(1 << 0)
#define DEBUG_PROBE_DI_DE			(1 << 1)
#define DEBUG_PROBE_VID_DE			(1 << 2)
#define DEBUG_PROBE_BYPASS			(1 << 3)
#define DEBUG_PROBE_SEL_MASK			(0x30U)

#define I2S_FORMAT_I2S_FORMAT_MASK		(0x0FU)
#define I2S_FORMAT_I2S_DATA_SIZE_MASK		(0x0CU)

#define AIP_CLKSEL_DST_RATE       (1 << 6)
//    		AIP_CLKSEL_SEL_AIP_SHIFT  = 3,
#define AIP_CLKSEL_SEL_AIP_MASK			(0x38U)
#define AIP_CLKSEL_SEL_POL_CLK			(1 << 2)
#define AIP_CLKSEL_SEL_FS_MASK			(0x03U)

#define SC_VIDFORMAT_LUT_SEL_MASK		(0xC0U)
#define SC_VIDFORMAT_VID_FORMAT_O_MASK		(0x38U)
#define SC_VIDFORMAT_VID_FORMAT_I_MASK		(0x0FU)

#define SC_CNTRL_PHASES_H			(1 << 4)
#define SC_CNTRL_IL_OUT_ON			(1 << 3)
#define SC_CNTRL_PHASES_V			(1 << 2)
#define SC_CNTRL_VS_ON				(1 << 1)
#define SC_CNTRL_DEIL_ON			(1 << 0)

//		    VIDFORMAT_VIDFORMAT       = BINARY(0,0,0,0, 0,1,1,1),

#define TBG_CNTRL_0_SYNC_ONCE			(1 << 7)
#define TBG_CNTRL_0_SYNC_MTHD			(1 << 6)
#define TBG_CNTRL_0_FRAME_DIS			(1 << 5)
#define TBG_CNTRL_0_TOP_EXT			(1 << 3)
#define TBG_CNTRL_0_DE_EXT			(1 << 2)
#define TBG_CNTRL_0_TOP_SEL			(1 << 1)
#define TBG_CNTRL_0_TOP_TGL			(1 << 0)

#define PLL_SERIAL_1_SRL_FDN			(1 << 0)
#define PLL_SERIAL_1_SRL_IZ_MASK		(0x06U)
#define PLL_SERIAL_1_SRL_MAN_IZ			(1 << 6)

#define PLL_SERIAL_2_SRL_NOSC_MASK		(0x03U)
#define PLL_SERIAL_2_SRL_PR_MASK		(0xF0U)

#define PLL_SERIAL_3_SRL_CCIR			(1 << 0)
#define PLL_SERIAL_3_SRL_DE			(1 << 1)
#define PLL_SERIAL_3_SRL_PXIN_SEL		(1 << 4)

#define SERIALIZER_SRL_PHASE2_MASK		(0x0FU)
#define SERIALIZER_SRL_PHASE3_MASK		(0xF0U)

#define BUFFER_OUT_SRL_CLK_MASK			(0x03U)
#define BUFFER_OUT_SRL_FORCE_MASK		(0x0CU)

#define PLL_SCG1_SCG_FDN			(1 << 0)

#define PLL_SCG2_SCG_NOSC_MASK			(0x03U)
#define PLL_SCG2_SELPLLCLKIN			(1 << 4)
#define PLL_SCG2_BYPASS_SCG			(1 << 7)

#define VAI_PLL_PLLSRL_LOCK			(1 << 0)
#define VAI_PLL_PLLSCG_LOCK			(1 << 1)
#define VAI_PLL_PLLSRL_HVP			(1 << 4)
#define VAI_PLL_PLLSCG_HVP			(1 << 5)
#define VAI_PLL_PLLDE_HVP			(1 << 6)

#define AUDIO_DIV_AUDIO_DIV_MASK		(0x07U)

#define AIP_CNTRL_0_RST_FIFO			(1 << 0)
#define AIP_CNTRL_0_SWAP			(1 << 1)
#define AIP_CNTRL_0_LAYOUT			(1 << 2)
#define AIP_CNTRL_0_ACR_MAN			(1 << 5)
#define AIP_CNTRL_0_RST_CTS			(1 << 6)

#define TEST1_TST_ENAHVP			(1 << 0)
#define TEST1_TST_NOSC				(1 << 1)
#define TEST1_SRLDAT_MASK			(0xC0U)

#define TEST2_DIVTESTOE				(1 << 0)
#define TEST2_PWD1V8				(1 << 1)

#define SEL_CLK_SEL_CLK1			(1 << 0)
#define SEL_CLK_SEL_VRF_CLK_MASK		(0x06U)
#define SEL_CLK_ENA_SC_CLK			(1 << 3)


#define BUFF_OUT2_FORCE_DAT0_MASK		(0x03U)
#define BUFF_OUT2_FORCE_DAT1_MASK		(0x0CU)
#define BUFF_OUT2_FORCE_DAT2_MASK		(0x30U)

#define EDID_CTRL_EDID_RD			(1 << 0)

#define CA_I2S_CA_I2S_MASK			(0x1FU)
#define CA_I2S_HBR_CHSTAT_4			(1 << 5)

#define GC_AVMUTE_SETCLR_MUTE			(0x0CU)
#define GC_AVMUTE_CLR_MUTE			(1 << 0)
#define GC_AVMUTE_SET_MUTE			(1 << 1)

#define CTS_N_M_SEL_MASK			(0x30U)
#define CTS_N_K_SEL_MASK			(0x07U)

#define ENC_CNTRL_RST_ENC			(1 << 0)
#define ENC_CNTRL_RST_SEL			(1 << 1)
#define ENC_CNTRL_CTL_CODE_MASK			(0x0CU)

#define DIP_FLAGS_ACR				(1 << 0)
#define DIP_FLAGS_GC				(1 << 1)
#define DIP_FLAGS_ISRC1				(1 << 2)
#define DIP_FLAGS_ISRC2				(1 << 3)
#define DIP_FLAGS_ACP				(1 << 4)
#define DIP_FLAGS_NULL				(1 << 6)
#define DIP_FLAGS_FORCE_NULL			(1 << 7)

#define DIP_IF_FLAGS_IF1			(1 << 1)
#define DIP_IF_FLAGS_IF2			(1 << 2)
#define DIP_IF_FLAGS_IF3			(1 << 3)
#define DIP_IF_FLAGS_IF4			(1 << 4)
#define DIP_IF_FLAGS_IF5			(1 << 5)

#define OTP_TX0_SR_HDCP				(1 << 0)
#define OTP_TX33_HDMI				(1 << 1)

#define GMD_CONTROL_ENABLE			(1 << 0)
#define GMD_CONTROL_BUF_SEL			(1 << 1)

/**
 * @brief	HDMI Core Registers
 */
enum tda998x_hdmi_reg {
	VERSION			= PAGE_ADDR(PAGE_00, 0x00),	/**< Device version */
	MAIN_CNTRL0		= PAGE_ADDR(PAGE_00, 0x01),	/**< Main control */
	VERSION_MSB		= PAGE_ADDR(PAGE_00, 0x02),
	PACKAGE_TYPE		= PAGE_ADDR(PAGE_00, 0x03),
	SR_REG			= PAGE_ADDR(PAGE_00, 0x0A),
	DDC_DISABLE		= PAGE_ADDR(PAGE_00, 0x0B),
	CCLK_ON			= PAGE_ADDR(PAGE_00, 0x0C),
	I2C_MASTER		= PAGE_ADDR(PAGE_00, 0x0D),
#ifdef TMFL_HDCP_OPTIMIZED_POWER
	FEAT_POWER_DOWN		= PAGE_ADDR(PAGE_00, 0x0E),
#endif
	INT_FLAGS_0		= PAGE_ADDR(PAGE_00, 0x0F),
	INT_FLAGS_1		= PAGE_ADDR(PAGE_00, 0x10),
	INT_FLAGS_2		= PAGE_ADDR(PAGE_00, 0x11),
	INT_FLAGS_3		= PAGE_ADDR(PAGE_00, 0x12),
	SW_INT			= PAGE_ADDR(PAGE_00, 0x15),
	ENA_ACLK		= PAGE_ADDR(PAGE_00, 0x16),
	ENA_VP_0		= PAGE_ADDR(PAGE_00, 0x18),
	ENA_VP_1		= PAGE_ADDR(PAGE_00, 0x19),
	ENA_VP_2		= PAGE_ADDR(PAGE_00, 0x1A),
	ENA_AP			= PAGE_ADDR(PAGE_00, 0x1E),
	VIP_CNTRL_0		= PAGE_ADDR(PAGE_00, 0x20),
	VIP_CNTRL_1		= PAGE_ADDR(PAGE_00, 0x21),
	VIP_CNTRL_2		= PAGE_ADDR(PAGE_00, 0x22),
	VIP_CNTRL_3		= PAGE_ADDR(PAGE_00, 0x23),
	VIP_CNTRL_4		= PAGE_ADDR(PAGE_00, 0x24),
	VIP_CNTRL_5		= PAGE_ADDR(PAGE_00, 0x25),
	MUX_AP			= PAGE_ADDR(PAGE_00, 0x26),
	MUX_VP_VIP_OUT		= PAGE_ADDR(PAGE_00, 0x27),
	MAT_CONTRL		= PAGE_ADDR(PAGE_00, 0x80),
	MAT_OI1_MSB		= PAGE_ADDR(PAGE_00, 0x81),
	MAT_OI1_LSB		= PAGE_ADDR(PAGE_00, 0x82),
	MAT_OI2_MSB		= PAGE_ADDR(PAGE_00, 0x83),
	MAT_OI2_LSB		= PAGE_ADDR(PAGE_00, 0x84),
	MAT_OI3_MSB		= PAGE_ADDR(PAGE_00, 0x85),
	MAT_OI3_LSB		= PAGE_ADDR(PAGE_00, 0x86),
	MAT_P11_MSB		= PAGE_ADDR(PAGE_00, 0x87),
	MAT_P11_LSB		= PAGE_ADDR(PAGE_00, 0x88),
	MAT_P12_MSB		= PAGE_ADDR(PAGE_00, 0x89),
	MAT_P12_LSB		= PAGE_ADDR(PAGE_00, 0x8A),
	MAT_P13_MSB		= PAGE_ADDR(PAGE_00, 0x8B),
	MAT_P13_LSB		= PAGE_ADDR(PAGE_00, 0x8C),
	MAT_P21_MSB		= PAGE_ADDR(PAGE_00, 0x8D),
	MAT_P21_LSB		= PAGE_ADDR(PAGE_00, 0x8E),
	MAT_P22_MSB		= PAGE_ADDR(PAGE_00, 0x8F),
	MAT_P22_LSB		= PAGE_ADDR(PAGE_00, 0x90),
	MAT_P23_MSB		= PAGE_ADDR(PAGE_00, 0x91),
	MAT_P23_LSB		= PAGE_ADDR(PAGE_00, 0x92),
	MAT_P31_MSB		= PAGE_ADDR(PAGE_00, 0x93),
	MAT_P31_LSB		= PAGE_ADDR(PAGE_00, 0x94),
	MAT_P32_MSB		= PAGE_ADDR(PAGE_00, 0x95),
	MAT_P32_LSB		= PAGE_ADDR(PAGE_00, 0x96),
	MAT_P33_MSB		= PAGE_ADDR(PAGE_00, 0x97),
	MAT_P33_LSB		= PAGE_ADDR(PAGE_00, 0x98),
	MAT_OO1_MSB		= PAGE_ADDR(PAGE_00, 0x99),
	MAT_OO1_LSB		= PAGE_ADDR(PAGE_00, 0x9A),
	MAT_OO2_MSB		= PAGE_ADDR(PAGE_00, 0x9B),
	MAT_OO2_LSB		= PAGE_ADDR(PAGE_00, 0x9C),
	MAT_OO3_MSB		= PAGE_ADDR(PAGE_00, 0x9D),
	MAT_OO3_LSB		= PAGE_ADDR(PAGE_00, 0x9E),
	VIDFORMAT		= PAGE_ADDR(PAGE_00, 0xA0),
	REFPIX_MSB		= PAGE_ADDR(PAGE_00, 0xA1),
	REFPIX_LSB		= PAGE_ADDR(PAGE_00, 0xA2),
	REFLINE_MSB		= PAGE_ADDR(PAGE_00, 0xA3),
	REFLINE_LSB		= PAGE_ADDR(PAGE_00, 0xA4),
	NPIX_MSB		= PAGE_ADDR(PAGE_00, 0xA5),
	NPIX_LSB		= PAGE_ADDR(PAGE_00, 0xA6),
	NLINE_MSB		= PAGE_ADDR(PAGE_00, 0xA7),
	NLINE_LSB		= PAGE_ADDR(PAGE_00, 0xA8),
	VS_LINE_STRT_1_MSB	= PAGE_ADDR(PAGE_00, 0xA9),
	VS_LINE_STRT_1_LSB	= PAGE_ADDR(PAGE_00, 0xAA),
	VS_PIX_STRT_1_MSB	= PAGE_ADDR(PAGE_00, 0xAB),
	VS_PIX_STRT_1_LSB	= PAGE_ADDR(PAGE_00, 0xAC),
	VS_LINE_END_1_MSB	= PAGE_ADDR(PAGE_00, 0xAD),
	VS_LINE_END_1_LSB	= PAGE_ADDR(PAGE_00, 0xAE),
	VS_PIX_END_1_MSB	= PAGE_ADDR(PAGE_00, 0xAF),
	VS_PIX_END_1_LSB	= PAGE_ADDR(PAGE_00, 0xB0),
	VS_LINE_STRT_2_MSB	= PAGE_ADDR(PAGE_00, 0xB1),
	VS_LINE_STRT_2_LSB	= PAGE_ADDR(PAGE_00, 0xB2),
	VS_PIX_STRT_2_MSB	= PAGE_ADDR(PAGE_00, 0xB3),
	VS_PIX_STRT_2_LSB	= PAGE_ADDR(PAGE_00, 0xB4),
	VS_LINE_END_2_MSB	= PAGE_ADDR(PAGE_00, 0xB5),
	VS_LINE_END_2_LSB	= PAGE_ADDR(PAGE_00, 0xB6),
	VS_PIX_END_2_MSB	= PAGE_ADDR(PAGE_00, 0xB7),
	VS_PIX_END_2_LSB	= PAGE_ADDR(PAGE_00, 0xB8),
	HS_PIX_START_MSB	= PAGE_ADDR(PAGE_00, 0xB9),
	HS_PIX_START_LSB	= PAGE_ADDR(PAGE_00, 0xBA),
	HS_PIX_STOP_MSB		= PAGE_ADDR(PAGE_00, 0xBB),
	HS_PIX_STOP_LSB		= PAGE_ADDR(PAGE_00, 0xBC),
	VWIN_START_1_MSB	= PAGE_ADDR(PAGE_00, 0xBD),
	VWIN_START_1_LSB	= PAGE_ADDR(PAGE_00, 0xBE),
	VWIN_END_1_MSB		= PAGE_ADDR(PAGE_00, 0xBF),
	VWIN_END_1_LSB		= PAGE_ADDR(PAGE_00, 0xC0),
	VWIN_START_2_MSB	= PAGE_ADDR(PAGE_00, 0xC1),
	VWIN_START_2_LSB	= PAGE_ADDR(PAGE_00, 0xC2),
	VWIN_END_2_MSB		= PAGE_ADDR(PAGE_00, 0xC3),
	VWIN_END_2_LSB		= PAGE_ADDR(PAGE_00, 0xC4),
	DE_START_MSB		= PAGE_ADDR(PAGE_00, 0xC5),
	DE_START_LSB		= PAGE_ADDR(PAGE_00, 0xC6),
	DE_STOP_MSB		= PAGE_ADDR(PAGE_00, 0xC7),
	DE_STOP_LSB		= PAGE_ADDR(PAGE_00, 0xC8),
	COLBAR_WIDTH		= PAGE_ADDR(PAGE_00, 0xC9),
	TBG_CNTRL_0		= PAGE_ADDR(PAGE_00, 0xCA),
	TBG_CNTRL_1		= PAGE_ADDR(PAGE_00, 0xCB),
	VBL_OFFSET_START	= PAGE_ADDR(PAGE_00, 0xCC),
	VBL_OFFSET_END		= PAGE_ADDR(PAGE_00, 0xCD),
	HBL_OFFSET_START	= PAGE_ADDR(PAGE_00, 0xCE),
	HBL_OFFSET_END		= PAGE_ADDR(PAGE_00, 0xCF),
	DWIN_RE_DE		= PAGE_ADDR(PAGE_00, 0xD0),
	DWIN_FE_DE		= PAGE_ADDR(PAGE_00, 0xD1),
#ifdef TMFL_RGB_DDR_12BITS
	VSPACE_START_MSB	= PAGE_ADDR(PAGE_00, 0xD2),
	VSPACE_START_LSB	= PAGE_ADDR(PAGE_00, 0xD3),
	VSPACE_END_MSB		= PAGE_ADDR(PAGE_00, 0xD4),
	VSPACE_END_LSB		= PAGE_ADDR(PAGE_00, 0xD5),
	ENABLE_SPACE		= PAGE_ADDR(PAGE_00, 0xD6),
	VSPACE_Y_DATA		= PAGE_ADDR(PAGE_00, 0xD7),
	VSPACE_U_DATA		= PAGE_ADDR(PAGE_00, 0xD8),
	VSPACE_V_DATA		= PAGE_ADDR(PAGE_00, 0xD9),
#endif
	TIMER_RI_PJ		= PAGE_ADDR(PAGE_00, 0xE1),
	BCAPS_POLL		= PAGE_ADDR(PAGE_00, 0xE2),
	REG_100us		= PAGE_ADDR(PAGE_00, 0xE3),
	HVF_CNTRL_0		= PAGE_ADDR(PAGE_00, 0xE4),
	HVF_CNTRL_1		= PAGE_ADDR(PAGE_00, 0xE5),
	TIMER_H			= PAGE_ADDR(PAGE_00, 0xE8),
	TIMER_M			= PAGE_ADDR(PAGE_00, 0xE9),
	TIMER_L			= PAGE_ADDR(PAGE_00, 0xEA),
	TIMER_2SEC		= PAGE_ADDR(PAGE_00, 0xEB),
	TIMER_5SEC		= PAGE_ADDR(PAGE_00, 0xEC),
	NDIV_IM			= PAGE_ADDR(PAGE_00, 0xEE),
	NDIV_PF			= PAGE_ADDR(PAGE_00, 0xEF),
	RPT_CNTRL		= PAGE_ADDR(PAGE_00, 0xF0),
	LEAD_OFF		= PAGE_ADDR(PAGE_00, 0xF1),
	TRAIL_OFF		= PAGE_ADDR(PAGE_00, 0xF2),
	MISR_EXP_0		= PAGE_ADDR(PAGE_00, 0xF3),
	MISR_EXP_1		= PAGE_ADDR(PAGE_00, 0xF4),
	MISR_EXP_2		= PAGE_ADDR(PAGE_00, 0xF5),
	MISR_0			= PAGE_ADDR(PAGE_00, 0xF6),
	MISR_1			= PAGE_ADDR(PAGE_00, 0xF7),
	DEBUG_PROBE		= PAGE_ADDR(PAGE_00, 0xF8),
	GHOST_XADDR		= PAGE_ADDR(PAGE_00, 0xF9),
	MISR_2			= PAGE_ADDR(PAGE_00, 0xFA),
	I2S_FORMAT		= PAGE_ADDR(PAGE_00, 0xFC),
	AIP_CLKSEL		= PAGE_ADDR(PAGE_00, 0xFD),
	GHOST_ADDR		= PAGE_ADDR(PAGE_00, 0xFE),
	SC_VIDFORMAT		= PAGE_ADDR(PAGE_01, 0x00),
	SC_CNTRL		= PAGE_ADDR(PAGE_01, 0x01),
	SC_DELTA_PHASE_V	= PAGE_ADDR(PAGE_01, 0x02),
	SC_DELTA_PHASE_H	= PAGE_ADDR(PAGE_01, 0x03),
	SC_START_PHASE_H	= PAGE_ADDR(PAGE_01, 0x04),
	SC_NPIX_IN_LSB		= PAGE_ADDR(PAGE_01, 0x05),
	SC_NPIX_IN_MSB		= PAGE_ADDR(PAGE_01, 0x06),
	SC_NPIX_OUT_LSB		= PAGE_ADDR(PAGE_01, 0x07),
	SC_NPIX_OUT_MSB		= PAGE_ADDR(PAGE_01, 0x08),
	SC_NLINE_IN_LSB		= PAGE_ADDR(PAGE_01, 0x09),
	SC_NLINE_IN_MSB		= PAGE_ADDR(PAGE_01, 0x0A),
	SC_NLINE_OUT_LSB	= PAGE_ADDR(PAGE_01, 0x0B),
	SC_NLINE_OUT_MSB	= PAGE_ADDR(PAGE_01, 0x0C),
	SC_NLINE_SKIP		= PAGE_ADDR(PAGE_01, 0x0D),
	SC_SAMPLE_BUFFIL	= PAGE_ADDR(PAGE_01, 0x0E),
	SC_MAX_BUFFILL_P_0	= PAGE_ADDR(PAGE_01, 0x0F),
	SC_MAX_BUFFILL_P_1	= PAGE_ADDR(PAGE_01, 0x10),
	SC_MAX_BUFFILL_D_0	= PAGE_ADDR(PAGE_01, 0x11),
	SC_MAX_BUFFILL_D_1	= PAGE_ADDR(PAGE_01, 0x12),
	SC_SAMPLE_FIFOFILL	= PAGE_ADDR(PAGE_01, 0x13),
	SC_MAX_FIFOFILL_PI	= PAGE_ADDR(PAGE_01, 0x14),
	SC_MIN_FIFOFILL_PO1	= PAGE_ADDR(PAGE_01, 0x15),
	SC_MIN_FIFOFILL_PO2	= PAGE_ADDR(PAGE_01, 0x16),
	SC_MIN_FIFOFILL_PO3	= PAGE_ADDR(PAGE_01, 0x17),
	SC_MIN_FIFOFILL_PO4	= PAGE_ADDR(PAGE_01, 0x18),
	SC_MAX_FIFOFILL_DI	= PAGE_ADDR(PAGE_01, 0x19),
	SC_MAX_FIFOFILL_DO	= PAGE_ADDR(PAGE_01, 0x1A),
	SC_VS_LUT_0		= PAGE_ADDR(PAGE_01, 0x1B),
	SC_VS_LUT_1		= PAGE_ADDR(PAGE_01, 0x1C),
	SC_VS_LUT_2		= PAGE_ADDR(PAGE_01, 0x1D),
	SC_VS_LUT_3		= PAGE_ADDR(PAGE_01, 0x1E),
	SC_VS_LUT_4		= PAGE_ADDR(PAGE_01, 0x1F),
	SC_VS_LUT_5		= PAGE_ADDR(PAGE_01, 0x20),
	SC_VS_LUT_6		= PAGE_ADDR(PAGE_01, 0x21),
	SC_VS_LUT_7		= PAGE_ADDR(PAGE_01, 0x22),
	SC_VS_LUT_8		= PAGE_ADDR(PAGE_01, 0x23),
	SC_VS_LUT_9		= PAGE_ADDR(PAGE_01, 0x24),
	SC_VS_LUT_10		= PAGE_ADDR(PAGE_01, 0x25),
	SC_VS_LUT_11		= PAGE_ADDR(PAGE_01, 0x26),
	SC_VS_LUT_12		= PAGE_ADDR(PAGE_01, 0x27),
	SC_VS_LUT_13		= PAGE_ADDR(PAGE_01, 0x28),
	SC_VS_LUT_14		= PAGE_ADDR(PAGE_01, 0x29),
	SC_VS_LUT_15		= PAGE_ADDR(PAGE_01, 0x2A),
	SC_VS_LUT_16		= PAGE_ADDR(PAGE_01, 0x2B),
	SC_VS_LUT_17		= PAGE_ADDR(PAGE_01, 0x2C),
	SC_VS_LUT_18		= PAGE_ADDR(PAGE_01, 0x2D),
	SC_VS_LUT_19		= PAGE_ADDR(PAGE_01, 0x2E),
	SC_VS_LUT_20		= PAGE_ADDR(PAGE_01, 0x2F),
	SC_VS_LUT_21		= PAGE_ADDR(PAGE_01, 0x30),
	SC_VS_LUT_22		= PAGE_ADDR(PAGE_01, 0x31),
	SC_VS_LUT_23		= PAGE_ADDR(PAGE_01, 0x32),
	SC_VS_LUT_24		= PAGE_ADDR(PAGE_01, 0x33),
	SC_VS_LUT_25		= PAGE_ADDR(PAGE_01, 0x34),
	SC_VS_LUT_26		= PAGE_ADDR(PAGE_01, 0x35),
	SC_VS_LUT_27		= PAGE_ADDR(PAGE_01, 0x36),
	SC_VS_LUT_28		= PAGE_ADDR(PAGE_01, 0x37),
	SC_VS_LUT_29		= PAGE_ADDR(PAGE_01, 0x38),
	SC_VS_LUT_30		= PAGE_ADDR(PAGE_01, 0x39),
	SC_VS_LUT_31		= PAGE_ADDR(PAGE_01, 0x3A),
	SC_VS_LUT_32		= PAGE_ADDR(PAGE_01, 0x3B),
	SC_VS_LUT_33		= PAGE_ADDR(PAGE_01, 0x3C),
	SC_VS_LUT_34		= PAGE_ADDR(PAGE_01, 0x3D),
	SC_VS_LUT_35		= PAGE_ADDR(PAGE_01, 0x3E),
	SC_VS_LUT_36		= PAGE_ADDR(PAGE_01, 0x3F),
	SC_VS_LUT_37		= PAGE_ADDR(PAGE_01, 0x40),
	SC_VS_LUT_38		= PAGE_ADDR(PAGE_01, 0x41),
	SC_VS_LUT_39		= PAGE_ADDR(PAGE_01, 0x42),
	SC_VS_LUT_40		= PAGE_ADDR(PAGE_01, 0x43),
	SC_VS_LUT_41		= PAGE_ADDR(PAGE_01, 0x44),
	SC_VS_LUT_42		= PAGE_ADDR(PAGE_01, 0x45),
	SC_VS_LUT_43		= PAGE_ADDR(PAGE_01, 0x46),
	SC_VS_LUT_44		= PAGE_ADDR(PAGE_01, 0x47),
	SC_LAT_SCO		= PAGE_ADDR(PAGE_01, 0x48),
	VIDFORMAT_W		= PAGE_ADDR(PAGE_01, 0xA0),
	REFPIX_MSB_W		= PAGE_ADDR(PAGE_01, 0xA1),
	REFPIX_LSB_W		= PAGE_ADDR(PAGE_01, 0xA2),
	REFLINE_MSB_W		= PAGE_ADDR(PAGE_01, 0xA3),
	REFLINE_LSB_W		= PAGE_ADDR(PAGE_01, 0xA4),
	NPIX_MSB_W		= PAGE_ADDR(PAGE_01, 0xA5),
	NPIX_LSB_W		= PAGE_ADDR(PAGE_01, 0xA6),
	NLINE_MSB_W		= PAGE_ADDR(PAGE_01, 0xA7),
	NLINE_LSB_W		= PAGE_ADDR(PAGE_01, 0xA8),
	VWIN_START_1_MSB_W	= PAGE_ADDR(PAGE_01, 0xBD),
	VWIN_START_1_LSB_W	= PAGE_ADDR(PAGE_01, 0xBE),
	VWIN_END_1_MSB_W	= PAGE_ADDR(PAGE_01, 0xBF),
	VWIN_END_1_LSB_W	= PAGE_ADDR(PAGE_01, 0xC0),
	VWIN_START_2_MSB_W	= PAGE_ADDR(PAGE_01, 0xC1),
	VWIN_START_2_LSB_W	= PAGE_ADDR(PAGE_01, 0xC2),
	VWIN_END_2_MSB_W	= PAGE_ADDR(PAGE_01, 0xC3),
	VWIN_END_2_LSB_W	= PAGE_ADDR(PAGE_01, 0xC4),
	DE_START_MSB_W		= PAGE_ADDR(PAGE_01, 0xC5),
	DE_START_LSB_W		= PAGE_ADDR(PAGE_01, 0xC6),
	DE_STOP_MSB_W		= PAGE_ADDR(PAGE_01, 0xC7),
	DE_STOP_LSB_W		= PAGE_ADDR(PAGE_01, 0xC8),
	TBG_CNTRL_0_W		= PAGE_ADDR(PAGE_01, 0xCA),
	PLL_SERIAL_1_RW		= PAGE_ADDR(PAGE_02, 0x00),
	PLL_SERIAL_2_RW		= PAGE_ADDR(PAGE_02, 0x01),
	PLL_SERIAL_3_RW		= PAGE_ADDR(PAGE_02, 0x02),
	SERIALIZER_RW		= PAGE_ADDR(PAGE_02, 0x03),
	BUFFER_OUT		= PAGE_ADDR(PAGE_02, 0x04),
	PLL_SCG1_RW		= PAGE_ADDR(PAGE_02, 0x05),
	PLL_SCG2_RW		= PAGE_ADDR(PAGE_02, 0x06),
	PLL_SCGN1_RW		= PAGE_ADDR(PAGE_02, 0x07),
	PLL_SCGN2_RW		= PAGE_ADDR(PAGE_02, 0x08),
	PLL_SCGR1_RW		= PAGE_ADDR(PAGE_02, 0x09),
	PLL_SCGR2_RW		= PAGE_ADDR(PAGE_02, 0x0A),
	VAI_PLL_R		= PAGE_ADDR(PAGE_02, 0x0D),
	AUDIO_DIV_RW		= PAGE_ADDR(PAGE_02, 0x0E),
	TEST1_RW		= PAGE_ADDR(PAGE_02, 0x0F),
	TEST2_RW		= PAGE_ADDR(PAGE_02, 0x10),
	SEL_CLK_RW		= PAGE_ADDR(PAGE_02, 0x11),
	ANA_GENERAL		= PAGE_ADDR(PAGE_02, 0x12),
	BUFFER_OUT2_RW		= PAGE_ADDR(PAGE_02, 0x13),
	SRL_TSTPAT0_RW		= PAGE_ADDR(PAGE_02, 0x14),
	SRL_TSTPAT1_RW		= PAGE_ADDR(PAGE_02, 0x15),
	SRL_TSTPAT2_RW		= PAGE_ADDR(PAGE_02, 0x16),
	SRL_TSTPAT3_RW		= PAGE_ADDR(PAGE_02, 0x17),
	EDID_DATA_0_R		= PAGE_ADDR(PAGE_09, 0x00),
//	EDID_DATA_1_R		= PAGE_ADDR(PAGE_09, 0x01),
//	EDID_DATA_2_R		= PAGE_ADDR(PAGE_09, 0x02),
//	EDID_DATA_3_R		= PAGE_ADDR(PAGE_09, 0x03),
//	EDID_DATA_4_R		= PAGE_ADDR(PAGE_09, 0x04),
//	EDID_DATA_5_R		= PAGE_ADDR(PAGE_09, 0x05),
//	EDID_DATA_6_R		= PAGE_ADDR(PAGE_09, 0x06),
//	EDID_DATA_7_R		= PAGE_ADDR(PAGE_09, 0x07),
//	EDID_DATA_8_R		= PAGE_ADDR(PAGE_09, 0x08),
//	EDID_DATA_9_R		= PAGE_ADDR(PAGE_09, 0x09),
//	EDID_DATA_10_R		= PAGE_ADDR(PAGE_09, 0x0A),
//	EDID_DATA_11_R		= PAGE_ADDR(PAGE_09, 0x0B),
//	EDID_DATA_12_R		= PAGE_ADDR(PAGE_09, 0x0C),
//	EDID_DATA_13_R		= PAGE_ADDR(PAGE_09, 0x0D),
//	EDID_DATA_14_R		= PAGE_ADDR(PAGE_09, 0x0E),
//	EDID_DATA_15_R		= PAGE_ADDR(PAGE_09, 0x0F),
//	EDID_DATA_16_R		= PAGE_ADDR(PAGE_09, 0x10),
//	EDID_DATA_17_R		= PAGE_ADDR(PAGE_09, 0x11),
//	EDID_DATA_18_R		= PAGE_ADDR(PAGE_09, 0x12),
//	EDID_DATA_19_R		= PAGE_ADDR(PAGE_09, 0x13),
//	EDID_DATA_20_R		= PAGE_ADDR(PAGE_09, 0x14),
//	EDID_DATA_21_R		= PAGE_ADDR(PAGE_09, 0x15),
//	EDID_DATA_22_R		= PAGE_ADDR(PAGE_09, 0x16),
//	EDID_DATA_23_R		= PAGE_ADDR(PAGE_09, 0x17),
//	EDID_DATA_24_R		= PAGE_ADDR(PAGE_09, 0x18),
//	EDID_DATA_25_R		= PAGE_ADDR(PAGE_09, 0x19),
//	EDID_DATA_26_R		= PAGE_ADDR(PAGE_09, 0x1A),
//	EDID_DATA_27_R		= PAGE_ADDR(PAGE_09, 0x1B),
//	EDID_DATA_28_R		= PAGE_ADDR(PAGE_09, 0x1C),
//	EDID_DATA_29_R		= PAGE_ADDR(PAGE_09, 0x1D),
//	EDID_DATA_30_R		= PAGE_ADDR(PAGE_09, 0x1E),
//	EDID_DATA_31_R		= PAGE_ADDR(PAGE_09, 0x1F),
//	EDID_DATA_32_R		= PAGE_ADDR(PAGE_09, 0x20),
//	EDID_DATA_33_R		= PAGE_ADDR(PAGE_09, 0x21),
//	EDID_DATA_34_R 		= PAGE_ADDR(PAGE_09, 0x22),
//	EDID_DATA_35_R		= PAGE_ADDR(PAGE_09, 0x23),
//	EDID_DATA_36_R		= PAGE_ADDR(PAGE_09, 0x24),
//	EDID_DATA_37_R		= PAGE_ADDR(PAGE_09, 0x25),
//	EDID_DATA_38_R		= PAGE_ADDR(PAGE_09, 0x26),
//	EDID_DATA_39_R		= PAGE_ADDR(PAGE_09, 0x27),
//	EDID_DATA_40_R		= PAGE_ADDR(PAGE_09, 0x28),
//	EDID_DATA_41_R		= PAGE_ADDR(PAGE_09, 0x29),
//	EDID_DATA_42_R		= PAGE_ADDR(PAGE_09, 0x2A),
//	EDID_DATA_43_R		= PAGE_ADDR(PAGE_09, 0x2B),
//	EDID_DATA_44_R		= PAGE_ADDR(PAGE_09, 0x2C),
//	EDID_DATA_45_R		= PAGE_ADDR(PAGE_09, 0x2D),
//	EDID_DATA_46_R		= PAGE_ADDR(PAGE_09, 0x2E),
//	EDID_DATA_47_R		= PAGE_ADDR(PAGE_09, 0x2F),
//	EDID_DATA_48_R		= PAGE_ADDR(PAGE_09, 0x30),
//	EDID_DATA_49_R		= PAGE_ADDR(PAGE_09, 0x31),
//	EDID_DATA_50_R		= PAGE_ADDR(PAGE_09, 0x32),
//	EDID_DATA_51_R		= PAGE_ADDR(PAGE_09, 0x33),
//	EDID_DATA_52_R		= PAGE_ADDR(PAGE_09, 0x34),
//	EDID_DATA_53_R		= PAGE_ADDR(PAGE_09, 0x35),
//	EDID_DATA_54_R		= PAGE_ADDR(PAGE_09, 0x36),
//	EDID_DATA_55_R		= PAGE_ADDR(PAGE_09, 0x37),
//	EDID_DATA_56_R		= PAGE_ADDR(PAGE_09, 0x38),
//	EDID_DATA_57_R		= PAGE_ADDR(PAGE_09, 0x39),
//	EDID_DATA_58_R		= PAGE_ADDR(PAGE_09, 0x3A),
//	EDID_DATA_59_R		= PAGE_ADDR(PAGE_09, 0x3B),
//	EDID_DATA_60_R		= PAGE_ADDR(PAGE_09, 0x3C),
//	EDID_DATA_61_R		= PAGE_ADDR(PAGE_09, 0x3D),
//	EDID_DATA_62_R		= PAGE_ADDR(PAGE_09, 0x3E),
//	EDID_DATA_63_R		= PAGE_ADDR(PAGE_09, 0x3F),
//	EDID_DATA_64_R		= PAGE_ADDR(PAGE_09, 0x40),
//	EDID_DATA_65_R		= PAGE_ADDR(PAGE_09, 0x41),
//	EDID_DATA_66_R		= PAGE_ADDR(PAGE_09, 0x42),
//	EDID_DATA_67_R		= PAGE_ADDR(PAGE_09, 0x43),
//	EDID_DATA_68_R		= PAGE_ADDR(PAGE_09, 0x44),
//	EDID_DATA_69_R		= PAGE_ADDR(PAGE_09, 0x45),
//	EDID_DATA_70_R		= PAGE_ADDR(PAGE_09, 0x46),
//	EDID_DATA_71_R		= PAGE_ADDR(PAGE_09, 0x47),
//	EDID_DATA_72_R		= PAGE_ADDR(PAGE_09, 0x48),
//	EDID_DATA_73_R		= PAGE_ADDR(PAGE_09, 0x49),
//	EDID_DATA_74_R		= PAGE_ADDR(PAGE_09, 0x4A),
//	EDID_DATA_75_R		= PAGE_ADDR(PAGE_09, 0x4B),
//	EDID_DATA_76_R		= PAGE_ADDR(PAGE_09, 0x4C),
//	EDID_DATA_77_R		= PAGE_ADDR(PAGE_09, 0x4D),
//	EDID_DATA_78_R		= PAGE_ADDR(PAGE_09, 0x4E),
//	EDID_DATA_79_R		= PAGE_ADDR(PAGE_09, 0x4F),
//	EDID_DATA_80_R		= PAGE_ADDR(PAGE_09, 0x50),
//	EDID_DATA_81_R		= PAGE_ADDR(PAGE_09, 0x51),
//	EDID_DATA_82_R		= PAGE_ADDR(PAGE_09, 0x52),
//	EDID_DATA_83_R		= PAGE_ADDR(PAGE_09, 0x53),
//	EDID_DATA_84_R		= PAGE_ADDR(PAGE_09, 0x54),
//	EDID_DATA_85_R		= PAGE_ADDR(PAGE_09, 0x55),
//	EDID_DATA_86_R		= PAGE_ADDR(PAGE_09, 0x56),
//	EDID_DATA_87_R		= PAGE_ADDR(PAGE_09, 0x57),
//	EDID_DATA_88_R		= PAGE_ADDR(PAGE_09, 0x58),
//	EDID_DATA_89_R		= PAGE_ADDR(PAGE_09, 0x59),
//	EDID_DATA_90_R		= PAGE_ADDR(PAGE_09, 0x5A),
//	EDID_DATA_91_R		= PAGE_ADDR(PAGE_09, 0x5B),
//	EDID_DATA_92_R		= PAGE_ADDR(PAGE_09, 0x5C),
//	EDID_DATA_93_R		= PAGE_ADDR(PAGE_09, 0x5D),
//	EDID_DATA_94_R		= PAGE_ADDR(PAGE_09, 0x5E),
//	EDID_DATA_95_R		= PAGE_ADDR(PAGE_09, 0x5F),
//	EDID_DATA_96_R		= PAGE_ADDR(PAGE_09, 0x60),
//	EDID_DATA_97_R		= PAGE_ADDR(PAGE_09, 0x61),
//	EDID_DATA_98_R		= PAGE_ADDR(PAGE_09, 0x62),
//	EDID_DATA_99_R		= PAGE_ADDR(PAGE_09, 0x63),
//	EDID_DATA_100_R		= PAGE_ADDR(PAGE_09, 0x64),
//	EDID_DATA_101_R		= PAGE_ADDR(PAGE_09, 0x65),
//	EDID_DATA_102_R		= PAGE_ADDR(PAGE_09, 0x66),
//	EDID_DATA_103_R		= PAGE_ADDR(PAGE_09, 0x67),
//	EDID_DATA_104_R		= PAGE_ADDR(PAGE_09, 0x68),
//	EDID_DATA_105_R		= PAGE_ADDR(PAGE_09, 0x69),
//	EDID_DATA_106_R		= PAGE_ADDR(PAGE_09, 0x6A),
//	EDID_DATA_107_R		= PAGE_ADDR(PAGE_09, 0x6B),
//	EDID_DATA_108_R		= PAGE_ADDR(PAGE_09, 0x6C),
//	EDID_DATA_109_R		= PAGE_ADDR(PAGE_09, 0x6D),
//	EDID_DATA_110_R		= PAGE_ADDR(PAGE_09, 0x6E),
//	EDID_DATA_111_R		= PAGE_ADDR(PAGE_09, 0x6F),
//	EDID_DATA_112_R		= PAGE_ADDR(PAGE_09, 0x70),
//	EDID_DATA_113_R		= PAGE_ADDR(PAGE_09, 0x71),
//	EDID_DATA_114_R		= PAGE_ADDR(PAGE_09, 0x72),
//	EDID_DATA_115_R		= PAGE_ADDR(PAGE_09, 0x73),
//	EDID_DATA_116_R		= PAGE_ADDR(PAGE_09, 0x74),
//	EDID_DATA_117_R		= PAGE_ADDR(PAGE_09, 0x75),
//	EDID_DATA_118_R		= PAGE_ADDR(PAGE_09, 0x76),
//	EDID_DATA_119_R		= PAGE_ADDR(PAGE_09, 0x77),
//	EDID_DATA_120_R		= PAGE_ADDR(PAGE_09, 0x78),
//	EDID_DATA_121_R		= PAGE_ADDR(PAGE_09, 0x79),
//	EDID_DATA_122_R		= PAGE_ADDR(PAGE_09, 0x7A),
//	EDID_DATA_123_R		= PAGE_ADDR(PAGE_09, 0x7B),
//	EDID_DATA_124_R		= PAGE_ADDR(PAGE_09, 0x7C),
//	EDID_DATA_125_R		= PAGE_ADDR(PAGE_09, 0x7D),
//	EDID_DATA_126_R		= PAGE_ADDR(PAGE_09, 0x7E),
//	EDID_DATA_127_R		= PAGE_ADDR(PAGE_09, 0x7F),
	EDID_CTRL_RW		= PAGE_ADDR(PAGE_09, 0xFA),
	DDC_ADDR_RW		= PAGE_ADDR(PAGE_09, 0xFB),
	DDC_OFFS_RW		= PAGE_ADDR(PAGE_09, 0xFC),
	DDC_SEGM_ADDR_RW	= PAGE_ADDR(PAGE_09, 0xFD),
	DDC_SEGM_RW		= PAGE_ADDR(PAGE_09, 0xFE),
	IF1_HB0_RW		= PAGE_ADDR(PAGE_10, 0x20),
//	IF1_HB1_RW		= PAGE_ADDR(PAGE_10, 0x21),
//	IF1_HB2_RW		= PAGE_ADDR(PAGE_10, 0x22),
	IF1_PB0_RW		= PAGE_ADDR(PAGE_10, 0x23),
//	IF1_PB1_RW		= PAGE_ADDR(PAGE_10, 0x24),
//	IF1_PB2_RW		= PAGE_ADDR(PAGE_10, 0x25),
//	IF1_PB3_RW		= PAGE_ADDR(PAGE_10, 0x26),
//	IF1_PB4_RW		= PAGE_ADDR(PAGE_10, 0x27),
//	IF1_PB5_RW		= PAGE_ADDR(PAGE_10, 0x28),
//	IF1_PB6_RW		= PAGE_ADDR(PAGE_10, 0x29),
//	IF1_PB7_RW		= PAGE_ADDR(PAGE_10, 0x2A),
//	IF1_PB8_RW		= PAGE_ADDR(PAGE_10, 0x2B),
//	IF1_PB9_RW		= PAGE_ADDR(PAGE_10, 0x2C),
	IF1_PB10_RW		= PAGE_ADDR(PAGE_10, 0x2D),
//	IF1_PB11_RW		= PAGE_ADDR(PAGE_10, 0x2E),
//	IF1_PB12_RW		= PAGE_ADDR(PAGE_10, 0x2F),
//	IF1_PB13_RW		= PAGE_ADDR(PAGE_10, 0x30),
//	IF1_PB14_RW		= PAGE_ADDR(PAGE_10, 0x31),
//	IF1_PB15_RW		= PAGE_ADDR(PAGE_10, 0x32),
//	IF1_PB16_RW		= PAGE_ADDR(PAGE_10, 0x33),
//	IF1_PB17_RW		= PAGE_ADDR(PAGE_10, 0x34),
//	IF1_PB18_RW		= PAGE_ADDR(PAGE_10, 0x35),
//	IF1_PB19_RW		= PAGE_ADDR(PAGE_10, 0x36),
//	IF1_PB20_RW		= PAGE_ADDR(PAGE_10, 0x37),
//	IF1_PB21_RW		= PAGE_ADDR(PAGE_10, 0x38),
//	IF1_PB22_RW		= PAGE_ADDR(PAGE_10, 0x39),
//	IF1_PB23_RW		= PAGE_ADDR(PAGE_10, 0x3A),
//	IF1_PB24_RW		= PAGE_ADDR(PAGE_10, 0x3B),
//	IF1_PB25_RW		= PAGE_ADDR(PAGE_10, 0x3C),
//	IF1_PB26_RW		= PAGE_ADDR(PAGE_10, 0x3D),
//	IF1_PB27_RW		= PAGE_ADDR(PAGE_10, 0x3E),
	IF2_HB0_RW		= PAGE_ADDR(PAGE_10, 0x40),
//	IF2_HB1_RW		= PAGE_ADDR(PAGE_10, 0x41),
//	IF2_HB2_RW		= PAGE_ADDR(PAGE_10, 0x42),
	IF2_PB0_RW		= PAGE_ADDR(PAGE_10, 0x43),
//	IF2_PB1_RW		= PAGE_ADDR(PAGE_10, 0x44),
//	IF2_PB2_RW		= PAGE_ADDR(PAGE_10, 0x45),
//	IF2_PB3_RW		= PAGE_ADDR(PAGE_10, 0x46),
//	IF2_PB4_RW		= PAGE_ADDR(PAGE_10, 0x47),
//	IF2_PB5_RW		= PAGE_ADDR(PAGE_10, 0x48),
//	IF2_PB6_RW		= PAGE_ADDR(PAGE_10, 0x49),
//	IF2_PB7_RW		= PAGE_ADDR(PAGE_10, 0x4A),
//	IF2_PB8_RW		= PAGE_ADDR(PAGE_10, 0x4B),
//	IF2_PB9_RW		= PAGE_ADDR(PAGE_10, 0x4C),
//	IF2_PB10_RW		= PAGE_ADDR(PAGE_10, 0x4D),
//	IF2_PB11_RW		= PAGE_ADDR(PAGE_10, 0x4E),
//	IF2_PB12_RW		= PAGE_ADDR(PAGE_10, 0x4F),
//	IF2_PB13_RW		= PAGE_ADDR(PAGE_10, 0x50),
//	IF2_PB14_RW		= PAGE_ADDR(PAGE_10, 0x51),
//	IF2_PB15_RW		= PAGE_ADDR(PAGE_10, 0x52),
//	IF2_PB16_RW		= PAGE_ADDR(PAGE_10, 0x53),
//	IF2_PB17_RW		= PAGE_ADDR(PAGE_10, 0x54),
//	IF2_PB18_RW		= PAGE_ADDR(PAGE_10, 0x55),
//	IF2_PB19_RW		= PAGE_ADDR(PAGE_10, 0x56),
//	IF2_PB20_RW		= PAGE_ADDR(PAGE_10, 0x57),
//	IF2_PB21_RW		= PAGE_ADDR(PAGE_10, 0x58),
//	IF2_PB22_RW		= PAGE_ADDR(PAGE_10, 0x59),
//	IF2_PB23_RW		= PAGE_ADDR(PAGE_10, 0x5A),
//	IF2_PB24_RW		= PAGE_ADDR(PAGE_10, 0x5B),
//	IF2_PB25_RW		= PAGE_ADDR(PAGE_10, 0x5C),
//	IF2_PB26_RW		= PAGE_ADDR(PAGE_10, 0x5D),
//	IF2_PB27_RW		= PAGE_ADDR(PAGE_10, 0x5E),
	IF3_HB0_RW		= PAGE_ADDR(PAGE_10, 0x60),
//	IF3_HB1_RW		= PAGE_ADDR(PAGE_10, 0x61),
//	IF3_HB2_RW		= PAGE_ADDR(PAGE_10, 0x62),
	IF3_PB0_RW		= PAGE_ADDR(PAGE_10, 0x63),
//	IF3_PB1_RW		= PAGE_ADDR(PAGE_10, 0x64),
//	IF3_PB2_RW		= PAGE_ADDR(PAGE_10, 0x65),
//	IF3_PB3_RW		= PAGE_ADDR(PAGE_10, 0x66),
//	IF3_PB4_RW		= PAGE_ADDR(PAGE_10, 0x67),
//	IF3_PB5_RW		= PAGE_ADDR(PAGE_10, 0x68),
//	IF3_PB6_RW		= PAGE_ADDR(PAGE_10, 0x69),
//	IF3_PB7_RW		= PAGE_ADDR(PAGE_10, 0x6A),
//	IF3_PB8_RW		= PAGE_ADDR(PAGE_10, 0x6B),
//	IF3_PB9_RW		= PAGE_ADDR(PAGE_10, 0x6C),
//	IF3_PB10_RW		= PAGE_ADDR(PAGE_10, 0x6D),
//	IF3_PB11_RW		= PAGE_ADDR(PAGE_10, 0x6E),
//	IF3_PB12_RW		= PAGE_ADDR(PAGE_10, 0x6F),
//	IF3_PB13_RW		= PAGE_ADDR(PAGE_10, 0x70),
//	IF3_PB14_RW		= PAGE_ADDR(PAGE_10, 0x71),
//	IF3_PB15_RW		= PAGE_ADDR(PAGE_10, 0x72),
//	IF3_PB16_RW		= PAGE_ADDR(PAGE_10, 0x73),
//	IF3_PB17_RW		= PAGE_ADDR(PAGE_10, 0x74),
//	IF3_PB18_RW		= PAGE_ADDR(PAGE_10, 0x75),
//	IF3_PB19_RW		= PAGE_ADDR(PAGE_10, 0x76),
//	IF3_PB20_RW		= PAGE_ADDR(PAGE_10, 0x77),
//	IF3_PB21_RW		= PAGE_ADDR(PAGE_10, 0x78),
//	IF3_PB22_RW		= PAGE_ADDR(PAGE_10, 0x79),
//	IF3_PB23_RW		= PAGE_ADDR(PAGE_10, 0x7A),
//	IF3_PB24_RW		= PAGE_ADDR(PAGE_10, 0x7B),
//	IF3_PB25_RW		= PAGE_ADDR(PAGE_10, 0x7C),
//	IF3_PB26_RW		= PAGE_ADDR(PAGE_10, 0x7D),
//	IF3_PB27_RW		= PAGE_ADDR(PAGE_10, 0x7E),
	IF4_HB0_RW		= PAGE_ADDR(PAGE_10, 0x80),
//	IF4_HB1_RW		= PAGE_ADDR(PAGE_10, 0x81),
//	IF4_HB2_RW		= PAGE_ADDR(PAGE_10, 0x82),
	IF4_PB0_RW		= PAGE_ADDR(PAGE_10, 0x83),
//	IF4_PB1_RW		= PAGE_ADDR(PAGE_10, 0x84),
//	IF4_PB2_RW		= PAGE_ADDR(PAGE_10, 0x85),
//	IF4_PB3_RW		= PAGE_ADDR(PAGE_10, 0x86),
//	IF4_PB4_RW		= PAGE_ADDR(PAGE_10, 0x87),
//	IF4_PB5_RW		= PAGE_ADDR(PAGE_10, 0x88),
//	IF4_PB6_RW		= PAGE_ADDR(PAGE_10, 0x89),
//	IF4_PB7_RW		= PAGE_ADDR(PAGE_10, 0x8A),
//	IF4_PB8_RW		= PAGE_ADDR(PAGE_10, 0x8B),
//	IF4_PB9_RW		= PAGE_ADDR(PAGE_10, 0x8C),
//	IF4_PB10_RW		= PAGE_ADDR(PAGE_10, 0x8D),
//	IF4_PB11_RW		= PAGE_ADDR(PAGE_10, 0x8E),
//	IF4_PB12_RW		= PAGE_ADDR(PAGE_10, 0x8F),
//	IF4_PB13_RW		= PAGE_ADDR(PAGE_10, 0x90),
//	IF4_PB14_RW		= PAGE_ADDR(PAGE_10, 0x91),
//	IF4_PB15_RW		= PAGE_ADDR(PAGE_10, 0x92),
//	IF4_PB16_RW		= PAGE_ADDR(PAGE_10, 0x93),
//	IF4_PB17_RW		= PAGE_ADDR(PAGE_10, 0x94),
//	IF4_PB18_RW		= PAGE_ADDR(PAGE_10, 0x95),
//	IF4_PB19_RW		= PAGE_ADDR(PAGE_10, 0x96),
//	IF4_PB20_RW		= PAGE_ADDR(PAGE_10, 0x97),
//	IF4_PB21_RW		= PAGE_ADDR(PAGE_10, 0x98),
//	IF4_PB22_RW		= PAGE_ADDR(PAGE_10, 0x99),
//	IF4_PB23_RW		= PAGE_ADDR(PAGE_10, 0x9A),
//	IF4_PB24_RW		= PAGE_ADDR(PAGE_10, 0x9B),
//	IF4_PB25_RW		= PAGE_ADDR(PAGE_10, 0x9C),
//	IF4_PB26_RW		= PAGE_ADDR(PAGE_10, 0x9D),
//	IF4_PB27_RW		= PAGE_ADDR(PAGE_10, 0x9E),
	IF5_HB0_RW		= PAGE_ADDR(PAGE_10, 0xA0),
//	IF5_HB1_RW		= PAGE_ADDR(PAGE_10, 0xA1),
//	IF5_HB2_RW		= PAGE_ADDR(PAGE_10, 0xA2),
	IF5_PB0			= PAGE_ADDR(PAGE_10, 0xA3),
//	IF5_PB1			= PAGE_ADDR(PAGE_10, 0xA4),
//	IF5_PB2			= PAGE_ADDR(PAGE_10, 0xA5),
//	IF5_PB3			= PAGE_ADDR(PAGE_10, 0xA6),
//	IF5_PB4			= PAGE_ADDR(PAGE_10, 0xA7),
//	IF5_PB5			= PAGE_ADDR(PAGE_10, 0xA8),
//	IF5_PB6			= PAGE_ADDR(PAGE_10, 0xA9),
//	IF5_PB7			= PAGE_ADDR(PAGE_10, 0xAA),
//	IF5_PB8			= PAGE_ADDR(PAGE_10, 0xAB),
//	IF5_PB9			= PAGE_ADDR(PAGE_10, 0xAC),
//	IF5_PB10		= PAGE_ADDR(PAGE_10, 0xAD),
//	IF5_PB11		= PAGE_ADDR(PAGE_10, 0xAE),
//	IF5_PB12		= PAGE_ADDR(PAGE_10, 0xAF),
//	IF5_PB13		= PAGE_ADDR(PAGE_10, 0xB0),
//	IF5_PB14		= PAGE_ADDR(PAGE_10, 0xB1),
//	IF5_PB15		= PAGE_ADDR(PAGE_10, 0xB2),
//	IF5_PB16		= PAGE_ADDR(PAGE_10, 0xB3),
//	IF5_PB17		= PAGE_ADDR(PAGE_10, 0xB4),
//	IF5_PB18		= PAGE_ADDR(PAGE_10, 0xB5),
//	IF5_PB19		= PAGE_ADDR(PAGE_10, 0xB6),
//	IF5_PB20		= PAGE_ADDR(PAGE_10, 0xB7),
//	IF5_PB21		= PAGE_ADDR(PAGE_10, 0xB8),
//	IF5_PB22		= PAGE_ADDR(PAGE_10, 0xB9),
//	IF5_PB23		= PAGE_ADDR(PAGE_10, 0xBA),
//	IF5_PB24		= PAGE_ADDR(PAGE_10, 0xBB),
//	IF5_PB25		= PAGE_ADDR(PAGE_10, 0xBC),
//	IF5_PB26		= PAGE_ADDR(PAGE_10, 0xBD),
//	IF5_PB27		= PAGE_ADDR(PAGE_10, 0xBE),
	AIP_CNTRL_0		= PAGE_ADDR(PAGE_11, 0x00),
	CA_I2S			= PAGE_ADDR(PAGE_11, 0x01),
	CA_DSD			= PAGE_ADDR(PAGE_11, 0x02),
	OBA_PH			= PAGE_ADDR(PAGE_11, 0x03),
	LATENCY_RD		= PAGE_ADDR(PAGE_11, 0x04),
	ACR_CTS_0		= PAGE_ADDR(PAGE_11, 0x05),
	ACR_CTS_1		= PAGE_ADDR(PAGE_11, 0x06),
	ACR_CTS_2		= PAGE_ADDR(PAGE_11, 0x07),
	ACR_N_0			= PAGE_ADDR(PAGE_11, 0x08),
	ACR_N_1			= PAGE_ADDR(PAGE_11, 0x09),
	ACR_N_2			= PAGE_ADDR(PAGE_11, 0x0A),
	GC_AVMUTE		= PAGE_ADDR(PAGE_11, 0x0B),
	CTS_N_RW		= PAGE_ADDR(PAGE_11, 0x0C),
	ENC_CNTRL		= PAGE_ADDR(PAGE_11, 0x0D),
	DIP_FLAGS		= PAGE_ADDR(PAGE_11, 0x0E),
	DIP_IF_FLAGS		= PAGE_ADDR(PAGE_11, 0x0F),
	CH_STAT_B_0		= PAGE_ADDR(PAGE_11, 0x14),
	CH_STAT_B_1		= PAGE_ADDR(PAGE_11, 0x15),
	CH_STAT_B_3		= PAGE_ADDR(PAGE_11, 0x16),
	CH_STAT_B_4		= PAGE_ADDR(PAGE_11, 0x17),
	CH_STAT_B_2_ap0_l_RW	= PAGE_ADDR(PAGE_11, 0x18),
	CH_STAT_B_2_ap0_r_RW	= PAGE_ADDR(PAGE_11, 0x19),
	CH_STAT_B_2_ap1_l_RW	= PAGE_ADDR(PAGE_11, 0x1A),
	CH_STAT_B_2_ap1_r_RW	= PAGE_ADDR(PAGE_11, 0x1B),
	CH_STAT_B_2_ap2_l_RW	= PAGE_ADDR(PAGE_11, 0x1C),
	CH_STAT_B_2_ap2_r_RW	= PAGE_ADDR(PAGE_11, 0x1D),
	CH_STAT_B_2_ap3_l_RW	= PAGE_ADDR(PAGE_11, 0x1E),
	CH_STAT_B_2_ap3_r_RW	= PAGE_ADDR(PAGE_11, 0x1F),
	ISRC1_HB0_RW		= PAGE_ADDR(PAGE_11, 0x20),
//	ISRC1_HB1_RW		= PAGE_ADDR(PAGE_11, 0x21),
//	ISRC1_HB2_RW		= PAGE_ADDR(PAGE_11, 0x22),
	ISRC1_PB0_RW		= PAGE_ADDR(PAGE_11, 0x23),
//	ISRC1_PB1_RW		= PAGE_ADDR(PAGE_11, 0x24),
//	ISRC1_PB2_RW		= PAGE_ADDR(PAGE_11, 0x25),
//	ISRC1_PB3_RW		= PAGE_ADDR(PAGE_11, 0x26),
//	ISRC1_PB4_RW		= PAGE_ADDR(PAGE_11, 0x27),
//	ISRC1_PB5_RW		= PAGE_ADDR(PAGE_11, 0x28),
//	ISRC1_PB6_RW		= PAGE_ADDR(PAGE_11, 0x29),
//	ISRC1_PB7_RW		= PAGE_ADDR(PAGE_11, 0x2A),
//	ISRC1_PB8_RW		= PAGE_ADDR(PAGE_11, 0x2B),
//	ISRC1_PB9_RW		= PAGE_ADDR(PAGE_11, 0x2C),
//	ISRC1_PB10_RW		= PAGE_ADDR(PAGE_11, 0x2D),
//	ISRC1_PB11_RW		= PAGE_ADDR(PAGE_11, 0x2E),
//	ISRC1_PB12_RW		= PAGE_ADDR(PAGE_11, 0x2F),
//	ISRC1_PB13_RW		= PAGE_ADDR(PAGE_11, 0x30),
//	ISRC1_PB14_RW		= PAGE_ADDR(PAGE_11, 0x31),
//	ISRC1_PB15_RW		= PAGE_ADDR(PAGE_11, 0x32),
//	ISRC1_PB16_RW		= PAGE_ADDR(PAGE_11, 0x33),
//	ISRC1_PB17_RW		= PAGE_ADDR(PAGE_11, 0x34),
//	ISRC1_PB18_RW		= PAGE_ADDR(PAGE_11, 0x35),
//	ISRC1_PB19_RW		= PAGE_ADDR(PAGE_11, 0x36),
//	ISRC1_PB20_RW		= PAGE_ADDR(PAGE_11, 0x37),
//	ISRC1_PB21_RW		= PAGE_ADDR(PAGE_11, 0x38),
//	ISRC1_PB22_RW		= PAGE_ADDR(PAGE_11, 0x39),
//	ISRC1_PB23_RW		= PAGE_ADDR(PAGE_11, 0x3A),
//	ISRC1_PB24_RW		= PAGE_ADDR(PAGE_11, 0x3B),
//	ISRC1_PB25_RW		= PAGE_ADDR(PAGE_11, 0x3C),
//	ISRC1_PB26_RW		= PAGE_ADDR(PAGE_11, 0x3D),
//	ISRC1_PB27_RW		= PAGE_ADDR(PAGE_11, 0x3E),
	ISRC2_HB0_RW		= PAGE_ADDR(PAGE_11, 0x40),
//	ISRC2_HB1_RW		= PAGE_ADDR(PAGE_11, 0x41),
//	ISRC2_HB2_RW		= PAGE_ADDR(PAGE_11, 0x42),
	ISRC2_PB0_RW		= PAGE_ADDR(PAGE_11, 0x43),
//	ISRC2_PB1_RW		= PAGE_ADDR(PAGE_11, 0x44),
//	ISRC2_PB2_RW		= PAGE_ADDR(PAGE_11, 0x45),
//	ISRC2_PB3_RW		= PAGE_ADDR(PAGE_11, 0x46),
//	ISRC2_PB4_RW		= PAGE_ADDR(PAGE_11, 0x47),
//	ISRC2_PB5_RW		= PAGE_ADDR(PAGE_11, 0x48),
//	ISRC2_PB6_RW		= PAGE_ADDR(PAGE_11, 0x49),
//	ISRC2_PB7_RW		= PAGE_ADDR(PAGE_11, 0x4A),
//	ISRC2_PB8_RW		= PAGE_ADDR(PAGE_11, 0x4B),
//	ISRC2_PB9_RW		= PAGE_ADDR(PAGE_11, 0x4C),
//	ISRC2_PB10_RW		= PAGE_ADDR(PAGE_11, 0x4D),
//	ISRC2_PB11_RW		= PAGE_ADDR(PAGE_11, 0x4E),
//	ISRC2_PB12_RW		= PAGE_ADDR(PAGE_11, 0x4F),
//	ISRC2_PB13_RW		= PAGE_ADDR(PAGE_11, 0x50),
//	ISRC2_PB14_RW		= PAGE_ADDR(PAGE_11, 0x51),
//	ISRC2_PB15_RW		= PAGE_ADDR(PAGE_11, 0x52),
//	ISRC2_PB16_RW		= PAGE_ADDR(PAGE_11, 0x53),
//	ISRC2_PB17_RW		= PAGE_ADDR(PAGE_11, 0x54),
//	ISRC2_PB18_RW		= PAGE_ADDR(PAGE_11, 0x55),
//	ISRC2_PB19_RW		= PAGE_ADDR(PAGE_11, 0x56),
//	ISRC2_PB20_RW		= PAGE_ADDR(PAGE_11, 0x57),
//	ISRC2_PB21_RW		= PAGE_ADDR(PAGE_11, 0x58),
//	ISRC2_PB22_RW		= PAGE_ADDR(PAGE_11, 0x59),
//	ISRC2_PB23_RW		= PAGE_ADDR(PAGE_11, 0x5A),
//	ISRC2_PB24_RW		= PAGE_ADDR(PAGE_11, 0x5B),
//	ISRC2_PB25_RW		= PAGE_ADDR(PAGE_11, 0x5C),
//	ISRC2_PB26_RW		= PAGE_ADDR(PAGE_11, 0x5D),
//	ISRC2_PB27_RW		= PAGE_ADDR(PAGE_11, 0x5E),
	ACP_HB0_RW		= PAGE_ADDR(PAGE_11, 0x60),
//	ACP_HB1_RW		= PAGE_ADDR(PAGE_11, 0x61),
//	ACP_HB2_RW		= PAGE_ADDR(PAGE_11, 0x62),
	ACP_PB0_RW		= PAGE_ADDR(PAGE_11, 0x63),
//	ACP_PB1_RW		= PAGE_ADDR(PAGE_11, 0x64),
//	ACP_PB2_RW		= PAGE_ADDR(PAGE_11, 0x65),
//	ACP_PB3_RW		= PAGE_ADDR(PAGE_11, 0x66),
//	ACP_PB4_RW		= PAGE_ADDR(PAGE_11, 0x67),
//	ACP_PB5_RW		= PAGE_ADDR(PAGE_11, 0x68),
//	ACP_PB6_RW		= PAGE_ADDR(PAGE_11, 0x69),
//	ACP_PB7_RW		= PAGE_ADDR(PAGE_11, 0x6A),
//	ACP_PB8_RW		= PAGE_ADDR(PAGE_11, 0x6B),
//	ACP_PB9_RW		= PAGE_ADDR(PAGE_11, 0x6C),
//	ACP_PB10_RW		= PAGE_ADDR(PAGE_11, 0x6D),
//	ACP_PB11_RW		= PAGE_ADDR(PAGE_11, 0x6E),
//	ACP_PB12_RW		= PAGE_ADDR(PAGE_11, 0x6F),
//	ACP_PB13_RW		= PAGE_ADDR(PAGE_11, 0x70),
//	ACP_PB14_RW		= PAGE_ADDR(PAGE_11, 0x71),
//	ACP_PB15_RW		= PAGE_ADDR(PAGE_11, 0x72),
//	ACP_PB16_RW		= PAGE_ADDR(PAGE_11, 0x73),
//	ACP_PB17_RW		= PAGE_ADDR(PAGE_11, 0x74),
//	ACP_PB18_RW		= PAGE_ADDR(PAGE_11, 0x75),
//	ACP_PB19_RW		= PAGE_ADDR(PAGE_11, 0x76),
//	ACP_PB20_RW		= PAGE_ADDR(PAGE_11, 0x77),
//	ACP_PB21_RW		= PAGE_ADDR(PAGE_11, 0x78),
//	ACP_PB22_RW		= PAGE_ADDR(PAGE_11, 0x79),
//	ACP_PB23_RW		= PAGE_ADDR(PAGE_11, 0x7A),
//	ACP_PB24_RW		= PAGE_ADDR(PAGE_11, 0x7B),
//	ACP_PB25_RW		= PAGE_ADDR(PAGE_11, 0x7C),
//	ACP_PB26_RW		= PAGE_ADDR(PAGE_11, 0x7D),
//	ACP_PB27_RW		= PAGE_ADDR(PAGE_11, 0x7E),
	OTP_TX0			= PAGE_ADDR(PAGE_12, 0x97),
	OTP_TX1			= PAGE_ADDR(PAGE_12, 0x98),
	OTP_TX2			= PAGE_ADDR(PAGE_12, 0x99),
	OTP_TX3			= PAGE_ADDR(PAGE_12, 0x9A),
	OTP_TX33		= PAGE_ADDR(PAGE_12, 0xB8),
	GMD_0_HB0_RW		= PAGE_ADDR(PAGE_13, 0x00),
//	GMD_0_HB1_RW		= PAGE_ADDR(PAGE_13, 0x01),
//	GMD_0_HB2_RW		= PAGE_ADDR(PAGE_13, 0x02),
	GMD_0_PB0_RW		= PAGE_ADDR(PAGE_13, 0x03),
//	GMD_0_PB1_RW		= PAGE_ADDR(PAGE_13, 0x04),
//	GMD_0_PB2_RW		= PAGE_ADDR(PAGE_13, 0x05),
//	GMD_0_PB3_RW		= PAGE_ADDR(PAGE_13, 0x06),
//	GMD_0_PB4_RW		= PAGE_ADDR(PAGE_13, 0x07),
//	GMD_0_PB5_RW		= PAGE_ADDR(PAGE_13, 0x08),
//	GMD_0_PB6_RW		= PAGE_ADDR(PAGE_13, 0x09),
//	GMD_0_PB7_RW		= PAGE_ADDR(PAGE_13, 0x0A),
//	GMD_0_PB8_RW		= PAGE_ADDR(PAGE_13, 0x0B),
//	GMD_0_PB9_RW		= PAGE_ADDR(PAGE_13, 0x0C),
//	GMD_0_PB10_RW		= PAGE_ADDR(PAGE_13, 0x0D),
//	GMD_0_PB11_RW		= PAGE_ADDR(PAGE_13, 0x0E),
//	GMD_0_PB12_RW		= PAGE_ADDR(PAGE_13, 0x0F),
//	GMD_0_PB13_RW		= PAGE_ADDR(PAGE_13, 0x10),
//	GMD_0_PB14_RW		= PAGE_ADDR(PAGE_13, 0x11),
//	GMD_0_PB15_RW		= PAGE_ADDR(PAGE_13, 0x12),
//	GMD_0_PB16_RW		= PAGE_ADDR(PAGE_13, 0x13),
//	GMD_0_PB17_RW		= PAGE_ADDR(PAGE_13, 0x14),
//	GMD_0_PB18_RW		= PAGE_ADDR(PAGE_13, 0x15),
//	GMD_0_PB19_RW		= PAGE_ADDR(PAGE_13, 0x16),
//	GMD_0_PB20_RW		= PAGE_ADDR(PAGE_13, 0x17),
//	GMD_0_PB21_RW		= PAGE_ADDR(PAGE_13, 0x18),
//	GMD_0_PB22_RW		= PAGE_ADDR(PAGE_13, 0x19),
//	GMD_0_PB23_RW		= PAGE_ADDR(PAGE_13, 0x1A),
//	GMD_0_PB24_RW		= PAGE_ADDR(PAGE_13, 0x1B),
//	GMD_0_PB25_RW		= PAGE_ADDR(PAGE_13, 0x1C),
//	GMD_0_PB26_RW		= PAGE_ADDR(PAGE_13, 0x1D),
//	GMD_0_PB27_RW		= PAGE_ADDR(PAGE_13, 0x1E),
	GMD_CONTROL_RW		= PAGE_ADDR(PAGE_13, 0x1F),
	GMD_1_HB0_RW		= PAGE_ADDR(PAGE_13, 0x20),
//	GMD_1_HB1_RW		= PAGE_ADDR(PAGE_13, 0x21),
//	GMD_1_HB2_RW		= PAGE_ADDR(PAGE_13, 0x22),
	GMD_1_PB0_RW		= PAGE_ADDR(PAGE_13, 0x23),
//	GMD_1_PB1_RW		= PAGE_ADDR(PAGE_13, 0x24),
//	GMD_1_PB2_RW		= PAGE_ADDR(PAGE_13, 0x25),
//	GMD_1_PB3_RW		= PAGE_ADDR(PAGE_13, 0x26),
//	GMD_1_PB4_RW		= PAGE_ADDR(PAGE_13, 0x27),
//	GMD_1_PB5_RW		= PAGE_ADDR(PAGE_13, 0x28),
//	GMD_1_PB6_RW		= PAGE_ADDR(PAGE_13, 0x29),
//	GMD_1_PB7_RW		= PAGE_ADDR(PAGE_13, 0x2A),
//	GMD_1_PB8_RW		= PAGE_ADDR(PAGE_13, 0x2B),
//	GMD_1_PB9_RW		= PAGE_ADDR(PAGE_13, 0x2C),
//	GMD_1_PB10_RW		= PAGE_ADDR(PAGE_13, 0x2D),
//	GMD_1_PB11_RW		= PAGE_ADDR(PAGE_13, 0x2E),
//	GMD_1_PB12_RW		= PAGE_ADDR(PAGE_13, 0x2F),
//	GMD_1_PB13_RW		= PAGE_ADDR(PAGE_13, 0x30),
//	GMD_1_PB14_RW		= PAGE_ADDR(PAGE_13, 0x31),
//	GMD_1_PB15_RW		= PAGE_ADDR(PAGE_13, 0x32),
//	GMD_1_PB16_RW		= PAGE_ADDR(PAGE_13, 0x33),
//	GMD_1_PB17_RW		= PAGE_ADDR(PAGE_13, 0x34),
//	GMD_1_PB18_RW		= PAGE_ADDR(PAGE_13, 0x35),
//	GMD_1_PB19_RW		= PAGE_ADDR(PAGE_13, 0x36),
//	GMD_1_PB20_RW		= PAGE_ADDR(PAGE_13, 0x37),
//	GMD_1_PB21_RW		= PAGE_ADDR(PAGE_13, 0x38),
//	GMD_1_PB22_RW		= PAGE_ADDR(PAGE_13, 0x39),
//	GMD_1_PB23_RW		= PAGE_ADDR(PAGE_13, 0x3A),
//	GMD_1_PB24_RW		= PAGE_ADDR(PAGE_13, 0x3B),
//	GMD_1_PB25_RW		= PAGE_ADDR(PAGE_13, 0x3C),
//	GMD_1_PB26_RW		= PAGE_ADDR(PAGE_13, 0x3D),
//	GMD_1_PB27_RW		= PAGE_ADDR(PAGE_13, 0x3E),
	CURPAGE			= PAGE_ADDR(PAGE_INVALID, 0xFF),
};


/**
 * @brief	Supported feature enumeration
 */
enum tda998x_feature {
	TDA998X_FEAT_HDCP = 0,			/**< HDCP */
	TDA998X_FEAT_SCALER = 1,  		/**< Scaler */
	TDA998X_FEAT_AUDIO_OBA = 2, 		/**< One bit audio */
	TDA998X_FEAT_AUDIO_DST = 3,  		/**< DST audio */
	TDA998X_FEAT_AUDIO_HBR = 4,  		/**< HBR audio */
	TDA998X_FEAT_HDMI_1_1 = 5,  		/**< HDMI 1.1 */
	TDA998X_FEAT_HDMI_1_2A = 6, 		/**< HDMI 1.2a */
	TDA998X_FEAT_HDMI_1_3A = 7,  		/**< HDMI 1.3a */
	TDA998X_FEAT_DEEP_COLOR_30 = 8,  	/**< 30 bits deep color */
	TDA998X_FEAT_DEEP_COLOR_36 = 9,  	/**< 36 bits deep color */
	TDA998X_FEAT_DEEP_COLOR_48 = 11, 	/**< 48 bits deep color */
	TDA998X_FEAT_UPSAMPLER = 12, 		/**< Up sampler */
	TDA998X_FEAT_DOWNSAMPLER = 13, 		/**< Down sampler */
	TDA998X_FEAT_COLOR_CONVERSION = 14	/**< Color conversion matrix */
};


/**
 * Lookup table of input port control registers and their swap and mirror masks
 */
//CONST_DAT tmbslTDA9989RegVip
// kRegVip[HDMITX_VIN_PORT_MAP_TABLE_LEN] =
//{
//    {E_REG_P00_VIP_CNTRL_0_W,
//        E_MASKREG_P00_VIP_CNTRL_0_swap_a,
//        E_MASKREG_P00_VIP_CNTRL_0_mirr_a
//    }, /* Port group 0 */
//    {E_REG_P00_VIP_CNTRL_0_W,
//        E_MASKREG_P00_VIP_CNTRL_0_swap_b,
//        E_MASKREG_P00_VIP_CNTRL_0_mirr_b
//    }, /* Port group 1 */
//    {E_REG_P00_VIP_CNTRL_1_W,
//        E_MASKREG_P00_VIP_CNTRL_1_swap_c,
//        E_MASKREG_P00_VIP_CNTRL_1_mirr_c
//    }, /* Port group 2 */
//    {E_REG_P00_VIP_CNTRL_1_W,
//        E_MASKREG_P00_VIP_CNTRL_1_swap_d,
//        E_MASKREG_P00_VIP_CNTRL_1_mirr_d
//    }, /* Port group 3 */
//    {E_REG_P00_VIP_CNTRL_2_W,
//        E_MASKREG_P00_VIP_CNTRL_2_swap_e,
//        E_MASKREG_P00_VIP_CNTRL_2_mirr_e
//    }, /* Port group 4 */
//    {E_REG_P00_VIP_CNTRL_2_W,
//        E_MASKREG_P00_VIP_CNTRL_2_swap_f,
//        E_MASKREG_P00_VIP_CNTRL_2_mirr_f
//    }  /* Port group 5 */
//};


/**
 * Table of PLL settings registers to configure for all video input format (vinFmt)
 */
//CONST_DAT tmHdmiTxRegMaskVal_t kCommonPllCfg[] =
//{
//    {E_REG_P02_PLL_SERIAL_1_RW, E_MASKREG_ALL,  0x00},
//    {E_REG_P02_PLL_SERIAL_2_RW, E_MASKREG_ALL,  0x01},
//    {E_REG_P02_PLL_SERIAL_3_RW, E_MASKREG_ALL,  0x00},
//    {E_REG_P02_SERIALIZER_RW,   E_MASKREG_ALL,  0x00},
//    {E_REG_P02_BUFFER_OUT_RW,   E_MASKREG_ALL,  0x00},
//    {E_REG_P02_PLL_SCG1_RW,     E_MASKREG_ALL,  0x00},
//    {E_REG_P02_AUDIO_DIV_RW,    E_MASKREG_ALL,  0x03},
//    /*{E_REG_P02_TEST2_RW,        E_MASKREG_ALL,  0x00},*/
//    {E_REG_P02_SEL_CLK_RW,      E_MASKREG_ALL,  0x09},
//    {0,0,0}
//};


/**
 * @brief	Write Data
 *
 * @param	dev:	TDA998X device structure pointer
 * @param	reg:	Start register and page address
 * @param	len:	Length of data to write to device
 * @param	data:	Pointer to data to write from
 * @return	Number of bytes written or less-than-zero error status
 */
static int tda998x_write(struct tda998x_dev *dev, enum tda998x_hdmi_reg reg, uint8_t len, uint8_t *data)
{
	int i, err;
	struct tda998x_cfg *cfg = dev->cfg;
	uint8_t page = PAGE_OF(reg);

	if (dev->cfg->cur_page != page) {
		/* Change the page */
		err = cfg->i2c_write(cfg->hdmi_addr, (uint8_t)CURPAGE, &page);
		if (err < 0)
			return err;

		dev->cfg->cur_page = page;
	}

	for (i = 0; i < len; i++, data++) {
		err = cfg->i2c_write(cfg->hdmi_addr, (uint8_t)reg + i, data);
		if (err < 0)
			return err;
	}

	return i;
}

/**
 * @brief	Write Register
 *
 * @param	dev:	TDA998X device structure pointer
 * @param	reg:	Register and page address
 * @param	data:	Data value to write to register
 * @return	Number of bytes written or less-than-zero error status
 */
static int write_reg(struct tda998x_dev *dev, enum tda998x_hdmi_reg reg, uint8_t data)
{
	uint8_t tmp = data;

	return tda998x_write(dev, reg, 1, &tmp);
}

/**
 * @brief	Read Data
 *
 * @param	dev:	TDA998X device structure pointer
 * @param	reg:	Start register and page address
 * @param	len:	Length of data to read from device
 * @param	data:	Pointer to data to read to
 * @return	Number of bytes read or less-than-zero error status
 */
static int tda998x_read(struct tda998x_dev *dev, enum tda998x_hdmi_reg reg, uint8_t len, uint8_t *data)
{
	int i, err;
	struct tda998x_cfg *cfg = dev->cfg;
	uint8_t page = PAGE_OF(reg);

	if (dev->cfg->cur_page != page) {
		/* Change the page */
		err = cfg->i2c_write(cfg->hdmi_addr, (uint8_t)CURPAGE, &page);
		if (err < 0)
			return err;

		dev->cfg->cur_page = page;
	}

	for (i = 0; i < len; i++, data++) {
		err = cfg->i2c_read(cfg->hdmi_addr, (uint8_t)reg + i, data);
		if (err < 0)
			return err;
	}

	return i;
}

/**
 * @brief	Read Register
 *
 * @param	dev:	TDA998X device structure pointer
 * @param	reg:	Register and page address
 * @param	data:	Pointer to data to read to
 * @return	Number of bytes read or less-than-zero error status
 */
static int read_reg(struct tda998x_dev *dev, enum tda998x_hdmi_reg reg, uint8_t *data)
{
	return tda998x_read(dev, reg, 1, data);
}


/**
 * @brief	Register Mask Write
 *		Write a specified value with specified mask bits to a register
 *
 * @param	dev:	TDA998X device structure pointer
 * @param	reg:	Register and page address
 * @param	mask:	Mask of bits to be transformed
 * @param	val:	Bitfield to be written within mask
 * @return	Number of bytes written or less-than-zero error status
 */
static int write_reg_mask(struct tda998x_dev *dev, enum tda998x_hdmi_reg reg, uint8_t mask, uint8_t val)
{
	int err;
	uint8_t reg_val;

	err = read_reg(dev, reg, &reg_val);
	if (err < 0)
		return err;

	reg_val &= ~(mask);			/* clear bits in the mask */
	reg_val |= val & mask;			/* set masked value bits */

	return write_reg(dev, reg, reg_val);
}

/**
 * @brief	CEC Write Data
 *
 * @param	dev:	TDA998X device structure pointer
 * @param	reg:	Start register and page address
 * @param	len:	Length of data to write to device
 * @param	data:	Pointer to data to write from
 * @return	Number of bytes written or less-than-zero error status
 */
static int tda998x_cec_write(struct tda998x_dev *dev, enum tda998x_cec_reg reg, uint8_t len, uint8_t *data)
{
	int i, err;
	struct tda998x_cfg *cfg = dev->cfg;

	for (i = 0; i < len; i++, data++) {
		err = cfg->i2c_write(cfg->cec_addr, (uint8_t)reg + i, data);
		if (err < 0)
			return err;
	}

	return i;
}

/**
 * @brief	CEC Write Register
 *
 * @param	dev:	TDA998X device structure pointer
 * @param	reg:	Register and page address
 * @param	data:	Data value to write to register
 * @return	Number of bytes written or less-than-zero error status
 */
static int cec_write_reg(struct tda998x_dev *dev, enum tda998x_cec_reg reg, uint8_t data)
{
	uint8_t tmp = data;

	return tda998x_cec_write(dev, reg, 1, &tmp);
}


/**
 * @brief	CEC Read Data
 *
 * @param	dev:	TDA998X device structure pointer
 * @param	reg:	Start register and page address
 * @param	len:	Length of data to read from device
 * @param	data:	Pointer to data to read to
 * @return	Number of bytes read or less-than-zero error status
 */
static int tda998x_cec_read(struct tda998x_dev *dev, enum tda998x_cec_reg reg, uint8_t len, uint8_t *data)
{
	int i, err;
	struct tda998x_cfg *cfg = dev->cfg;

	for (i = 0; i < len; i++, data++) {
		err = cfg->i2c_read(cfg->cec_addr, (uint8_t)reg + i, data);
		if (err < 0)
			return err;
	}

	return i;
}

/**
 * @brief	CEC Read Register
 *
 * @param	dev:	TDA998X device structure pointer
 * @param	reg:	Register and page address
 * @param	data:	Pointer to data to read to
 * @return	Number of bytes read or less-than-zero error status
 */
static int cec_read_reg(struct tda998x_dev *dev, enum tda998x_cec_reg reg, uint8_t *data)
{
	return tda998x_cec_read(dev, reg, 1, data);
}

/**
 * @brief	CEC Register Mask Write
 *		Write a specified value with specified mask bits to a register
 *
 * @param	dev:	TDA99X device structure pointer
 * @param	reg:	Register and page address
 * @param	mask:	Mask of bits to be transformed
 * @param	val:	Bitfield to be written within mask
 * @return	Number of bytes written or less-than-zero error status
 */
static int cec_write_reg_mask(struct tda998x_dev *dev, enum tda998x_cec_reg reg, uint8_t mask, uint8_t val)
{
	int err;
	uint8_t reg_val;

	err = cec_read_reg(dev, reg, &reg_val);
	if (err < 0)
		return err;

	reg_val &= ~(mask);
	reg_val |= val & mask;

	return cec_write_reg(dev, reg, reg_val);
}


/**
 * Internal port | RGB 4:4:4 | YCbCr 4:4:4 | YCbCr 4:2:2 Semi-planar | YCbCr 4:2:2 ITU656
 * ------------- | --------- | ----------- | ----------------------- | ------------------
 * VP[23]        | G[7]      | Y[7]        | Y[11]                   | YCbCr[11]
 * VP[22]        | G[6]      | Y[6]        | Y[10]                   | YCbCr[10]
 * VP[21]        | G[5]      | Y[5]        | Y[9]                    | YCbCr[9]
 * VP[20]        | G[4]      | Y[4]        | Y[8]                    | YCbCr[8]
 * VP[19]        | G[3]      | Y[3]        | Y[7]                    | YCbCr[7]
 * VP[18]        | G[2]      | Y[2]        | Y[6]                    | YCbCr[6]
 * VP[17]        | G[1]      | Y[1]        | Y[5]                    | YCbCr[5]
 * VP[16]        | G[0]      | Y[0]        | Y[4]                    | YCbCr[4]
 * VP[15]        | B[7]      | Cb[7]       | Y[3]                    | YCbCr[3]
 * VP[14]        | B[6]      | Cb[6]       | Y[2]                    | YCbCr[2]
 * VP[13]        | B[5]      | Cb[5]       | Y[1]                    | YCbCr[1]
 * VP[12]        | B[4]      | Cb[4]       | Y[0]                    | YCbCr[0]
 * VP[11]        | B[3]      | Cb[3]       | CbCr[11]
 * VP[10]        | B[2]      | Cb[2]       | CbCr[10]
 * VP[9]         | B[1]      | Cb[1]       | CbCr[9]
 * VP[8]         | B[0]      | Cb[0]       | CbCr[8]
 * VP[7]         | R[7]      | Cr[7]       | CbCr[7]
 * VP[6]         | R[6]      | Cr[6]       | CbCr[6]
 * VP[5]         | R[5]      | Cr[5]       | CbCr[5]
 * VP[4]         | R[4]      | Cr[4]       | CbCr[4]
 * VP[3]         | R[3]      | Cr[3]       | CbCr[3]
 * VP[2]         | R[2]      | Cr[2]       | CbCr[2]
 * VP[1]         | R[1]      | Cr[1]       | CbCr[1]
 * VP[0]         | R[0]      | Cr[0]       | CbCr[0]
 */


/**
 * VPC[7]	d_vp[23]	VPB[7]	d_vp[15]	VPA[7]	d_vp[7]
 * VPC[6]	d_vp[22]	VPB[6]	d_vp[14]	VPA[6]	d_vp[6]
 * VPC[5]	d_vp[21]	VPB[5]	d_vp[13]	VPA[5]	d_vp[5]
 * VPC[4]	d_vp[20]	VPB[4]	d_vp[12]	VPA[4]	d_vp[4]
 * VPC[3]	d_vp[19]	VPB[3]	d_vp[11]	VPA[3]	d_vp[3]
 * VPC[2]	d_vp[18]	VPB[2]	d_vp[10]	VPA[2]	d_vp[2]
 * VPC[1]	d_vp[17]	VPB[1]	d_vp[9]		VPA[1]	d_vp[1]
 * VPC[0]	d_vp[16]	VPB[0]	d_vp[8]		VPA[0]	d_vp[0]
 */
int tda998x_set_video_port_enable(struct tda998x_dev *dev)
{
	int err;

	err = write_reg(dev, ENA_VP_0, 0xFF);
	if (err < 0)
		return err;

	err = write_reg(dev, ENA_VP_1, 0xFF);
	if (err < 0)
		return err;

	err = write_reg(dev, ENA_VP_2, 0xFF);
	if (err < 0)
		return err;

	return err;
}


int tda998x_set_video_port_map(struct tda998x_dev *dev)
{
	int i, err;
	uint8_t mask;
	uint8_t reg_val;
	const enum tda998x_vip_cntrl_swap port_map[] = {
		VIP_CNTRL_VP23_20,
		VIP_CNTRL_VP19_16,
		VIP_CNTRL_VP15_12,
		VIP_CNTRL_VP11_8,
		VIP_CNTRL_VP7_4,
		VIP_CNTRL_VP3_0
	};
	const enum tda998x_vip_cntrl_mirr mirr_map[] = {
		VIP_CNTRL_NOT_MIRRORED,
		VIP_CNTRL_NOT_MIRRORED,
		VIP_CNTRL_NOT_MIRRORED,
		VIP_CNTRL_NOT_MIRRORED,
		VIP_CNTRL_NOT_MIRRORED,
		VIP_CNTRL_NOT_MIRRORED
	};

	/* Check parameters */
	for (i = 0; i < 3; i++) {
		reg_val = port_map[2 * i] << VIP_CNTRL_SWAP_H_SHIFT;
		reg_val |= port_map[(2 * i) + 1] << VIP_CNTRL_SWAP_L_SHIFT;
		reg_val |= mirr_map[2 * i] == VIP_CNTRL_MIRRORED ? VIP_CNTRL_MIRR_H : 0;
		reg_val |= mirr_map[(2 * i) + 1] == VIP_CNTRL_MIRRORED ? VIP_CNTRL_MIRR_L : 0;

		err = write_reg_mask(dev,
				VIP_CNTRL_0 + i,
				VIP_CNTRL_SWAP_MASK,
				reg_val);
	}

	return err;
}


/**
 * @brief	Disable HDMI HDCP
 * 		Set HDMI HDCP mode off for DVI
 */
static int tda998x_disable_hdcp(struct tda998x_dev *dev)
{
	int err;

	err = write_reg_mask(dev,
			TBG_CNTRL_1,
			TBG_CNTRL_1_DWIN_DIS, TBG_CNTRL_1_DWIN_DIS);
	if (err < 0)
		return err;

	err = write_reg_mask(dev,
			OTP_TX33,
			OTP_TX33_HDMI, 0);
	if (err < 0)
		return err;

	return 0;
}


/**
 * @brief	Enable HDMI HDCP
 * 		Set HDMI HDCP mode on for HDMI
 */
static int tda998x_enable_hdcp(struct tda998x_dev *dev)
{
	int err;

	err = write_reg_mask(dev,
			TBG_CNTRL_1,
			TBG_CNTRL_1_DWIN_DIS, 0);
	if (err < 0)
		return err;

	err = write_reg_mask(dev,
			ENC_CNTRL,
			ENC_CNTRL_CTL_CODE_MASK,
			ENC_CNTRL_CTL_CODE_MASK);
	if (err < 0)
		return err;

	err = write_reg_mask(dev,
			OTP_TX33,
			OTP_TX33_HDMI,
			OTP_TX33_HDMI);
	if (err < 0)
		return err;
}



int tda998x_set_video_out_config(struct tda998x_dev *dev)
//(
//    tmUnitSelect_t            txUnit,
//    tmbslHdmiTxSinkType_t     sinkType,
//    tmbslHdmiTxVoutMode_t     voutMode,
//    tmbslHdmiTxVoutPrefil_t   preFilter,
//    tmbslHdmiTxVoutYuvBlnk_t  yuvBlank,
//    tmbslHdmiTxVoutQrange_t   quantization
//)
{
	int err;

	if (sinkType == HDMITX_SINK_EDID) {
		if (pDis->EdidStatus == HDMITX_EDID_NOT_READ) {
			/* EDID has not been read so assume simplest sink */
			pDis->sinkType = HDMITX_SINK_DVI;
		} else {
			/* EDID has been read so set sink to the type that was read */
			pDis->sinkType = pDis->EdidSinkType;
		}
	} else {
		pDis->sinkType = sinkType;	/* Set demanded sink type */
	}

	/* Is DVI sink required? */
	if (pDis->sinkType == HDMITX_SINK_DVI) {
		/* Mute the audio FIFO */
		err = write_reg_mask(dev,
				AIP_CNTRL_0,
				AIP_CNTRL_0_RST_FIFO,
				AIP_CNTRL_0_RST_FIFO);
		if (err < 0)
			return err;

		/* Force RGB mode for DVI sink */
		voutMode = HDMITX_VOUTMODE_RGB444;

		err = tda998x_disable_hdcp(dev);
		if (err < 0)
			return err;

		err = write_reg_mask(dev,
				ENC_CNTRL,
				ENC_CNTRL_CTL_CODE,
				regVal);
	} else {
		/* Unmute the audio FIFO */
		err = write_reg_mask(dev,
				AIP_CNTRL_0,
				AIP_CNTRL_0_RST_FIFO,
				0);
		if (err < 0)
			return err;

		err = tda998x_enable_hdcp(dev);
		if (err < 0)
			return err;
	}

	/* For each parameter that is not No Change, set its register */
	if (voutMode != HDMITX_VOUTMODE_NO_CHANGE) {
		/* Save the output mode for later use by the matrix & downsampler */
		pDis->voutMode = voutMode;
	}

	if (preFilter < HDMITX_VOUT_PREFIL_NO_CHANGE) {
#ifdef TMFL_HDCP_OPTIMIZED_POWER
       /*
          power management :
          freeze/wakeup SPDIF clock
       */
       err = write_reg_mask(dev,
		       FEAT_POWER_DOWN,
                       FEAT_POWER_DOWN_PREFILT,
                       (preFilter == HDMITX_VOUT_PREFIL_OFF));
       if (err < 0)
	       return err;
#endif
		err = write_reg_mask(dev,
                                 HVF_CNTRL_0,
                                 HVF_CNTRL_0_PREFIL,
                                 (uint8_t)preFilter);
        	if (err < 0)
        		return err;
	}

	if (yuvBlank < HDMITX_VOUT_YUV_BLNK_NO_CHANGE) {
		err = write_reg_mask(dev,
                                 HVF_CNTRL_1,
                                 HVF_CNTRL_1_YUVBLK,
                                 (uint8_t)yuvBlank);
        	if (err < 0)
        		return err;
	}

	return 0;
}




int tda998x_set_video_in_fine(struct tda998x_dev *dev, uint8_t pack_count, int toggle_clk)
{
	int err;

//#define VIP_CNTRL_3_X_TGL			(1 << 0)
//#define VIP_CNTRL_3_H_TGL			(1 << 1)
//#define VIP_CNTRL_3_V_TGL			(1 << 2)
//#define VIP_CNTRL_3_EMB				(1 << 3)
//#define VIP_CNTRL_3_SP_SYNC_MASK		(0x30U)
//#define VIP_CNTRL_3_DE_INT			(1 << 6)
//#define VIP_CNTRL_3_EDGE			(1 << 7)


//#define VIP_CNTRL_5_CKCASE			(1 << 0)
//#define VIP_CNTRL_5_SP_CNT_MASK			(0x06U)

	err = write_reg_mask(dev,
			VIP_CNTRL_5,
			VIP_CNTRL_5_SP_CNT,
			pack_count);

	err = write_reg_mask(dev,
			VIP_CNTRL_3,
			VIP_CNTRL_3_SP_SYNC,
			HDMITX_PIXSUBPKT_SYNC_FIXED);

    /* IF subpacketCount is Fix at 0/1/2/3 THEN set subpacket count register
     * to 0/1/2/3 and set subpacket sync register to 3
     */
    if (subpacketCount <= HDMITX_PIXSUBPKT_FIX_3) {
        err = write_reg_mask(pDis,
                                 E_REG_P00_VIP_CNTRL_5_W,
                                 E_MASKREG_P00_VIP_CNTRL_5_sp_cnt,
                                 (UInt8)subpacketCount);
        RETIF_REG_FAIL(err)
        err = setHwRegisterField(pDis,
                                 E_REG_P00_VIP_CNTRL_3_W,
                                 E_MASKREG_P00_VIP_CNTRL_3_sp_sync,
                                 HDMITX_PIXSUBPKT_SYNC_FIXED);
        RETIF_REG_FAIL(err)
    }
    /* ELSE IF subpacketCount is Sync by Hemb/ Sync by Rising Edge DE/
     * Sync by Rising Edge HS THEN set the unused subpacket count to zero and
     * set subpacket sync register to 0/1/2
     */
    else if (subpacketCount != HDMITX_PIXSUBPKT_NO_CHANGE)
    {
        err = setHwRegisterField(pDis,
                                 E_REG_P00_VIP_CNTRL_5_W,
                                 E_MASKREG_P00_VIP_CNTRL_5_sp_cnt,
                                 HDMITX_PIXSUBPKT_FIX_0);
        RETIF_REG_FAIL(err)

        err = setHwRegisterField(pDis,
                                 E_REG_P00_VIP_CNTRL_3_W,
                                 E_MASKREG_P00_VIP_CNTRL_3_sp_sync,
                         (UInt8)(subpacketCount - HDMITX_PIXSUBPKT_SYNC_FIRST));
        RETIF_REG_FAIL(err)
    }

    /* IF toggleClk1 is not No Change THEN set ckcase bitfield */
    if (toggleClk1 != HDMITX_PIXTOGL_NO_CHANGE)
    {
        err = setHwRegisterField(pDis,
                                 E_REG_P00_VIP_CNTRL_5_W,
                                 E_MASKREG_P00_VIP_CNTRL_5_ckcase,
                                 (UInt8)toggleClk1);
        RETIF_REG_FAIL(err)
    }
    return TM_OK;
}




int tda998x_set_outputs(struct tda998x_dev *dev, uint8_t tmds)
{
    /* Set the TMDS output mode */
    return write_reg_mask(dev,
                             BUFFER_OUT,
                             BUFFER_OUT_SRL_FORCE_MASK,
                             tmds);
}


/**
 * @brief	Is Feature Supported
 */
int tda998x_feat_is_supported(struct tda998x_dev *dev, enum tda998x_feature feat)
{
	switch (feat) {
	case HDMITX_FEATURE_HW_HDCP:
		return !(dev->features & VERSION_NOT_HDCP);
	case HDMITX_FEATURE_HW_SCALER:
		return !(dev->features & VERSION_NOT_SCALER);
	case HDMITX_FEATURE_HW_AUDIO_OBA: return true;
	case HDMITX_FEATURE_HW_AUDIO_DST: return false;
	case HDMITX_FEATURE_HW_AUDIO_HBR:
#ifdef TMFL_HBR_SUPPORT
		return true;
#else
		return false;
#endif
	case HDMITX_FEATURE_HW_HDMI_1_1: return true;
	case HDMITX_FEATURE_HW_HDMI_1_2A: return true;
	case HDMITX_FEATURE_HW_HDMI_1_3A: return false;
	case HDMITX_FEATURE_HW_DEEP_COLOR_30: return false;
	case HDMITX_FEATURE_HW_DEEP_COLOR_36: return false;
	case HDMITX_FEATURE_HW_DEEP_COLOR_48: return false;
	case HDMITX_FEATURE_HW_UPSAMPLER: return true;
	case HDMITX_FEATURE_HW_DOWNSAMPLER: return true;
	case HDMITX_FEATURE_HW_COLOR_CONVERSION: return true;
	default: return false;
	}

	return err;
}




static int tda998x_set_color_depth(struct tda998x_dev *dev, uint8_t color_depth)
{
	int err = 0;

	switch (color_depth) {
	case HDMITX_COLORDEPTH_NO_CHANGE:
		break;

	case HDMITX_COLORDEPTH_24:
		break;

        default:
        	err = TMBSL_ERR_HDMI_NOT_SUPPORTED;
        	break;
	}

	return err;
}


static int tda998x_set_tmds_outputs(struct tda998x_dev *dev, uint8_t tmds_out)
{
	/* Set the TMDS output mode */
	err = write_reg_mask(dev,
			BUFFER_OUT,
			BUFFER_OUT_SRL_FORCE_MASK,
			(uint8_t)tmds_out);

	return err;
}


static int tda998x_set_tmds_serializer(struct tda998x_dev *dev, uint8_t phase2, uint8_t phase3)
{
    return TMBSL_ERR_HDMI_NOT_SUPPORTED;
}


/**
 * @brief	Set Input/Output
 */
int tda998x_set_inout(void)
{
	tmErrorCode_t           errCode;
	UInt8                   pixRepeat;                  /* Pixel repetition */
	tmbslHdmiTxVoutDbits_t  pathBits;                   /* Data path bit width */
	tmbslHdmiTxPixEdge_t    pixelEdge;                  /* Pixel sampling edge */
	tmbslHdmiTxVsMeth_t     syncMethod;                 /* Sync method */
	tmbslHdmiTxPixTogl_t    toggle;                     /* Toggling */
	UInt8                   syncIn;                     /* Embedded or external */
	tmbslHdmiTxPixSubpkt_t  spSync;                     /* Subpacket sync */
	tmbslHdmiTxBlnkSrc_t    blankit;                    /* Blanking */
	tmbslHdmiTxPixRate_t    pixRateSingleDouble;        /* HDMITX_PIXRATE_SINGLE */
	UInt16                  uRefPix;                    /* REFPIX for output */
	UInt16                  uRefLine;                   /* REFLINE for output */
	UInt16                  uScRefPix=0;                /* REFPIX for scaler */
	UInt16                  uScRefLine=0;               /* REFLINE for scaler */
	Bool                    bVerified;                  /* Scaler setting verified */
	tmbslHdmiTxTopSel_t     topSel;                     /* Adjustment for interlaced output */
	tmbslHdmiTxHPhases_t    phasesH;                    /* Horizontal phase */
	tmbslHdmiTxVsOnce_t     once;                       /* Line/pixel counters sync */
	tmbslHdmiTxScaMode_t    scalerMode;                 /* Current scaler mode */
	Bool                    OBASupported;               /* OBA supported or not */
	Bool                    DSTSupported;               /* DST supported or not */
	Bool                    HBRSupported;               /* HBR supporeted or not */
	UInt8                   *pSwapTable = Null;         /* Initialized after (depend on video mode used) */
	UInt8                   *pMirrorTable = Null;       /* Initialized after (depend on video mode used) */
#ifdef TMFL_RGB_DDR_12BITS
	UInt8                   *pMux = Null;                 /* Initialized after (depend on video mode used) */
#endif
	UInt8                   *pEnaVideoPortTable = Null; /* Initialized after (depend on video mode used) */
	UInt8                   *pGndVideoPortTable = Null; /* Initialized after (depend on video mode used) */
	tmdlHdmiTxVidFmt_t      vinFmtIndex;                /* index in table kVfmtToShortFmt_TV */

	/* dummy definition to avoid derefencing type-punned pointer warning */
	tmdlHdmiTxSinkType_t    *pSinkType = &sinkType;

	/* Update the instance status information */
	instanceStatusInfoTx[instance].pVideoInfo->videoInConfig.format       = videoInputConfig.format;
	instanceStatusInfoTx[instance].pVideoInfo->videoInConfig.mode         = videoInputConfig.mode;
	instanceStatusInfoTx[instance].pVideoInfo->videoInConfig.syncSource   = videoInputConfig.syncSource;
	instanceStatusInfoTx[instance].pVideoInfo->videoInConfig.pixelRate    = videoInputConfig.pixelRate;
	instanceStatusInfoTx[instance].pVideoInfo->videoInConfig.structure3D  = videoInputConfig.structure3D;

	instanceStatusInfoTx[instance].pVideoInfo->videoOutConfig.format      = videoOutputConfig.format;
	instanceStatusInfoTx[instance].pVideoInfo->videoOutConfig.mode        = videoOutputConfig.mode;
	instanceStatusInfoTx[instance].pVideoInfo->videoOutConfig.colorDepth  = videoOutputConfig.colorDepth;

	/* TODO */
	/* instanceStatusInfoTx[instance].pVideoInfo->videoMuteState */

	/* Audio OBA support */
//	errCode = tmbslHdmiTxHwGetCapabilities(instance,
//					HDMITX_FEATURE_HW_AUDIO_OBA, &OBASupported);

	/* Audio DST support */
//	errCode = tmbslHdmiTxHwGetCapabilities(instance,
//					HDMITX_FEATURE_HW_AUDIO_DST, &DSTSupported);

	/* Audio HBR support */
//	errCode = tmbslHdmiTxHwGetCapabilities(instance,
//					HDMITX_FEATURE_HW_AUDIO_HBR, &HBRSupported);

        /* Test if audio input format is supported */
//        if ( ((audioInputConfig.format == TMDL_HDMITX_AFMT_OBA) && (OBASupported == False)) ||
//	         ((audioInputConfig.format == TMDL_HDMITX_AFMT_DST) && (DSTSupported == False)) ||
//             ((audioInputConfig.format == TMDL_HDMITX_AFMT_HBR) && (HBRSupported == False)) ) {
        	/* Release the sempahore */
//        	RETIF( (errCode = tmdlHdmiTxIWSemaphoreV(dlHdmiTxItSemaphore[instance]) ) != TM_OK, errCode)

//        	return TMDL_ERR_DLHDMITX_NOT_SUPPORTED;
//        }

//	instanceStatusInfoTx[instance].pAudioInfo->audioInCfg.format            = audioInputConfig.format;
//	instanceStatusInfoTx[instance].pAudioInfo->audioInCfg.i2sFormat         = audioInputConfig.i2sFormat;
//	instanceStatusInfoTx[instance].pAudioInfo->audioInCfg.i2sQualifier      = audioInputConfig.i2sQualifier;
//	instanceStatusInfoTx[instance].pAudioInfo->audioInCfg.rate              = audioInputConfig.rate;
//	instanceStatusInfoTx[instance].pAudioInfo->audioInCfg.channelAllocation = audioInputConfig.channelAllocation;


//	if (sinkType == TMDL_HDMITX_SINK_EDID) {
		/* Change sink type with the currently defined in EDID */
//		err = tmbslHdmiTxEdidGetSinkType(instance,
//				(tmbslHdmiTxSinkType_t *)pSinkType);
//	}

	/* forbid format with pixel repetition in DVI */
//	if ((sinkType == TMDL_HDMITX_SINK_DVI) &&
//			((videoOutputConfig.format >= TMDL_HDMITX_VFMT_06_720x480i_60Hz) && (videoOutputConfig.format <= TMDL_HDMITX_VFMT_15_1440x480p_60Hz)) ||
//			((videoOutputConfig.format >= TMDL_HDMITX_VFMT_21_720x576i_50Hz) && (videoOutputConfig.format <= TMDL_HDMITX_VFMT_30_1440x576p_50Hz)) ||
//			((videoOutputConfig.format >= TMDL_HDMITX_VFMT_35_2880x480p_60Hz) && (videoOutputConfig.format <= TMDL_HDMITX_VFMT_38_2880x576p_50Hz))) {

			/* Release the sempahore */
//			RETIF((errCode = tmdlHdmiTxIWSemaphoreV(dlHdmiTxItSemaphore[instance])) != TM_OK, errCode)
//        		    return TMDL_ERR_DLHDMITX_BAD_PARAMETER;
//		}
//	}

	/* Set color depth according to output config, transmitter termination is disable */
	err = tda998x_set_color_depth(dev,
			(tmbslHdmiTxColorDepth)(videoOutputConfig.colorDepth), False);

	/* Set the TMDS outputs to a forced state */
	err = tda998x_set_tmds_outputs(dev, HDMITX_TMDSOUT_FORCED0);

	/* Fine-tune the TMDS serializer */
	err = tda998x_set_tmds_serializer(dev, 4, 8);

	/* Set video output configuration */
	err = tda998x_set_video_out_config(instance,
			(tmbslHdmiTxSinkType_t)sinkType,
			(tmbslHdmiTxVoutMode_t)videoOutputConfig.mode,
			HDMITX_VOUT_PREFIL_OFF,
			HDMITX_VOUT_YUV_BLNK_16,
			HDMITX_VOUT_QRANGE_FS);

	/* Set default config */
	pixRepeat   = HDMITX_PIXREP_DEFAULT;
	pathBits    = HDMITX_VOUT_DBITS_12;
	pixelEdge   = HDMITX_PIXEDGE_CLK_POS;
	syncMethod  = HDMITX_VSMETH_V_H;
	toggle      = HDMITX_PIXTOGL_ENABLE;

	/* Set sync details */
	if (videoInputConfig.syncSource == TMDL_HDMITX_SYNCSRC_EMBEDDED) {
		/* Embedded sync */
		syncIn      = EMB;
		spSync      = HDMITX_PIXSUBPKT_SYNC_HEMB;
		blankit     = HDMITX_BLNKSRC_VS_HEMB_VEMB;
		syncMethod  = HDMITX_VSMETH_V_XDE;
	} else {
		/* External sync */
		syncIn  = EXT;

		if (gtmdlHdmiTxDriverConfigTable[instance].dataEnableSignalAvailable == 1) {
			/* DE is available */
			spSync  = HDMITX_PIXSUBPKT_SYNC_DE;
		} else {
			/* DE is NOT available */
			spSync  = HDMITX_PIXSUBPKT_SYNC_HS;
		}

		blankit = HDMITX_BLNKSRC_NOT_DE;
	}

#ifdef TMFL_RGB_DDR_12BITS
    /* by default, mux is not used */
    pMux = &gtmdlHdmiTxDriverConfigTable[instance].pNoMux[0];
#endif

//	/* Port swap table */
//	switch(videoInputConfig.mode) {
//	case TMDL_HDMITX_VINMODE_CCIR656:
//		pathBits = HDMITX_VOUT_DBITS_8;
//		pixelEdge = HDMITX_PIXEDGE_CLK_NEG;
//		pSwapTable = gtmdlHdmiTxDriverConfigTable[instance].pSwapTableCCIR656;
//		pMirrorTable = gtmdlHdmiTxDriverConfigTable[instance].pMirrorTableCCIR656;
//#ifdef TMFL_RGB_DDR_12BITS
//		pMux = &gtmdlHdmiTxDriverConfigTable[instance].pMux_RGB_DDR_12bits[0];
//#endif
//		pEnaVideoPortTable = gtmdlHdmiTxDriverConfigTable[instance].pEnableVideoPortCCIR656;
//		pGndVideoPortTable = gtmdlHdmiTxDriverConfigTable[instance].pGroundVideoPortCCIR656;
//		break;
//
//	case TMDL_HDMITX_VINMODE_RGB444:
//		pSwapTable = gtmdlHdmiTxDriverConfigTable[instance].pSwapTableRGB444;
//		pMirrorTable = gtmdlHdmiTxDriverConfigTable[instance].pMirrorTableRGB444;
//		pEnaVideoPortTable = gtmdlHdmiTxDriverConfigTable[instance].pEnableVideoPortRGB444;
//		pGndVideoPortTable = gtmdlHdmiTxDriverConfigTable[instance].pGroundVideoPortRGB444;
//		break;
//
//	case TMDL_HDMITX_VINMODE_YUV444:
//		pSwapTable = gtmdlHdmiTxDriverConfigTable[instance].pSwapTableYUV444;
//		pMirrorTable = gtmdlHdmiTxDriverConfigTable[instance].pMirrorTableYUV444;
//		pEnaVideoPortTable = gtmdlHdmiTxDriverConfigTable[instance].pEnableVideoPortYUV444;
//		pGndVideoPortTable = gtmdlHdmiTxDriverConfigTable[instance].pGroundVideoPortYUV444;
//		break;
//
//	case TMDL_HDMITX_VINMODE_YUV422:
//		pSwapTable = gtmdlHdmiTxDriverConfigTable[instance].pSwapTableYUV422;
//		pMirrorTable = gtmdlHdmiTxDriverConfigTable[instance].pMirrorTableYUV422;
//#ifdef TMFL_RGB_DDR_12BITS
//		pMux = &gtmdlHdmiTxDriverConfigTable[instance].pMux_RGB_DDR_12bits[0];
//#endif
//		pEnaVideoPortTable = gtmdlHdmiTxDriverConfigTable[instance].pEnableVideoPortYUV422;
//		pGndVideoPortTable = gtmdlHdmiTxDriverConfigTable[instance].pGroundVideoPortYUV422;
//		break;
//
//#ifdef TMFL_RGB_DDR_12BITS
//	case TMDL_HDMITX_VINMODE_RGB_DDR_12BITS:
//		pSwapTable = gtmdlHdmiTxDriverConfigTable[instance].pSwapTableRGB_DDR_12bits;
//		pMirrorTable = gtmdlHdmiTxDriverConfigTable[instance].pMirrorTableRGB_DDR_12bits;
//		pMux = &gtmdlHdmiTxDriverConfigTable[instance].pMux_RGB_DDR_12bits[0];
//		pEnaVideoPortTable = gtmdlHdmiTxDriverConfigTable[instance].pEnableVideoPortRGB_DDR_12bits;
//		pGndVideoPortTable = gtmdlHdmiTxDriverConfigTable[instance].pGroundVideoPortRGB_DDR_12bits;
//		break;
//#endif
//	default:
//		break;
//	}

	err = tda998x_set_video_port_enable(dev);


	err = tda998x_set_video_port_map(dev);

//	tmbslHdmiTxVideoInSetMapping(instance, pSwapTable, pMirrorTable);

	/* Set fine image position */
	err = tda998x_set_video_in_fine(dev, spSync, HDMITX_PIXTOGL_NO_ACTION);

	/* Set input blanking */
	errCode = tmbslHdmiTxVideoInSetBlanking(instance, blankit, HDMITX_BLNKCODE_ALL_0);

	/* Configure video input options and control the upsampler */
	errCode = tmbslHdmiTxVideoInSetConfig(instance,
					(tmbslHdmiTxVinMode_t)videoInputConfig.mode, (tmbslHdmiTxVidFmt_t)videoOutputConfig.format,
					(tmbslHdmiTx3DStructure_t)videoInputConfig.structure3D, pixelEdge,
					(tmbslHdmiTxPixRate_t)videoInputConfig.pixelRate, HDMITX_UPSAMPLE_AUTO);

	/* Set input ouput - may give NOT_SUPPORTED error */
	errCode = tmbslHdmiTxVideoSetInOut(instance, (tmbslHdmiTxVidFmt_t)videoInputConfig.format,
					(tmbslHdmiTx3DStructure_t)videoInputConfig.structure3D,
					HDMITX_SCAMODE_AUTO, (tmbslHdmiTxVidFmt_t)videoOutputConfig.format,
					pixRepeat, HDMITX_MATMODE_AUTO, pathBits, (tmbslHdmiTxVQR_t) videoOutputConfig.dviVqr);

	/* Only set audio for HDMI, not DVI */
	if (sinkType == TMDL_HDMITX_SINK_HDMI) {
		/* Set audio parameters */
		errCode = tmdlHdmiTxSetAudioInput(instance, audioInputConfig, sinkType);
		/* Take the sempahore */
		errCode = tmdlHdmiTxIWSemaphoreP(dlHdmiTxItSemaphore[instance]);
	}

	/* Output fine adjustment */
	pixRateSingleDouble = (tmbslHdmiTxPixRate_t)videoInputConfig.pixelRate;
	if (videoInputConfig.pixelRate == HDMITX_PIXRATE_SINGLE_REPEATED)
		pixRateSingleDouble = HDMITX_PIXRATE_SINGLE;

	if (videoInputConfig.structure3D != HDMITX_3D_FRAME_PACKING) {
		err = dlHdmiTxGetReflineRefpix(videoInputConfig.format,
					videoInputConfig.mode,
					videoOutputConfig.format,
					syncIn,
					(tmdlHdmiTxPixRate_t)pixRateSingleDouble,
					&uRefPix,
					&uRefLine,
					&uScRefPix,
					&uScRefLine,
					&bVerified);

		if (err > 0){
			/* From 720p50/60 or 1080i50/60 up-scaling to 1080p50/60, when external sync,
			   toggleV, toggleH and toggleX need to be set to 0 */
			if (syncIn == EXT) {
				switch (videoInputConfig.format) {
				case TMDL_HDMITX_VFMT_04_1280x720p_60Hz:
				case TMDL_HDMITX_VFMT_19_1280x720p_50Hz:
				case TMDL_HDMITX_VFMT_05_1920x1080i_60Hz:
				case TMDL_HDMITX_VFMT_20_1920x1080i_50Hz:
					if ((videoOutputConfig.format == TMDL_HDMITX_VFMT_16_1920x1080p_60Hz) ||
							(videoOutputConfig.format == TMDL_HDMITX_VFMT_31_1920x1080p_50Hz)) {
						toggle = HDMITX_PIXTOGL_NO_ACTION;
					}
					break;
				default:
					toggle = HDMITX_PIXTOGL_ENABLE;
					break;
				}
			}

			/* Combination found in table for scaler: configure input manually */
			err = tmbslHdmiTxVideoInSetSyncManual(instance,
							(tmbslHdmiTxSyncSource_t)videoInputConfig.syncSource,
							syncMethod,
							toggle,
							toggle,
							toggle,
							uRefPix,
							uRefLine);
		}
	} else {
		/* Not found so assume non-scaler and auto-configure input */
		err = tmbslHdmiTxVideoInSetSyncAuto(instance,
						(tmbslHdmiTxSyncSource_t)videoInputConfig.syncSource,
						(tmbslHdmiTxVidFmt_t)videoInputConfig.format,
						(tmbslHdmiTxVinMode_t)videoInputConfig.mode,
						(tmbslHdmiTx3DStructure_t)videoInputConfig.structure3D);
	}

	/* Only set infoframes for HDMI, not DVI */
	if (sinkType == TMDL_HDMITX_SINK_HDMI) {
		/* Set avi infoframe */
		erre = dlHdmiTxSetVideoInfoframe(instance, videoOutputConfig.format, videoOutputConfig.mode);
	}

	err = tmbslHdmiTxScalerGetMode(instance, &scalerMode);

	/* Ignore scaler TMBSL_ERR_HDMI_NOT_SUPPORTED error */
	if ((errCode == TM_OK) && (scalerMode == HDMITX_SCAMODE_ON)) {
		/* Enable scaler mode */
		err = tmbslHdmiTxScalerInDisable(instance, False);

        		/* Correction to interlace */
        		topSel = HDMITX_TOPSEL_INTERNAL;
		if ((videoOutputConfig.format == TMDL_HDMITX_VFMT_05_1920x1080i_60Hz) ||
				(videoOutputConfig.format == TMDL_HDMITX_VFMT_20_1920x1080i_50Hz)) {
			/* video input format is range-checked by tmbslHdmiTxVideoSetInOut above */
			vinFmtIndex = dlHdmiTxCalcVidFmtIndex(videoInputConfig.format);
			if ((kVfmtToShortFmt_TV[vinFmtIndex] == TV_480p_60Hz) ||
					(kVfmtToShortFmt_TV[vinFmtIndex] == TV_576p_50Hz)) {
				/* Correct for 1080i output for p->i conversion only */
				topSel = HDMITX_TOPSEL_VRF;
			}
		}

		/* Set scaler field positions */
		err = tmbslHdmiTxScalerSetFieldOrder(instance,
					HDMITX_INTEXT_NO_CHANGE,
					HDMITX_INTEXT_NO_CHANGE,
					topSel,
					HDMITX_TOPTGL_NO_CHANGE);

		/* Scaler fine adjustment */
		err = tmbslHdmiTxScalerSetFine(instance, uScRefPix, uScRefLine);

		if ((videoOutputConfig.format == TMDL_HDMITX_VFMT_16_1920x1080p_60Hz) ||
				(videoOutputConfig.format == TMDL_HDMITX_VFMT_31_1920x1080p_50Hz)) {
			phasesH = HDMITX_H_PHASES_16;
		} else {
			phasesH = HDMITX_H_PHASES_15;
		}

		/* Set scaler phase */
		err = tmbslHdmiTxScalerSetPhase(instance, phasesH);

		/* Set scaler latency */
		err = tmbslHdmiTxScalerSetLatency(instance, 0x22);

		/* Set scaler synchronisation option */
		err = tmbslHdmiTxScalerSetSync(instance,
					syncMethod,
					HDMITX_VSONCE_EACH_FRAME);

		/* With scaler, use Only Once setting for tmbslHdmiTxVideoOutSetSync */
		once = HDMITX_VSONCE_ONCE;
	} else {
		once = HDMITX_VSONCE_EACH_FRAME;
	}

	/* Set video synchronisation */
	err = tmbslHdmiTxVideoOutSetSync(instance,
				HDMITX_VSSRC_INTERNAL,
				HDMITX_VSSRC_INTERNAL,
				HDMITX_VSSRC_INTERNAL,
				HDMITX_VSTGL_TABLE,
				once);
	return TM_OK;
}


/**
 * @brief	Initialize TDA1998x HDMI Transmitter
 *
 * @param dev:
 * @param cfg:
 * @return 0 on success, error status otherwise
 */
int tda998x_init(struct tda998x_dev *dev)
{
	int err;
	uint8_t reg_val;

	/* Reset ENAMODS */
	err = cec_write_reg(dev, ENAMODS, 0x40);
	if (err < 0)
		return err;

	/* Enable HDMI and RX sense and FRO */
	err = cec_write_reg_mask(dev,
			ENAMODS,
			ENAMODS_ENA_HDMI | ENAMODS_ENA_RXS | ENAMODS_DIS_FRO,
			ENAMODS_ENA_HDMI | ENAMODS_ENA_RXS);
	if (err < 0)
		return err;

	/**
	 * Reset device
	 */
	err = write_reg_mask(dev,
			SR_REG,
			SR_REG_SR_I2C_MS | SR_REG_SR_AUDIO,
			SR_REG_SR_I2C_MS | SR_REG_SR_AUDIO);
	if (err < 0)
		return err;

//	pDis->sysFuncTimer(50); /* ms */

	err = write_reg_mask(dev,
			SR_REG,
			SR_REG_SR_I2C_MS | SR_REG_SR_AUDIO,
			0);
	if (err < 0)
		return err;

	/* Soft reset */
	err = write_reg_mask(dev,
			MAIN_CNTRL0,
			MAIN_CNTRL0_SR,
			MAIN_CNTRL0_SR);
	if (err < 0)
		return err;

	/* pDis->sysFuncTimer(50); */ /* ms */

	err = write_reg_mask(dev,
			MAIN_CNTRL0,
			MAIN_CNTRL0_SR,
			0);
	if (err < 0)
		return err;

	/* pDis->sysFuncTimer(50); */ /* ms */

	/* Clear color bars */
	err = write_reg_mask(dev,
			HVF_CNTRL_0,
			HVF_CNTRL_0_SM,
			0);
	if (err < 0)
		return err;

	/*
	 * Read the device version registers
	 */
	err = read_reg(dev, VERSION, &reg_val);
	if (err < 0)
		return err;

	dev->version = reg_val;

	/* Version MSB value */
	err = read_reg(dev, VERSION_MSB, &reg_val);
	if (err < 0)
		return err;

	dev->version |= (uint16_t)reg_val << 8;

	/** VSWING default value */
	//	#define HDMI_TX_VSWING_VALUE 0x09
	err = write_reg(dev, ANA_GENERAL, 0x09U);
	if (err < 0)
		return err;

	/* Set the PLL before resetting the device */
	/**
	 * Table of PLL settings registers to configure for all video input format (vinFmt)
	 */
//	CONST_DAT tmHdmiTxRegMaskVal_t kCommonPllCfg[] =
//	{
//	    {E_REG_P02_PLL_SERIAL_1_RW, E_MASKREG_ALL,  0x00},
//	    {E_REG_P02_PLL_SERIAL_2_RW, E_MASKREG_ALL,  0x01},
//	    {E_REG_P02_PLL_SERIAL_3_RW, E_MASKREG_ALL,  0x00},
//	    {E_REG_P02_SERIALIZER_RW,   E_MASKREG_ALL,  0x00},
//	    {E_REG_P02_BUFFER_OUT_RW,   E_MASKREG_ALL,  0x00},
//	    {E_REG_P02_PLL_SCG1_RW,     E_MASKREG_ALL,  0x00},
//	    {E_REG_P02_AUDIO_DIV_RW,    E_MASKREG_ALL,  0x03},
//	    /*{E_REG_P02_TEST2_RW,        E_MASKREG_ALL,  0x00},*/
//	    {E_REG_P02_SEL_CLK_RW,      E_MASKREG_ALL,  0x09},
//	    {0,0,0}
//	};
//
//	err = write_reg(dev, )

	err = write_reg_mask(dev,
			VIP_CNTRL_4,
			VIP_CNTRL_4_656_ALT,
			0);
	if (err < 0)
		return err;

	switch (vinFmt) {
	case HDMITX_VFMT_06_720x480i_60Hz:
	case HDMITX_VFMT_07_720x480i_60Hz:
	case HDMITX_VFMT_21_720x576i_50Hz:
	case HDMITX_VFMT_22_720x576i_50Hz:


		/**
		 * Table of PLL settings registers to configure for single mode pixel rate,
		 * vinFmt 480i or 576i only
		 */

		/**
		 * Table of PLL settings registers to configure for 480i and 576i vinFmt
		 */
//		CONST_DAT tmHdmiTxRegMaskVal_t kVfmt480i576iPllCfg[] =
//		{
//		    {E_REG_P02_PLL_SCGN1_RW,    E_MASKREG_ALL,  0x14},
//		    {E_REG_P02_PLL_SCGN2_RW,    E_MASKREG_ALL,  0x00},
//		    {E_REG_P02_PLL_SCGR1_RW,    E_MASKREG_ALL,  0x0A},
//		    {E_REG_P02_PLL_SCGR2_RW,    E_MASKREG_ALL,  0x00},
//		    {0,0,0}
//		};
		err = setHwRegisterFieldTable(pDis, &kVfmt480i576iPllCfg[0]);
		RETIF_REG_FAIL(err)

		/**
		 * Table of PLL settings registers to configure single mode pixel rate,
		 * vinFmt other than 480i or 576i
		 */
		CONST_DAT tmHdmiTxRegMaskVal_t kSinglePrateVfmtOtherPllCfg[] =
		{
		    {E_REG_P02_PLL_SCG2_RW,     E_MASKREG_ALL,  0x10},
		    {0,0,0}
		};

		switch (pixRate) {
		case HDMITX_PIXRATE_SINGLE:
			/* Single edge mode, vinFmt 480i or 576i */
//			CONST_DAT tmHdmiTxRegMaskVal_t kSinglePrateVfmt480i576iPllCfg[] =
//			{
//			    {E_REG_P02_PLL_SCG2_RW,     E_MASKREG_ALL,  0x11},
//			    {0,0,0}
//			};
			err = setHwRegisterFieldTable(pDis, &kSinglePrateVfmt480i576iPllCfg[0]);
			RETIF_REG_FAIL(err)

			break;
		case HDMITX_PIXRATE_SINGLE_REPEATED:
			/* Single repeated edge mode, vinFmt 480i or 576i */

			/**
			 * Table of PLL settings registers to configure for single repeated mode pixel rate,
			 * vinFmt 480i or 576i only
			 */
//			CONST_DAT tmHdmiTxRegMaskVal_t kSrepeatedPrateVfmt480i576iPllCfg[] =
//			{
//			    {E_REG_P02_PLL_SCG2_RW,     E_MASKREG_ALL,  0x01},
//			    {0,0,0}
//			};

			err = setHwRegisterFieldTable(pDis, &kSrepeatedPrateVfmt480i576iPllCfg[0]);
			RETIF_REG_FAIL(err)

			break;
		default:
			/* Double edge mode doesn't exist for vinFmt 480i or 576i */
			return(TMBSL_ERR_HDMI_INCONSISTENT_PARAMS);
		}
		break;
	default:

		/**
		 * Table of PLL settings registers to configure for other vinFmt than 480i and 576i
		 */
//		CONST_DAT tmHdmiTxRegMaskVal_t kVfmtOtherPllCfg[] =
//		{
//		    {E_REG_P02_PLL_SCGN1_RW,    E_MASKREG_ALL,  0xFA},
//		    {E_REG_P02_PLL_SCGN2_RW,    E_MASKREG_ALL,  0x00},
//		    {E_REG_P02_PLL_SCGR1_RW,    E_MASKREG_ALL,  0x5B},
//		    {E_REG_P02_PLL_SCGR2_RW,    E_MASKREG_ALL,  0x00},
//		    {0,0,0}
//		};
		err = setHwRegisterFieldTable(pDis, &kVfmtOtherPllCfg[0]);
		RETIF_REG_FAIL(err)

		switch (pixRate) {
		case HDMITX_PIXRATE_SINGLE:
			/* Single edge mode, vinFmt other than 480i or 576i */




			err = setHwRegisterFieldTable(pDis, &kSinglePrateVfmtOtherPllCfg[0]);
			RETIF_REG_FAIL(err)
			break;
		case HDMITX_PIXRATE_DOUBLE:
			/* Double edge mode, vinFmt other than 480i or 576i */
			/**
			 * Table of PLL settings registers to configure double mode pixel rate,
			 * vinFmt other than 480i or 576i
			 */
//			CONST_DAT tmHdmiTxRegMaskVal_t kDoublePrateVfmtOtherPllCfg[] =
//			{
//			    {E_REG_P02_PLL_SCG2_RW,     E_MASKREG_ALL,  0x00},
//			    {0,0,0}
//			};
			err = setHwRegisterFieldTable(pDis, &kDoublePrateVfmtOtherPllCfg[0]);
			RETIF_REG_FAIL(err)
			break;
		default:
			/* Single repeated edge mode doesn't exist for other vinFmt */
			return(TMBSL_ERR_HDMI_INCONSISTENT_PARAMS);
		}
		break;
	}

	/* DDC interface is disable for TDA9989 after reset, enable it */
	err = write_reg(dev, DDC_DISABLE, 0x00);
	if (err < 0)
		return err;

	/* Set DDC channel clock speed */
	err = write_reg(dev, OTP_TX3, 0x27);
	if (err < 0)
		return err;

	/* TDA19989 N1 only */
	if (pDis->uDeviceVersion == E_DEV_VERSION_TDA19989) {
		/* 0: enable multi master mode */
		err = write_reg_mask(dev,
				I2C_MASTER,
				I2C_MASTER_DIS_MM,
				0);
		if (err < 0)
			return err;
	}

	err = cec_write_reg(dev,
			FRO_IM_CLK_CTRL,
			FRO_IM_CLK_CTRL_IMCLK_SEL | FRO_IM_CLK_CTRL_GHOST_DIS);
	if (err < 0)
		return err;

	/* enable  sw _interrupt and  VS_interrupt for debug */
	err = write_reg(dev, INT_FLAGS_1, INT_FLAGS_1_SW_INT);

	/* enable edid read */
	err = write_reg(dev, INT_FLAGS_2, INT_FLAGS_2_EDID_BLK_RD);

	/* Read HPD RXS level */
	err = cec_read_reg(dev, RXSHPDLEV, &reg_val);

	/* Read Hot Plug input status to know the actual level that caused the interrupt */
	pDis->hotPlugStatus = (regVal & E_MASKREG_CEC_RXSHPDLEV_hpd_level) ?
		HDMITX_HOTPLUG_ACTIVE : HDMITX_HOTPLUG_INACTIVE;

	/*Read RXS_FIL status to know the actual level that caused the interrupt */
	pDis->rxSenseStatus = (regVal & E_MASKREG_CEC_RXSHPDLEV_rxs_level) ?
		 HDMITX_RX_SENSE_ACTIVE : HDMITX_RX_SENSE_INACTIVE;

	err = cec_write_reg_mask(dev,
				RXSHPDINTENA,
				RXSHPDINTENA_ENA_RXS_INT | RXSHPDINTENA_ENA_HPD_INT,
				RXSHPDINTENA_ENA_RXS_INT | RXSHPDINTENA_ENA_HPD_INT);

	err = cec_read_reg(dev, RXSHPDLEV, &reg_val);

	/* Start by forcing the TMDS ouputs off */
	err = tda998x_set_outputs(dev, HDMITX_TMDSOUT_FORCED0);


	err = tda998x_set_inout();
//	tmdlHdmiTxSetInputOutput(HdmiTxInstance, HdmiTxVideoInputConfig, HdmiTxVideoOutputConfig, HdmiTxAudioInputConfig, TMDL_HDMITX_SINK_HDMI);

	return (0);
}



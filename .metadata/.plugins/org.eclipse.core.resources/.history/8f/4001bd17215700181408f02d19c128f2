/**
 *******************************************************************************
 *******************************************************************************
 *
 * @file    axidma_uio.c
 * @author  R. Bush
 * @email   bush@krtkl.com
 * @version 0.1
 * @date    Jan 16, 2018
 * @brief   AXI DMA Userspace I/O Driver
 * @license FreeBSD
 *
 *******************************************************************************
 *
 * Copyright (c) 2018, krtkl inc.
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 * 1. Redistributions of source code must retain the above copyright notice,
 *    this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright notice,
 *    this list of conditions and the following disclaimer in the documentation
 *    and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
 * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
 * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
 * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
 * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
 * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
 * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
 * POSSIBILITY OF SUCH DAMAGE.
 *
 * The views and conclusions contained in the software and documentation are
 * those of the authors and should not be interpreted as representing official
 * policies, either expressed or implied, of the FreeBSD Project.
 *
 *******************************************************************************
 */


//#include <stdio.h>
//#include <stdlib.h>
//#include <unistd.h>
//#include <fcntl.h>
//#include <errno.h>


#define AXIVDMA_MM2S_CR			(0x00000000U)	/**< MM2S control register */

#define MM2S_CR_IRQ_DLY_CNT		(0xFF000000U)
#define MM2S_CR_IRQ_FRM_CNT		(0x00FF0000U)
#define MM2S_CR_RPT_EN			(1 << 15)
#define MM2S_CR_ERR_IRQ_EN		(1 << 14)
#define MM2S_CR_DLY_CNT_IRQ_EN		(1 << 13)
#define MM2S_CR_FRM_CNT_IRQ_EN		(1 << 12)
#define MM2S_CR_RD_PTR_NUM		(0x00000F00U)
#define MM2S_CR_GEN_LOCK_SRC		(1 << 7)
#define MM2S_CR_FRM_CNT_EN		(1 << 4)
#define MM2S_CR_GEN_LOCK_EN		(1 << 3)
#define MM2S_CR_RESET			(1 << 2)
#define MM2S_CR_CIRC_PARK		(1 << 1)
#define MM2S_CR_RUN_STOP		(1 << 0)

#define AXIVDMA_MM2S_SR			(0x00000004U)	/**< MM2S status register */

#define MM2S_SR_IRQ_DLY_CNT_STS		(0xFF000000U)	/**< Interrupt delay count status */
#define MM2S_SR_IRQ_FRM_CNT_STS		(0x00FF0000U)	/**< Interrupt frame count status */
#define MM2S_SR_IRQ_ERR			(1 << 14)	/**< Interrupt on error */
#define MM2S_SR_IRQ_DLY_CNT		(1 << 13)	/**< Interrupt on delay */
#define MM2S_SR_IRQ_FRM_CNT		(1 << 12)	/**< Frame count interrupt */
#define MM2S_SR_ERR_SOF_ERLY		(1 << 7)	/**< Start of frame early error */
#define MM2S_SR_ERR_VDMA_DEC		(1 << 6)	/**< VDMA decode error */
#define MM2S_SR_ERR_VDMA_SLV		(1 << 5)	/**< VDMA slave error */
#define MM2S_SR_ERR_VDMA_INT		(1 << 4)	/**< VDMA internal error */
#define MM2S_SR_HALTED			(1 << 0)	/**< VDMA channel halted */

#define AXIVDMA_MM2S_INDEX		(0x00000014U)	/**< MM2S register index */
#define AXIVDMA_PARK_PTR		(0x00000028U)	/**< Park pointer */
#define AXIVDMA_VERSION			(0x0000002CU)	/**< Video DMA version */
#define AXIVDMA_S2MM_CR			(0x00000030U)	/**< S2MM control register */
#define AXIVDMA_S2MM_SR			(0x00000034U)	/**< S2MM status register */
#define AXIVDMA_S2MM_IRQ_MASK		(0x0000003CU)	/**< S2MM error interrupt mask */
#define AXIVDMA_S2MM_INDEX		(0x00000044U)	/**< S2MM register index */
#define AXIVDMA_MM2S_VSIZE		(0x00000050U)	/**< MM2S vertical size */
#define AXIVDMA_MM2S_HSIZE		(0x00000054U)	/**< MM2S horizontal size */
#define AXIVDMA_MM2S_FRMDLYSTRD		(0x00000058U)	/**< MM2S frame delay and stride */
#define AXIVDMA_MM2S_START_ADDRESS	(0x0000005CU)	/**< MM2S start address */
#define AXIVDMA_S2MM_VSIZE		(0x000000A0U)	/**< S2MM vertical size */
#define AXIVDMA_S2MM_HSIZE		(0x000000A4U)	/**< S2MM horizontal size */
#define AXIVDMA_S2MM_FRMDLYSTRD		(0x000000A8U)	/**< S2MM frame delay and stride */
#define AXIVDMA_S2MM_START_ADDRESS	(0x000000ACU)	/**< S2MM start address */


/**
 * From AXI Video Direct Memory Access v6.2 - PG020
 *
 * Programming Sequence
 *
 * AXI VDMA operations begin with the setup of the video parameter and start address
 * registers and the VDMA control registers. The following lists the minimum steps, in order,
 * required to start AXI VDMA operations:
 *
 *   1. Write control information to the channel VDMACR register (Offset 0x00 for MM2S and
 *      0x30 for S2MM) to set interrupt enables if desired, and set VDMACR.RS=1 to start the
 *      AXI VDMA channel running.
 *
 *   2. Write a valid video frame buffer start address to the channel START_ADDRESS register 1
 *      to N where N equals Frame Buffers (Offset 0x5C up to 0x98 for MM2S and 0xAC up to
 *      0xE8 for S2MM). Set the REG_INDEX register if required.
 *
 *      When AXI VDMA is configured for an address space greater than 32, each start address
 *      is to be programmed as a combination of two registers wherein the first register is used
 *      to specify LSB 32 bits of address while the next register is used to specify MSB 32 bits.
 *
 *   3. Write a valid Frame Delay (valid only for Genlock Slave) and Stride to the channel
 *      FRMDLY_STRIDE register (Offset 0x58 for MM2S and 0xA8 for S2MM).
 *
 *   4. Write a valid Horizontal Size to the channel HSIZE register (Offset 0x54 for MM2S and
 *      0xA4 for S2MM).
 *
 *   5. Write a valid Vertical Size to the channel VSIZE register (Offset 0x50 for MM2S and
 *      0xA0 for S2MM). This starts the channel transferring video data.
 *
 * You should be able to update video parameter settings at any time while the engine is
 * running by writing new video parameters and a video start address through the AXI4-Lite
 * control interface. The newly written video transfer values take effect on the next frame
 * boundary after you write the vertical size register for the respective channel.
 * To update video parameters dynamically while AXI VDMA operations are ongoing, a similar
 * process to the start steps is needed.
 *
 *   1. Write the Frame Delay, Stride, and Horizontal Size in any order for the associated
 *      channel.
 *
 *   2. Write the Vertical Size. When VSize is written, the video register values are transferred to
 *      an internal register block. On the next frame boundary the VDMA controller for the
 *      associated channel starts transfers using the newly updated values.
 *
 * Interrupts
 *
 * An interrupt output is provided for each channel (MM2S and S2MM). This output drives
 * High when there is an error if the error interrupt is enabled.
 *
 */


/**
 * @brief	Reset a DMA Channel
 */
int
axidma_reset(AxiDma *dma)
{
	int ret;

	if (dma == NULL || dma->ctrl == NULL)
		return -EINVAL;

	/* setting the MM2S reset will reset the entire DMA engine */
	ret = uio_write_reg (dma->ctrl, AXIDMA_CR_RESET, AXIDMA_MM2S_OFFSET + AXIDMA_CR_OFFSET);
	if (ret < 0)
		goto out;

	ret = uio_write_reg (dma->ctrl, AXIDMA_CR_RESET, AXIDMA_S2MM_OFFSET + AXIDMA_CR_OFFSET);
	if (ret < 0)
		goto out;

//	ret = uio_read_reg (dma->ctrl, &val, AXIDMA_MM2S_OFFSET + AXIDMA_SR_OFFSET);
//	if (ret < 0)
//		goto out;
//
//	while (!(val & AXIDMA_SR_HALTED)) {
//		if (val & AXIDMA_SR_IDLE)
//			break;
//
//		ret = uio_read_reg (dma->ctrl, &val, AXIDMA_MM2S_OFFSET + AXIDMA_SR_OFFSET);
//		if (ret < 0)
//			goto out;
//	}

	ret = uio_mask_write_reg (dma->ctrl, 0, AXIDMA_CR_RESET, AXIDMA_MM2S_OFFSET + AXIDMA_CR_OFFSET);
	if (ret < 0)
		goto out;

	ret = uio_mask_write_reg (dma->ctrl, 0, AXIDMA_CR_RESET, AXIDMA_S2MM_OFFSET + AXIDMA_CR_OFFSET);
out:
	return ret;
}


/**
 *
 *
 *
 *
 *
 *
 */
int
axidma_ready(AxiDma *dma, AxiDmaChan chan)
{
	int ret;
	unsigned long offset, reg;

	switch (chan) {
	case AXIDMA_MM2S_CHANNEL: offset = AXIDMA_MM2S_OFFSET; break;
	case AXIDMA_S2MM_CHANNEL: offset = AXIDMA_S2MM_OFFSET; break;
	}

	ret = uio_read_reg (dma->ctrl, &reg, offset + AXIDMA_SR_OFFSET);
	if (ret < 0)
		return ret;

	return (reg & AXIDMA_SR_HALTED ? 1 : 0);
}


int
axidma_idle(AxiDma *dma, AxiDmaChan chan)
{
	int ret;
	unsigned long offset, reg;

	switch (chan) {
	case AXIDMA_MM2S_CHANNEL: offset = AXIDMA_MM2S_OFFSET; break;
	case AXIDMA_S2MM_CHANNEL: offset = AXIDMA_S2MM_OFFSET; break;
	}

	ret = uio_read_reg (dma->ctrl, &reg, offset + AXIDMA_SR_OFFSET);
	if (ret < 0)
		return ret;

	return (reg & AXIDMA_SR_IDLE ? 1 : 0);
}


int
axidma_irq_enable(AxiDma *dma, AxiDmaChan chan, unsigned long irq)
{
	unsigned long offset;

	if (dma == NULL || dma->ctrl == NULL)
		return -EINVAL;

	switch (chan) {
	case AXIDMA_MM2S_CHANNEL: offset = AXIDMA_MM2S_OFFSET; break;
	case AXIDMA_S2MM_CHANNEL: offset = AXIDMA_S2MM_OFFSET; break;
	}

	return uio_mask_write_reg (dma->ctrl, irq, AXIDMA_CR_IRQALL, offset + AXIDMA_CR_OFFSET);
}


int
axidma_irq_disable(AxiDma *dma, AxiDmaChan chan, unsigned long irq)
{
	unsigned long offset;

	if (dma == NULL || dma->ctrl == NULL)
		return -EINVAL;

	switch (chan) {
	case AXIDMA_MM2S_CHANNEL: offset = AXIDMA_MM2S_OFFSET; break;
	case AXIDMA_S2MM_CHANNEL: offset = AXIDMA_S2MM_OFFSET; break;
	}

	return uio_mask_write_reg (dma->ctrl, 0, irq, offset + AXIDMA_CR_OFFSET);
}


int
axidma_init(AxiDma *dma)
{
	int ret;

	if (dma == NULL)
		return -EINVAL;

	/* DMA engine control device */
	dma->ctrl = uio_new (0);
	if (dma->ctrl == NULL)
		return -ENOMEM;

	ret = uio_dev_open (dma->ctrl);
	if (ret < 0)
		return ret;

	ret = uio_init_maps (dma->ctrl);
	if (ret < 0)
		return ret;

	/* memory to stream interrupt and memory region device */
	dma->mm2s = uio_new (1);
	if (dma->mm2s == NULL)
		return -ENOMEM;

	ret = uio_dev_open (dma->mm2s);
	if (ret < 0)
		return ret;

	ret = uio_init_maps (dma->mm2s);
	if (ret < 0)
		return ret;

	/* stream to memory interrupt and memory region device */
	dma->s2mm = uio_new (2);
	if (dma->s2mm == NULL)
		return -ENOMEM;

	ret = uio_dev_open (dma->s2mm);
	if (ret < 0)
		return ret;

	ret = uio_init_maps (dma->s2mm);
	if (ret < 0)
		return ret;

	return 0;
}


int
axidma_transfer(AxiDma *dma, AxiDmaXfer *xfer)
{
	int ret;
	unsigned long offset;

	if (dma == NULL || dma->ctrl == NULL || xfer == NULL)
		return -EINVAL;

	if (xfer->len > AXIDMA_MAX_LENGTH)
		return -EINVAL;

	/* which channel is it for? */
	switch (xfer->chan) {
	case AXIDMA_MM2S_CHANNEL: offset = AXIDMA_MM2S_OFFSET; break;
	case AXIDMA_S2MM_CHANNEL: offset = AXIDMA_S2MM_OFFSET; break;
	}

	/* set source/destination address */
	ret = uio_write_reg (dma->ctrl, xfer->addr, offset + AXIDMA_SRCDEST_OFFSET);
	if (ret < 0)
		goto out;

	if (xfer->addr_width > 32) {
		ret = uio_write_reg (dma->ctrl, xfer->addr_msb, offset + AXIDMA_SRCDEST_MSB_OFFSET);
		if (ret < 0)
			goto out;
	} else {
		ret = uio_write_reg (dma->ctrl, 0, offset + AXIDMA_SRCDEST_MSB_OFFSET);
		if (ret < 0)
			goto out;
	}

	/* run the channel */
	ret = uio_mask_write_reg (dma->ctrl, AXIDMA_CR_RUN, AXIDMA_CR_RUN, offset + AXIDMA_CR_OFFSET);
	if (ret < 0)
		goto out;

	/* set the length (this will start the transfer) */
	ret = uio_write_reg (dma->ctrl, xfer->len, offset + AXIDMA_LENGTH_OFFSET);
out:
	return ret;
}


int
axidma_transfer_end(AxiDma *dma, AxiDmaChan chan)
{
	int ret;
	unsigned long reg_val, offset;
	UioDevice *dev;

	if (dma == NULL || dma->mm2s == NULL || dma->s2mm == NULL)
		return -EINVAL;

	switch (chan) {
	case AXIDMA_MM2S_CHANNEL:
		dev = dma->mm2s;
		offset = AXIDMA_MM2S_OFFSET;
		break;
	case AXIDMA_S2MM_CHANNEL:
		dev = dma->s2mm;
		offset = AXIDMA_S2MM_OFFSET;
		break;
	default:
		return -EINVAL;
	}

	printf ("finishing DMA transfer\n");

	ret = uio_wait_on_irq (dev);
	if (ret < 0)
		return ret;

	printf ("waiting for DMA channel to be halted");

	ret = uio_read_reg (dma->ctrl, &reg_val, offset + AXIDMA_SR_OFFSET);
	if (ret < 0)
		return ret;

	while (!(reg_val & AXIDMA_SR_HALTED)) {
		if (reg_val & AXIDMA_SR_HALTED)
			break;

		ret = uio_read_reg (dma->ctrl, &reg_val, offset + AXIDMA_SR_OFFSET);
		if (ret < 0)
			return ret;
	}

	return 0;
}





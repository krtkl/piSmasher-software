/**
 *******************************************************************************
 *******************************************************************************
 *
 * @file	tda998x.c
 * @author	R. Bush
 * @email	bush@krtkl.com
 * @version	v1.0
 * @date	2017 November 10
 * @brief	TDA998x HDMI Transmitter
 * @license	FreeBSD
 *
 *******************************************************************************
 *
 * Copyright (c) 2017, krtkl inc.
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 * 1. Redistributions of source code must retain the above copyright notice,
 *	  this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright notice,
 *	  this list of conditions and the following disclaimer in the documentation
 *	  and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
 * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
 * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
 * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
 * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
 * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
 * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
 * POSSIBILITY OF SUCH DAMAGE.
 *
 * The views and conclusions contained in the software and documentation are
 * those of the authors and should not be interpreted as representing official
 * policies, either expressed or implied, of the FreeBSD Project.
 *
 *******************************************************************************
 */

#include <stdio.h>
#include <stdint.h>
#include <stdbool.h>
#include <unistd.h>

#include "tda998x.h"

/**
 * @defgroup	TDA998X NXP TDA998x HDMI Transmitter
 * @{
 */
#define PAGE_ADDR(__PAGE__, __ADDR__)		(((__PAGE__) << 8) | ((__ADDR__) & 0xFFU))
#define PAGE_OF(__REG__)			((uint8_t)(((__REG__) >> 8) & 0xFFU))

/**
 * @addtogroup	TDA998X_CEC_Core
 * @{
 */
#define INTERRUPTSTATUS_CEC			(1 << 0)
#define INTERRUPTSTATUS_HDMI			(1 << 1)

#define RXSHPDINTENA_ENA_RXS_INT		(1 << 0)
#define RXSHPDINTENA_ENA_HPD_INT		(1 << 1)

#define RXSHPDINT_RXS_INT			(1 << 0)
#define RXSHPDINT_HPD_INT			(1 << 1)

#define RXSHPDLEV_RXS_LEVEL			(1 << 0)
#define RXSHPDLEV_HPD_LEVEL			(1 << 1)

#define ENAMODS_ENA_CEC				(1 << 0)
#define ENAMODS_ENA_HDMI			(1 << 1)
#define ENAMODS_ENA_RXS				(1 << 2)
#define ENAMODS_DIS_CCLK			(1 << 5)
#define ENAMODS_DIS_FRO				(1 << 6)

#define FRO_IM_CLK_CTRL_FRO_DIV			(1 << 0)
#define FRO_IM_CLK_CTRL_IMCLK_SEL		(1 << 1)
#define FRO_IM_CLK_CTRL_ENA_OTP			(1 << 6)
#define FRO_IM_CLK_CTRL_GHOST_DIS		(1 << 7)

/**
 * @brief	CEC Core Registers
 */
enum tda998x_cec_reg {
	INTERRUPTSTATUS = 0xEE,
	RXSHPDINTENA = 0xFC,
	RXSHPDINT = 0xFD,
	RXSHPDLEV = 0xFE,
	ENAMODS = 0xFF,
	FRO_IM_CLK_CTRL = 0xFB,
};
/**
 * @}
 */

/**
 * @addtogroup	TDA998X_HDMI_Core
 * @{
 */

/**
 * @addtogroup	TDA998X_HDMI_Core_Registers
 * @{
 */

/**
 * @brief	HDMI Core Register Pages
 */
enum tda998x_hdmi_page {
	PAGE_00 = 0x00,
	PAGE_01 = 0x01,
	PAGE_02 = 0x02,
	PAGE_09 = 0x09,
	PAGE_10 = 0x10,
	PAGE_11 = 0x11,
	PAGE_12 = 0x12,
	PAGE_13 = 0x13,
	PAGE_INVALID = 0xFF
};

#define VERSION_NOT_SCALER			(1 << 4)
#define VERSION_NOT_HDCP			(1 << 5)

#define MAIN_CNTRL0_SR				(1 << 0)
#define MAIN_CNTRL0_DECS			(1 << 1)
#define MAIN_CNTRL0_DEHS			(1 << 2)
#define MAIN_CNTRL0_CECS			(1 << 3)
#define MAIN_CNTRL0_CEHS			(1 << 4)
#define MAIN_CNTRL0_SCALER			(1 << 7)

#define SR_REG_SR_AUDIO				(1 << 0)
#define SR_REG_SR_I2C_MS			(1 << 1)

#define DDC_DISABLE_DDC_DIS			(1 << 0)

#define CCLK_ON_CCLK_DDC_ON			(1 << 0)

#define I2C_MASTER_DIS_MM			(1 << 0)
#define I2C_MASTER_DIS_FILT			(1 << 1)
#define I2C_MASTER_APP_STRT_LAT			(1 << 2)

#define INT_FLAGS_0_ENCRYPT			(1 << 0)
#define INT_FLAGS_0_HPD				(1 << 1)
#define INT_FLAGS_0_T0				(1 << 2)
#define INT_FLAGS_0_BCAPS			(1 << 3)
#define INT_FLAGS_0_BSTATUS			(1 << 4)
#define INT_FLAGS_0_SHA_1			(1 << 5)
#define INT_FLAGS_0_PJ				(1 << 6)
#define INT_FLAGS_0_R0				(1 << 7)

#define INT_FLAGS_1_VS_RPT			(1 << 0)
#define INT_FLAGS_1_OTP				(1 << 1)
#define INT_FLAGS_1_SC_IN			(1 << 2)
#define INT_FLAGS_1_SC_OUT			(1 << 3)
#define INT_FLAGS_1_SC_VID			(1 << 4)
#define INT_FLAGS_1_SC_DEIL			(1 << 5)
#define INT_FLAGS_1_SW_INT			(1 << 6)
#define INT_FLAGS_1_HPD_IN			(1 << 7)

#define INT_FLAGS_2_RX_SENSE			(1 << 0)
#define INT_FLAGS_2_EDID_BLK_RD			(1 << 1)

#define INT_FLAGS_3_RXS_FIL			(1 << 0)

#define SW_INT_SW_INT				(1 << 0)

#define ENA_ACLK_ENA_ACLK			(1 << 0)
#define GND_ACLK_GND_ACLK			(1 << 0)

#define ENA_VP_0_ENA_VP0			(1 << 0)
#define ENA_VP_0_ENA_VP1			(1 << 1)
#define ENA_VP_0_ENA_VP2			(1 << 2)
#define ENA_VP_0_ENA_VP3			(1 << 3)
#define ENA_VP_0_ENA_VP4			(1 << 4)
#define ENA_VP_0_ENA_VP5			(1 << 5)
#define ENA_VP_0_ENA_VP6			(1 << 6)
#define ENA_VP_0_ENA_VP7			(1 << 7)

#define ENA_VP_1_ENA_VP8			(1 << 0)
#define ENA_VP_1_ENA_VP9			(1 << 1)
#define ENA_VP_1_ENA_VP10			(1 << 2)
#define ENA_VP_1_ENA_VP11			(1 << 3)
#define ENA_VP_1_ENA_VP12			(1 << 4)
#define ENA_VP_1_ENA_VP13			(1 << 5)
#define ENA_VP_1_ENA_VP14			(1 << 6)
#define ENA_VP_1_ENA_VP15			(1 << 7)

#define ENA_VP_2_ENA_VP16			(1 << 0)
#define ENA_VP_2_ENA_VP17			(1 << 1)
#define ENA_VP_2_ENA_VP18			(1 << 2)
#define ENA_VP_2_ENA_VP19			(1 << 3)
#define ENA_VP_2_ENA_VP20			(1 << 4)
#define ENA_VP_2_ENA_VP21			(1 << 5)
#define ENA_VP_2_ENA_VP22			(1 << 6)
#define ENA_VP_2_ENA_VP23			(1 << 7)

#define ENA_AP_ENA_AP0				(1 << 0)
#define ENA_AP_ENA_AP1				(1 << 1)
#define ENA_AP_ENA_AP2				(1 << 2)
#define ENA_AP_ENA_AP3				(1 << 3)
#define ENA_AP_ENA_AP4				(1 << 4)
#define ENA_AP_ENA_AP5				(1 << 5)
#define ENA_AP_ENA_AP6				(1 << 6)
#define ENA_AP_ENA_AP7				(1 << 7)

#define VIP_CNTRL_SWAP_L_SHIFT			(0)
#define VIP_CNTRL_MIRR_L			(1 << 3)
#define VIP_CNTRL_SWAP_H_SHIFT			(4)
#define VIP_CNTRL_MIRR_H			(1 << 7)

#define VIP_CNTRL_SWAP_MASK			(0x77U)
enum vip_cntrl_swap {
	VIP_CNTRL_VP23_20 = 0x00,
	VIP_CNTRL_VP19_16 = 0x01,
	VIP_CNTRL_VP15_12 = 0x02,
	VIP_CNTRL_VP11_8 = 0x03,
	VIP_CNTRL_VP7_4 = 0x04,
	VIP_CNTRL_VP3_0 = 0x05
};

enum vip_cntrl_mirr {
	VIP_CNTRL_NOT_MIRRORED = 0,		/**< No action */
	VIP_CNTRL_MIRRORED = 1			/**< Mirrored (i.e. In[a:b] -> Out[b:a]) */
};

#define VIP_CNTRL_3_X_TGL			(1 << 0)
#define VIP_CNTRL_3_H_TGL			(1 << 1)
#define VIP_CNTRL_3_V_TGL			(1 << 2)
#define VIP_CNTRL_3_EMB				(1 << 3)
#define VIP_CNTRL_3_SP_SYNC_MASK		(0x30U)
enum vip_cntrl_3_sp_sync {
	PIXSUBPKT_FIX_0 = 0,
    	PIXSUBPKT_FIX_1 = 0x10,
    	PIXSUBPKT_FIX_2 = 0x20,
    	PIXSUBPKT_FIX_3 = 0x30
};

#define VIP_CNTRL_3_DE_INT			(1 << 6)
#define VIP_CNTRL_3_EDGE			(1 << 7)
enum vip_cntrl_3_edge {
	PIXEDGE_POS = 0,        		/**< Pixel Clock Positive Edge */
	PIXEDGE_NEG = VIP_CNTRL_3_EDGE,        /**< Pixel Clock Negative Edge */
};

#define VIP_CNTRL_4_BLC_MASK			(0x03U)
enum vip_cntrl_4_blc {
	BLNKCODE_ALL_0 = 0x00,			/**< All Zero */
	BLNKCODE_RGB444 = 0x01,			/**< RGB444 */
	BLNKCODE_YUV444 = 0x02,			/**< YUV444 */
	BLNKCODE_YUV422 = 0x03			/**< YUV422 */
};

#define VIP_CNTRL_4_BLNKIT_MASK			(0x0CU)
enum vip_cntrl_4_blnkit {
	BLNKSRC_NOT_DE = 0x00,			/**< Not DE */
	BLNKSRC_VS_HS = 0x04,			/**< VS AND HS */
	BLNKSRC_VS_NOT_HS = 0x08,		/**< VS AND NOT HS */
	BLNKSRC_VS_HEMB_VEMB = 0x0C		/**< Hemb AND Vemb */
};

#define VIP_CNTRL_4_CCIR656			(1 << 4)
#define VIP_CNTRL_4_656_ALT			(1 << 5)
#define VIP_CNTRL_4_TST_656			(1 << 6)
#define VIP_CNTRL_4_TST_PAT			(1 << 7)

#ifdef TDA19989
# define VIDFORMAT_3D_NEG_VS			(1 << 6)
# define VIDFORMAT_3D				(1 << 7)
#endif
#define VIDFORMAT_VIDFORMAT_MASK		(0x1FU)
enum tda998x_vidformat {
	VIDFORMAT_640x480p_60Hz = 0x00,
	VIDFORMAT_720x480p_60Hz = 0x01,
	VIDFORMAT_1280x720p_60Hz = 0x02,
	VIDFORMAT_1920x1080i_60Hz = 0x03,
	VIDFORMAT_720x480i_60Hz = 0x04,
	VIDFORMAT_720x240p_60Hz = 0x05,
	VIDFORMAT_1920x1080p_60Hz = 0x06,
	VIDFORMAT_720x576p_50Hz = 0x07,
	VIDFORMAT_1280x720p_50Hz = 0x08,
	VIDFORMAT_1920x1080i_50Hz = 0x09,
	VIDFORMAT_720x576i_50Hz = 0x0A,
	VIDFORMAT_720x288p_50Hz = 0x0B,
	VIDFORMAT_1920x1080p_50Hz = 0x0C
};

#define VIP_CNTRL_5_CKCASE			(1 << 0)
#define VIP_CNTRL_5_SP_CNT_MASK			(0x06U)
#define VIP_CNTRL_5_SP_CNT_SHIFT		(1)

#define MAT_CONTRL_MAT_SC			(0x03U)
#define MAT_CONTRL_MAT_BP			(1 << 2)

#define TBG_CNTRL_0_SYNC_MASK			(1 << 7)
#define TBG_CNTRL_0_SYNC_MTHD			(1 << 6)
#define TBG_CNTRL_0_FRAME_DIS			(1 << 5)

#define TBG_CNTRL_1_VH_TGL_MASK			(0x07U)
#define TBG_CNTRL_1_VH_TGL_0			(1 << 0)
#define TBG_CNTRL_1_VH_TGL_1			(1 << 1)
#define TBG_CNTRL_1_VH_TGL_2			(1 << 2)
#define TBG_CNTRL_1_VHX_EXT_MASK		(0x38U)
#define TBG_CNTRL_1_VHX_EXT_DE			(1 << 3)
#define TBG_CNTRL_1_VHX_EXT_HS			(1 << 4)
#define TBG_CNTRL_1_VHX_EXT_VS			(1 << 5)
#define TBG_CNTRL_1_DWIN_DIS			(1 << 6)

#define I2C_TIMER_RI_MASK			(0x0FU)
#define I2C_TIMER_PJ_MASK			(0xF0U)

#define HVF_CNTRL_0_INTPOL_MASK			(0x03U)
#define HVF_CNTRL_0_PREFIL_MASK			(0x0CU)
enum hvf_cntrl_0_prefil {
	PREFIL_OFF = 0,
	PREFIL_121 = 0x04,
	PREFIL_109 = 0x08,
	PREFIL_CCIR601 = 0x0C
};

#define HVF_CNTRL_0_RWB				(1 << 6)
#define HVF_CNTRL_0_SM				(1 << 7)

#define HVF_CNTRL_1_FOR				(1 << 0)
#define HVF_CNTRL_1_YUVBLK			(1 << 1)
enum hvf_cntrl_1_yuvblk {
	YUVBLK_16 = 0,
	YUVBLK_0 = HVF_CNTRL_1_YUVBLK,
};

#define HVF_CNTRL_1_VQR_MASK			(0x0CU)
enum hvf_cntrl_1_vqr {
	QRANGE_FS = 0,				/**< Full Scale */
	QRANGE_RGB_YUV = 0x04,			/**< RGB Or YUV */
	QRANGE_YUV = 0x08,			/**< YUV */
};

#define HVF_CNTRL_1_PAD_MASK			(0x30U)
enum hvf_cntrl_1_pad {
	DATAPATH_BITS_12 = 0,			/**< 12 bits */
	DATAPATH_BITS_8 = 0x40,			/**< 8 bits  */
	DATAPATH_BITS_10 = 0x80,		/**< 10 bits */
};

#define HVF_CNTRL_1_SEMI_PLANAR			(1 << 6)

#define TIMER_H_TIM_H_MASK			(0x03U)
#define TIMER_H_WD_CLKSEL			(1 << 6)

#define DEBUG_PROBE_WOO_EN			(1 << 0)
#define DEBUG_PROBE_DI_DE			(1 << 1)
#define DEBUG_PROBE_VID_DE			(1 << 2)
#define DEBUG_PROBE_BYPASS			(1 << 3)
#define DEBUG_PROBE_SEL_MASK			(0x30U)

#define I2S_FORMAT_I2S_FORMAT_MASK		(0x0FU)
#define I2S_FORMAT_I2S_DATA_SIZE_MASK		(0x0CU)

#define AIP_CLKSEL_DST_RATE       		(1 << 6)
// AIP_CLKSEL_SEL_AIP_SHIFT	(3)
#define AIP_CLKSEL_SEL_AIP_MASK			(0x38U)
#define AIP_CLKSEL_SEL_POL_CLK			(1 << 2)
#define AIP_CLKSEL_SEL_FS_MASK			(0x03U)

#define SC_VIDFORMAT_LUT_SEL_MASK		(0xC0U)
#define SC_VIDFORMAT_VID_FORMAT_O_MASK		(0x38U)
#define SC_VIDFORMAT_VID_FORMAT_I_MASK		(0x0FU)

#define SC_CNTRL_PHASES_H			(1 << 4)
#define SC_CNTRL_IL_OUT_ON			(1 << 3)
#define SC_CNTRL_PHASES_V			(1 << 2)
#define SC_CNTRL_VS_ON				(1 << 1)
#define SC_CNTRL_DEIL_ON			(1 << 0)

// VIDFORMAT_VIDFORMAT				(0x07U)

#define TBG_CNTRL_0_SYNC_MASK			(1 << 7)
enum tbg_cntrl_0_sync {
	SYNC_EACH_FRAME = 0,
	SYNC_ONCE = TBG_CNTRL_0_SYNC_MASK
};

#define TBG_CNTRL_0_SYNC_MTHD			(1 << 6)
#define TBG_CNTRL_0_FRAME_DIS			(1 << 5)
#define TBG_CNTRL_0_TOP_EXT			(1 << 3)
#define TBG_CNTRL_0_DE_EXT			(1 << 2)
#define TBG_CNTRL_0_TOP_SEL			(1 << 1)
#define TBG_CNTRL_0_TOP_TGL			(1 << 0)

#define PLL_SERIAL_1_SRL_FDN			(1 << 0)
#define PLL_SERIAL_1_SRL_IZ_MASK		(0x06U)
#define PLL_SERIAL_1_SRL_MAN_IZ			(1 << 6)

#define PLL_SERIAL_2_SRL_NOSC_MASK		(0x03U)
#define PLL_SERIAL_2_SRL_PR_MASK		(0xF0U)

#define PLL_SERIAL_3_SRL_CCIR			(1 << 0)
#define PLL_SERIAL_3_SRL_DE			(1 << 1)
#define PLL_SERIAL_3_SRL_PXIN_SEL		(1 << 4)

#define SERIALIZER_SRL_PHASE2_MASK		(0x0FU)
#define SERIALIZER_SRL_PHASE3_MASK		(0xF0U)

#define BUFFER_OUT_SRL_CLK_MASK			(0x03U)
#define BUFFER_OUT_SRL_FORCE_MASK		(0x0CU)
enum buffer_out_srl_force {
	TMDSOUT_NORMAL = 0x00,
	TMDSOUT_NORMAL1 = 0x04,
	TMDSOUT_FORCED0 = 0x08,
	TMDSOUT_FORCED1 = 0x0C
};

#define PLL_SCG1_SCG_FDN			(1 << 0)

#define PLL_SCG2_SCG_NOSC_MASK			(0x03U)
#define PLL_SCG2_SELPLLCLKIN			(1 << 4)
#define PLL_SCG2_BYPASS_SCG			(1 << 7)

#define VAI_PLL_PLLSRL_LOCK			(1 << 0)
#define VAI_PLL_PLLSCG_LOCK			(1 << 1)
#define VAI_PLL_PLLSRL_HVP			(1 << 4)
#define VAI_PLL_PLLSCG_HVP			(1 << 5)
#define VAI_PLL_PLLDE_HVP			(1 << 6)

#define AUDIO_DIV_AUDIO_DIV_MASK		(0x07U)

#define AIP_CNTRL_0_RST_FIFO			(1 << 0)
#define AIP_CNTRL_0_SWAP			(1 << 1)
#define AIP_CNTRL_0_LAYOUT			(1 << 2)
#define AIP_CNTRL_0_ACR_MAN			(1 << 5)
#define AIP_CNTRL_0_RST_CTS			(1 << 6)

#define TEST1_TST_ENAHVP			(1 << 0)
#define TEST1_TST_NOSC				(1 << 1)
#define TEST1_SRLDAT_MASK			(0xC0U)

#define TEST2_DIVTESTOE				(1 << 0)
#define TEST2_PWD1V8				(1 << 1)

#define SEL_CLK_SEL_CLK1			(1 << 0)
#define SEL_CLK_SEL_VRF_CLK_MASK		(0x06U)
#define SEL_CLK_ENA_SC_CLK			(1 << 3)


#define BUFF_OUT2_FORCE_DAT0_MASK		(0x03U)
#define BUFF_OUT2_FORCE_DAT1_MASK		(0x0CU)
#define BUFF_OUT2_FORCE_DAT2_MASK		(0x30U)

#define EDID_CTRL_EDID_RD			(1 << 0)

#define CA_I2S_CA_I2S_MASK			(0x1FU)
#define CA_I2S_HBR_CHSTAT_4			(1 << 5)

#define GC_AVMUTE_SETCLR_MUTE			(0x0CU)
#define GC_AVMUTE_CLR_MUTE			(1 << 0)
#define GC_AVMUTE_SET_MUTE			(1 << 1)

#define CTS_N_M_SEL_MASK			(0x30U)
#define CTS_N_K_SEL_MASK			(0x07U)

#define ENC_CNTRL_RST_ENC			(1 << 0)
#define ENC_CNTRL_RST_SEL			(1 << 1)
#define ENC_CNTRL_CTL_CODE_MASK			(0x0CU)

#define DIP_FLAGS_ACR				(1 << 0)
#define DIP_FLAGS_GC				(1 << 1)
#define DIP_FLAGS_ISRC1				(1 << 2)
#define DIP_FLAGS_ISRC2				(1 << 3)
#define DIP_FLAGS_ACP				(1 << 4)
#define DIP_FLAGS_NULL				(1 << 6)
#define DIP_FLAGS_FORCE_NULL			(1 << 7)

#define DIP_IF_FLAGS_IF1			(1 << 1)
#define DIP_IF_FLAGS_IF2			(1 << 2)
#define DIP_IF_FLAGS_IF3			(1 << 3)
#define DIP_IF_FLAGS_IF4			(1 << 4)
#define DIP_IF_FLAGS_IF5			(1 << 5)

#define OTP_TX0_SR_HDCP				(1 << 0)
#define DDC_SPEED_FACTOR			(39)
#define OTP_TX33_HDMI				(1 << 1)

#define GMD_CONTROL_ENABLE			(1 << 0)
#define GMD_CONTROL_BUF_SEL			(1 << 1)

/**
 * @brief	HDMI Core Registers
 */
enum tda998x_hdmi_reg {
	VERSION			= PAGE_ADDR(PAGE_00, 0x00),	/**< Device version */
	MAIN_CNTRL0		= PAGE_ADDR(PAGE_00, 0x01),	/**< Main control */
	VERSION_MSB		= PAGE_ADDR(PAGE_00, 0x02),
	PACKAGE_TYPE		= PAGE_ADDR(PAGE_00, 0x03),
	SR_REG			= PAGE_ADDR(PAGE_00, 0x0A),
	DDC_DISABLE		= PAGE_ADDR(PAGE_00, 0x0B),
	CCLK_ON			= PAGE_ADDR(PAGE_00, 0x0C),
	I2C_MASTER		= PAGE_ADDR(PAGE_00, 0x0D),
#ifdef TMFL_HDCP_OPTIMIZED_POWER
	FEAT_POWER_DOWN		= PAGE_ADDR(PAGE_00, 0x0E),
#endif
	INT_FLAGS_0		= PAGE_ADDR(PAGE_00, 0x0F),
	INT_FLAGS_1		= PAGE_ADDR(PAGE_00, 0x10),
	INT_FLAGS_2		= PAGE_ADDR(PAGE_00, 0x11),
	INT_FLAGS_3		= PAGE_ADDR(PAGE_00, 0x12),
	SW_INT			= PAGE_ADDR(PAGE_00, 0x15),
	ENA_ACLK		= PAGE_ADDR(PAGE_00, 0x16),
	ENA_VP_0		= PAGE_ADDR(PAGE_00, 0x18),
	ENA_VP_1		= PAGE_ADDR(PAGE_00, 0x19),
	ENA_VP_2		= PAGE_ADDR(PAGE_00, 0x1A),
	ENA_AP			= PAGE_ADDR(PAGE_00, 0x1E),
	VIP_CNTRL_0		= PAGE_ADDR(PAGE_00, 0x20),
	VIP_CNTRL_1		= PAGE_ADDR(PAGE_00, 0x21),
	VIP_CNTRL_2		= PAGE_ADDR(PAGE_00, 0x22),
	VIP_CNTRL_3		= PAGE_ADDR(PAGE_00, 0x23),
	VIP_CNTRL_4		= PAGE_ADDR(PAGE_00, 0x24),
	VIP_CNTRL_5		= PAGE_ADDR(PAGE_00, 0x25),
	MUX_AP			= PAGE_ADDR(PAGE_00, 0x26),
	MUX_VP_VIP_OUT		= PAGE_ADDR(PAGE_00, 0x27),
	MAT_CONTRL		= PAGE_ADDR(PAGE_00, 0x80),
	MAT_OI1_MSB		= PAGE_ADDR(PAGE_00, 0x81),
	MAT_P11_MSB		= PAGE_ADDR(PAGE_00, 0x87),
	MAT_OO1_MSB		= PAGE_ADDR(PAGE_00, 0x99),
	VIDFORMAT		= PAGE_ADDR(PAGE_00, 0xA0),
	REFPIX_MSB		= PAGE_ADDR(PAGE_00, 0xA1),
	REFPIX_LSB		= PAGE_ADDR(PAGE_00, 0xA2),
	REFLINE_MSB		= PAGE_ADDR(PAGE_00, 0xA3),
	REFLINE_LSB		= PAGE_ADDR(PAGE_00, 0xA4),
	NPIX_MSB		= PAGE_ADDR(PAGE_00, 0xA5),
	NPIX_LSB		= PAGE_ADDR(PAGE_00, 0xA6),
	NLINE_MSB		= PAGE_ADDR(PAGE_00, 0xA7),
	NLINE_LSB		= PAGE_ADDR(PAGE_00, 0xA8),
	VS_LINE_STRT_1_MSB	= PAGE_ADDR(PAGE_00, 0xA9),
	VS_LINE_STRT_1_LSB	= PAGE_ADDR(PAGE_00, 0xAA),
	VS_PIX_STRT_1_MSB	= PAGE_ADDR(PAGE_00, 0xAB),
	VS_PIX_STRT_1_LSB	= PAGE_ADDR(PAGE_00, 0xAC),
	VS_LINE_END_1_MSB	= PAGE_ADDR(PAGE_00, 0xAD),
	VS_LINE_END_1_LSB	= PAGE_ADDR(PAGE_00, 0xAE),
	VS_PIX_END_1_MSB	= PAGE_ADDR(PAGE_00, 0xAF),
	VS_PIX_END_1_LSB	= PAGE_ADDR(PAGE_00, 0xB0),
	VS_LINE_STRT_2_MSB	= PAGE_ADDR(PAGE_00, 0xB1),
	VS_LINE_STRT_2_LSB	= PAGE_ADDR(PAGE_00, 0xB2),
	VS_PIX_STRT_2_MSB	= PAGE_ADDR(PAGE_00, 0xB3),
	VS_PIX_STRT_2_LSB	= PAGE_ADDR(PAGE_00, 0xB4),
	VS_LINE_END_2_MSB	= PAGE_ADDR(PAGE_00, 0xB5),
	VS_LINE_END_2_LSB	= PAGE_ADDR(PAGE_00, 0xB6),
	VS_PIX_END_2_MSB	= PAGE_ADDR(PAGE_00, 0xB7),
	VS_PIX_END_2_LSB	= PAGE_ADDR(PAGE_00, 0xB8),
	HS_PIX_START_MSB	= PAGE_ADDR(PAGE_00, 0xB9),
	HS_PIX_START_LSB	= PAGE_ADDR(PAGE_00, 0xBA),
	HS_PIX_STOP_MSB		= PAGE_ADDR(PAGE_00, 0xBB),
	HS_PIX_STOP_LSB		= PAGE_ADDR(PAGE_00, 0xBC),
	VWIN_START_1_MSB	= PAGE_ADDR(PAGE_00, 0xBD),
	VWIN_START_1_LSB	= PAGE_ADDR(PAGE_00, 0xBE),
	VWIN_END_1_MSB		= PAGE_ADDR(PAGE_00, 0xBF),
	VWIN_END_1_LSB		= PAGE_ADDR(PAGE_00, 0xC0),
	VWIN_START_2_MSB	= PAGE_ADDR(PAGE_00, 0xC1),
	VWIN_START_2_LSB	= PAGE_ADDR(PAGE_00, 0xC2),
	VWIN_END_2_MSB		= PAGE_ADDR(PAGE_00, 0xC3),
	VWIN_END_2_LSB		= PAGE_ADDR(PAGE_00, 0xC4),
	DE_START_MSB		= PAGE_ADDR(PAGE_00, 0xC5),
	DE_START_LSB		= PAGE_ADDR(PAGE_00, 0xC6),
	DE_STOP_MSB		= PAGE_ADDR(PAGE_00, 0xC7),
	DE_STOP_LSB		= PAGE_ADDR(PAGE_00, 0xC8),
	COLBAR_WIDTH		= PAGE_ADDR(PAGE_00, 0xC9),
	TBG_CNTRL_0		= PAGE_ADDR(PAGE_00, 0xCA),
	TBG_CNTRL_1		= PAGE_ADDR(PAGE_00, 0xCB),
	VBL_OFFSET_START	= PAGE_ADDR(PAGE_00, 0xCC),
	VBL_OFFSET_END		= PAGE_ADDR(PAGE_00, 0xCD),
	HBL_OFFSET_START	= PAGE_ADDR(PAGE_00, 0xCE),
	HBL_OFFSET_END		= PAGE_ADDR(PAGE_00, 0xCF),
	DWIN_RE_DE		= PAGE_ADDR(PAGE_00, 0xD0),
	DWIN_FE_DE		= PAGE_ADDR(PAGE_00, 0xD1),
#ifdef TMFL_RGB_DDR_12BITS
	VSPACE_START_MSB	= PAGE_ADDR(PAGE_00, 0xD2),
	VSPACE_START_LSB	= PAGE_ADDR(PAGE_00, 0xD3),
	VSPACE_END_MSB		= PAGE_ADDR(PAGE_00, 0xD4),
	VSPACE_END_LSB		= PAGE_ADDR(PAGE_00, 0xD5),
	ENABLE_SPACE		= PAGE_ADDR(PAGE_00, 0xD6),
	VSPACE_Y_DATA		= PAGE_ADDR(PAGE_00, 0xD7),
	VSPACE_U_DATA		= PAGE_ADDR(PAGE_00, 0xD8),
	VSPACE_V_DATA		= PAGE_ADDR(PAGE_00, 0xD9),
#endif
	TIMER_RI_PJ		= PAGE_ADDR(PAGE_00, 0xE1),
	BCAPS_POLL		= PAGE_ADDR(PAGE_00, 0xE2),
	REG_100us		= PAGE_ADDR(PAGE_00, 0xE3),
	HVF_CNTRL_0		= PAGE_ADDR(PAGE_00, 0xE4),
	HVF_CNTRL_1		= PAGE_ADDR(PAGE_00, 0xE5),
	TIMER_H			= PAGE_ADDR(PAGE_00, 0xE8),
	TIMER_M			= PAGE_ADDR(PAGE_00, 0xE9),
	TIMER_L			= PAGE_ADDR(PAGE_00, 0xEA),
	TIMER_2SEC		= PAGE_ADDR(PAGE_00, 0xEB),
	TIMER_5SEC		= PAGE_ADDR(PAGE_00, 0xEC),
	NDIV_IM			= PAGE_ADDR(PAGE_00, 0xEE),
	NDIV_PF			= PAGE_ADDR(PAGE_00, 0xEF),
	RPT_CNTRL		= PAGE_ADDR(PAGE_00, 0xF0),
	LEAD_OFF		= PAGE_ADDR(PAGE_00, 0xF1),
	TRAIL_OFF		= PAGE_ADDR(PAGE_00, 0xF2),
	MISR_EXP_0		= PAGE_ADDR(PAGE_00, 0xF3),
	MISR_EXP_1		= PAGE_ADDR(PAGE_00, 0xF4),
	MISR_EXP_2		= PAGE_ADDR(PAGE_00, 0xF5),
	MISR_0			= PAGE_ADDR(PAGE_00, 0xF6),
	MISR_1			= PAGE_ADDR(PAGE_00, 0xF7),
	DEBUG_PROBE		= PAGE_ADDR(PAGE_00, 0xF8),
	GHOST_XADDR		= PAGE_ADDR(PAGE_00, 0xF9),
	MISR_2			= PAGE_ADDR(PAGE_00, 0xFA),
	I2S_FORMAT		= PAGE_ADDR(PAGE_00, 0xFC),
	AIP_CLKSEL		= PAGE_ADDR(PAGE_00, 0xFD),
	GHOST_ADDR		= PAGE_ADDR(PAGE_00, 0xFE),
	SC_VIDFORMAT		= PAGE_ADDR(PAGE_01, 0x00),
	SC_CNTRL		= PAGE_ADDR(PAGE_01, 0x01),
	SC_DELTA_PHASE_V	= PAGE_ADDR(PAGE_01, 0x02),
	SC_DELTA_PHASE_H	= PAGE_ADDR(PAGE_01, 0x03),
	SC_START_PHASE_H	= PAGE_ADDR(PAGE_01, 0x04),
	SC_NPIX_IN_LSB		= PAGE_ADDR(PAGE_01, 0x05),
	SC_NPIX_IN_MSB		= PAGE_ADDR(PAGE_01, 0x06),
	SC_NPIX_OUT_LSB		= PAGE_ADDR(PAGE_01, 0x07),
	SC_NPIX_OUT_MSB		= PAGE_ADDR(PAGE_01, 0x08),
	SC_NLINE_IN_LSB		= PAGE_ADDR(PAGE_01, 0x09),
	SC_NLINE_IN_MSB		= PAGE_ADDR(PAGE_01, 0x0A),
	SC_NLINE_OUT_LSB	= PAGE_ADDR(PAGE_01, 0x0B),
	SC_NLINE_OUT_MSB	= PAGE_ADDR(PAGE_01, 0x0C),
	SC_NLINE_SKIP		= PAGE_ADDR(PAGE_01, 0x0D),
	SC_SAMPLE_BUFFIL	= PAGE_ADDR(PAGE_01, 0x0E),
	SC_MAX_BUFFILL_P_0	= PAGE_ADDR(PAGE_01, 0x0F),
	SC_MAX_BUFFILL_P_1	= PAGE_ADDR(PAGE_01, 0x10),
	SC_MAX_BUFFILL_D_0	= PAGE_ADDR(PAGE_01, 0x11),
	SC_MAX_BUFFILL_D_1	= PAGE_ADDR(PAGE_01, 0x12),
	SC_SAMPLE_FIFOFILL	= PAGE_ADDR(PAGE_01, 0x13),
	SC_MAX_FIFOFILL_PI	= PAGE_ADDR(PAGE_01, 0x14),
	SC_MIN_FIFOFILL_PO1	= PAGE_ADDR(PAGE_01, 0x15),
	SC_MIN_FIFOFILL_PO2	= PAGE_ADDR(PAGE_01, 0x16),
	SC_MIN_FIFOFILL_PO3	= PAGE_ADDR(PAGE_01, 0x17),
	SC_MIN_FIFOFILL_PO4	= PAGE_ADDR(PAGE_01, 0x18),
	SC_MAX_FIFOFILL_DI	= PAGE_ADDR(PAGE_01, 0x19),
	SC_MAX_FIFOFILL_DO	= PAGE_ADDR(PAGE_01, 0x1A),
	SC_VS_LUT_0		= PAGE_ADDR(PAGE_01, 0x1B),
	SC_LAT_SCO		= PAGE_ADDR(PAGE_01, 0x48),
	VIDFORMAT_W		= PAGE_ADDR(PAGE_01, 0xA0),
	REFPIX_MSB_W		= PAGE_ADDR(PAGE_01, 0xA1),
	REFPIX_LSB_W		= PAGE_ADDR(PAGE_01, 0xA2),
	REFLINE_MSB_W		= PAGE_ADDR(PAGE_01, 0xA3),
	REFLINE_LSB_W		= PAGE_ADDR(PAGE_01, 0xA4),
	NPIX_MSB_W		= PAGE_ADDR(PAGE_01, 0xA5),
	NPIX_LSB_W		= PAGE_ADDR(PAGE_01, 0xA6),
	NLINE_MSB_W		= PAGE_ADDR(PAGE_01, 0xA7),
	NLINE_LSB_W		= PAGE_ADDR(PAGE_01, 0xA8),
	VWIN_START_1_MSB_W	= PAGE_ADDR(PAGE_01, 0xBD),
	VWIN_START_1_LSB_W	= PAGE_ADDR(PAGE_01, 0xBE),
	VWIN_END_1_MSB_W	= PAGE_ADDR(PAGE_01, 0xBF),
	VWIN_END_1_LSB_W	= PAGE_ADDR(PAGE_01, 0xC0),
	VWIN_START_2_MSB_W	= PAGE_ADDR(PAGE_01, 0xC1),
	VWIN_START_2_LSB_W	= PAGE_ADDR(PAGE_01, 0xC2),
	VWIN_END_2_MSB_W	= PAGE_ADDR(PAGE_01, 0xC3),
	VWIN_END_2_LSB_W	= PAGE_ADDR(PAGE_01, 0xC4),
	DE_START_MSB_W		= PAGE_ADDR(PAGE_01, 0xC5),
	DE_START_LSB_W		= PAGE_ADDR(PAGE_01, 0xC6),
	DE_STOP_MSB_W		= PAGE_ADDR(PAGE_01, 0xC7),
	DE_STOP_LSB_W		= PAGE_ADDR(PAGE_01, 0xC8),
//	TBG_CNTRL_0		= PAGE_ADDR(PAGE_01, 0xCA),
	PLL_SERIAL_1		= PAGE_ADDR(PAGE_02, 0x00),
	PLL_SERIAL_2		= PAGE_ADDR(PAGE_02, 0x01),
	PLL_SERIAL_3		= PAGE_ADDR(PAGE_02, 0x02),
	SERIALIZER		= PAGE_ADDR(PAGE_02, 0x03),
	BUFFER_OUT		= PAGE_ADDR(PAGE_02, 0x04),
	PLL_SCG1		= PAGE_ADDR(PAGE_02, 0x05),
	PLL_SCG2		= PAGE_ADDR(PAGE_02, 0x06),
	PLL_SCGN1		= PAGE_ADDR(PAGE_02, 0x07),
	PLL_SCGN2		= PAGE_ADDR(PAGE_02, 0x08),
	PLL_SCGR1		= PAGE_ADDR(PAGE_02, 0x09),
	PLL_SCGR2		= PAGE_ADDR(PAGE_02, 0x0A),
	VAI_PLL_R		= PAGE_ADDR(PAGE_02, 0x0D),
	AUDIO_DIV		= PAGE_ADDR(PAGE_02, 0x0E),
	TEST1_RW		= PAGE_ADDR(PAGE_02, 0x0F),
	TEST2_RW		= PAGE_ADDR(PAGE_02, 0x10),
	SEL_CLK			= PAGE_ADDR(PAGE_02, 0x11),
	ANA_GENERAL		= PAGE_ADDR(PAGE_02, 0x12),
	BUFFER_OUT2_RW		= PAGE_ADDR(PAGE_02, 0x13),
	SRL_TSTPAT0_RW		= PAGE_ADDR(PAGE_02, 0x14),
	SRL_TSTPAT1_RW		= PAGE_ADDR(PAGE_02, 0x15),
	SRL_TSTPAT2_RW		= PAGE_ADDR(PAGE_02, 0x16),
	SRL_TSTPAT3_RW		= PAGE_ADDR(PAGE_02, 0x17),
	EDID_DATA_0_R		= PAGE_ADDR(PAGE_09, 0x00),
	EDID_CTRL_RW		= PAGE_ADDR(PAGE_09, 0xFA),
	DDC_ADDR_RW		= PAGE_ADDR(PAGE_09, 0xFB),
	DDC_OFFS_RW		= PAGE_ADDR(PAGE_09, 0xFC),
	DDC_SEGM_ADDR_RW	= PAGE_ADDR(PAGE_09, 0xFD),
	DDC_SEGM_RW		= PAGE_ADDR(PAGE_09, 0xFE),
	IF1_HB0_RW		= PAGE_ADDR(PAGE_10, 0x20),
	IF1_PB0_RW		= PAGE_ADDR(PAGE_10, 0x23),
	IF1_PB10_RW		= PAGE_ADDR(PAGE_10, 0x2D),
	IF2_HB0_RW		= PAGE_ADDR(PAGE_10, 0x40),
	IF2_PB0_RW		= PAGE_ADDR(PAGE_10, 0x43),
	IF3_HB0_RW		= PAGE_ADDR(PAGE_10, 0x60),
	IF3_PB0_RW		= PAGE_ADDR(PAGE_10, 0x63),
	IF4_HB0_RW		= PAGE_ADDR(PAGE_10, 0x80),
	IF4_PB0_RW		= PAGE_ADDR(PAGE_10, 0x83),
	IF5_HB0_RW		= PAGE_ADDR(PAGE_10, 0xA0),
	IF5_PB0			= PAGE_ADDR(PAGE_10, 0xA3),
	AIP_CNTRL_0		= PAGE_ADDR(PAGE_11, 0x00),
	CA_I2S			= PAGE_ADDR(PAGE_11, 0x01),
	CA_DSD			= PAGE_ADDR(PAGE_11, 0x02),
	OBA_PH			= PAGE_ADDR(PAGE_11, 0x03),
	LATENCY_RD		= PAGE_ADDR(PAGE_11, 0x04),
	ACR_CTS_0		= PAGE_ADDR(PAGE_11, 0x05),
	ACR_CTS_1		= PAGE_ADDR(PAGE_11, 0x06),
	ACR_CTS_2		= PAGE_ADDR(PAGE_11, 0x07),
	ACR_N_0			= PAGE_ADDR(PAGE_11, 0x08),
	ACR_N_1			= PAGE_ADDR(PAGE_11, 0x09),
	ACR_N_2			= PAGE_ADDR(PAGE_11, 0x0A),
	GC_AVMUTE		= PAGE_ADDR(PAGE_11, 0x0B),
	CTS_N_RW		= PAGE_ADDR(PAGE_11, 0x0C),
	ENC_CNTRL		= PAGE_ADDR(PAGE_11, 0x0D),
	DIP_FLAGS		= PAGE_ADDR(PAGE_11, 0x0E),
	DIP_IF_FLAGS		= PAGE_ADDR(PAGE_11, 0x0F),
	CH_STAT_B_0		= PAGE_ADDR(PAGE_11, 0x14),
	CH_STAT_B_1		= PAGE_ADDR(PAGE_11, 0x15),
	CH_STAT_B_3		= PAGE_ADDR(PAGE_11, 0x16),
	CH_STAT_B_4		= PAGE_ADDR(PAGE_11, 0x17),
	CH_STAT_B_2_ap0_l_RW	= PAGE_ADDR(PAGE_11, 0x18),
	CH_STAT_B_2_ap0_r_RW	= PAGE_ADDR(PAGE_11, 0x19),
	CH_STAT_B_2_ap1_l_RW	= PAGE_ADDR(PAGE_11, 0x1A),
	CH_STAT_B_2_ap1_r_RW	= PAGE_ADDR(PAGE_11, 0x1B),
	CH_STAT_B_2_ap2_l_RW	= PAGE_ADDR(PAGE_11, 0x1C),
	CH_STAT_B_2_ap2_r_RW	= PAGE_ADDR(PAGE_11, 0x1D),
	CH_STAT_B_2_ap3_l_RW	= PAGE_ADDR(PAGE_11, 0x1E),
	CH_STAT_B_2_ap3_r_RW	= PAGE_ADDR(PAGE_11, 0x1F),
	ISRC1_HB0_RW		= PAGE_ADDR(PAGE_11, 0x20),
	ISRC1_PB0_RW		= PAGE_ADDR(PAGE_11, 0x23),
	ISRC2_HB0_RW		= PAGE_ADDR(PAGE_11, 0x40),
	ISRC2_PB0_RW		= PAGE_ADDR(PAGE_11, 0x43),
	ACP_HB0_RW		= PAGE_ADDR(PAGE_11, 0x60),
	ACP_PB0_RW		= PAGE_ADDR(PAGE_11, 0x63),
	OTP_TX0			= PAGE_ADDR(PAGE_12, 0x97),
	OTP_TX1			= PAGE_ADDR(PAGE_12, 0x98),
	OTP_TX2			= PAGE_ADDR(PAGE_12, 0x99),
	OTP_TX3			= PAGE_ADDR(PAGE_12, 0x9A),
	OTP_TX33		= PAGE_ADDR(PAGE_12, 0xB8),
	GMD_0_HB0_RW		= PAGE_ADDR(PAGE_13, 0x00),
	GMD_0_PB0_RW		= PAGE_ADDR(PAGE_13, 0x03),
	GMD_CONTROL_RW		= PAGE_ADDR(PAGE_13, 0x1F),
	GMD_1_HB0_RW		= PAGE_ADDR(PAGE_13, 0x20),
	GMD_1_PB0_RW		= PAGE_ADDR(PAGE_13, 0x23),
	INVALID_REG		= PAGE_ADDR(PAGE_INVALID, 0xFF),
	CURPAGE			= PAGE_ADDR(PAGE_INVALID, 0xFF),
};

/**
 * @brief	Supported feature enumeration
 */
enum feat_support {
	FEAT_HDCP = 0,			/**< HDCP */
	FEAT_SCALER = 1,  		/**< Scaler */
	FEAT_AUDIO_OBA = 2, 		/**< One bit audio */
	FEAT_AUDIO_DST = 3,  		/**< DST audio */
	FEAT_AUDIO_HBR = 4,  		/**< HBR audio */
	FEAT_HDMI_1_1 = 5,  		/**< HDMI 1.1 */
	FEAT_HDMI_1_2A = 6, 		/**< HDMI 1.2a */
	FEAT_HDMI_1_3A = 7,  		/**< HDMI 1.3a */
	FEAT_DEEP_COLOR_30 = 8,  	/**< 30 bits deep color */
	FEAT_DEEP_COLOR_36 = 9,  	/**< 36 bits deep color */
	FEAT_DEEP_COLOR_48 = 11, 	/**< 48 bits deep color */
	FEAT_UPSAMPLER = 12, 		/**< Up sampler */
	FEAT_DOWNSAMPLER = 13, 		/**< Down sampler */
	FEAT_COLOR_CONVERSION = 14	/**< Color conversion matrix */
};

/**
 * @brief	Frame Sync
 */
enum vs_fsync {
	VS_FSYNC_EACH_FRAME = 0,	/**< Sync on each frame */
	VS_FSYNC_ONCE = 1,		/**< Sync once only     */
};

enum vs_src {
	VS_SRC_INTERNAL = 0,		/**< Internal */
	VS_SRC_EXTERNAL = 1,		/**< External */
};

enum vs_tgl {
	VS_TGL_TABLE = 0,		/**< VS/HS polarity from table */
	VS_TGL_UNUSED_1 = 1,		/**< Unused */
	VS_TGL_UNUSED_2 = 2,		/**< Unused */
	VS_TGL_UNUSED_3 = 3,		/**< Unused */
	VS_TGL_NO_ACTION = 4,		/**< No toggle */
	VS_TGL_HS = 5,			/**< Toggle Hs */
	VS_TGL_VS = 6,			/**< Toggle Vs */
	VS_TGL_HS_VS = 7		/**< Toggle Hs & Vs */
};

//struct sync_desc {
//   UInt16 Vs2;
//   uint8_t pix_rep;
//   uint8_t v_toggle;
//   uint8_t h_toggle;
//   UInt16 hfp;    /* Output values for Vs/Hs input sync */
//   UInt16 vfp;
//   UInt16 href; /* Output values for all other input sync sources */
//   UInt16 vref;
//};


struct reg_mask_val {
	enum tda998x_hdmi_reg	reg;
	uint8_t			val;
};

static const enum vip_cntrl_swap port_map_rgb444[] = {
	VIP_CNTRL_VP23_20,
	VIP_CNTRL_VP19_16,
	VIP_CNTRL_VP15_12,
	VIP_CNTRL_VP11_8,
	VIP_CNTRL_VP7_4,
	VIP_CNTRL_VP3_0
};

static const enum vip_cntrl_mirr mirr_map_rgb444[] = {
	VIP_CNTRL_NOT_MIRRORED,
	VIP_CNTRL_NOT_MIRRORED,
	VIP_CNTRL_NOT_MIRRORED,
	VIP_CNTRL_NOT_MIRRORED,
	VIP_CNTRL_NOT_MIRRORED,
	VIP_CNTRL_NOT_MIRRORED
};

/**
 * @addtogroup TDA998X_PLL_Configuration
 * @{
 */
struct reg_mask_val pll_cfg_common[] = {
	{ PLL_SERIAL_1,	0x00},
	{ PLL_SERIAL_2,	0x01},
	{ PLL_SERIAL_3,	0x00},
	{ SERIALIZER,	0x00},
	{ BUFFER_OUT,	0x00},
	{ PLL_SCG1,	0x00},
	{ AUDIO_DIV,	0x03},
	{ SEL_CLK,	0x09},
	{ INVALID_REG,	0x00 }
};

struct reg_mask_val pll_cfg_other[] = {
	{ PLL_SCGN1,	0xFA},
	{ PLL_SCGN2,	0x00},
	{ PLL_SCGR1,	0x5B},
	{ PLL_SCGR2,	0x00},
	{ INVALID_REG,	0x00 }
};

struct reg_mask_val pll_cfg_480ix576i[] = {
	{ PLL_SCGN1,	0x14 },
	{ PLL_SCGN2,	0x00 },
	{ PLL_SCGR1,	0x0A },
	{ PLL_SCGR2,	0x00 },
	{ INVALID_REG,	0x00 }
};
/**
 * @}
 */

/**
 * @defgroup TDA998x_Func TDA998x Device Control Functions
 * @{
 */

/**
 * @defgroup TDA998x_Func_I2C
 * @{
 */

/**
 * @brief	Write Data
 *
 * @param	dev:	TDA998X device structure pointer
 * @param	reg:	Start register and page address
 * @param	len:	Length of data to write to device
 * @param	data:	Pointer to data to write from
 * @return	Number of bytes written or less-than-zero error status
 */
static int
tda998x_write(struct tda998x_dev *dev,
		enum tda998x_hdmi_reg reg,
		uint8_t len,
		uint8_t *data)
{
	int i, err;
	struct tda998x_cfg *cfg = dev->cfg;
	uint8_t page = PAGE_OF(reg);

	if (dev->cfg->cur_page != page) {
		/* Change the page */
		err = cfg->i2c_write(cfg->hdmi_addr, (uint8_t)CURPAGE, &page);
		if (err < 0)
			return err;

		dev->cfg->cur_page = page;
	}

	for (i = 0; i < len; i++, data++) {
		err = cfg->i2c_write(cfg->hdmi_addr, (uint8_t)reg + i, data);
		if (err < 0)
			return err;
	}

	return i;
}

/**
 * @brief	Write Register
 *
 * @param	dev:	TDA998X device structure pointer
 * @param	reg:	Register and page address
 * @param	data:	Data value to write to register
 * @return	Number of bytes written or less-than-zero error status
 */
static int
write_reg(struct tda998x_dev *dev, enum tda998x_hdmi_reg reg, uint8_t data)
{
	uint8_t tmp = data;

	return tda998x_write(dev, reg, 1, &tmp);
}

/**
 * @brief	Read Data
 *
 * @param	dev:	TDA998X device structure pointer
 * @param	reg:	Start register and page address
 * @param	len:	Length of data to read from device
 * @param	data:	Pointer to data to read to
 * @return	Number of bytes read or less-than-zero error status
 */
static int
tda998x_read(struct tda998x_dev *dev,
		enum tda998x_hdmi_reg reg,
		uint8_t len,
		uint8_t *data)
{
	int i, err;
	struct tda998x_cfg *cfg = dev->cfg;
	uint8_t page = PAGE_OF(reg);

	if (dev->cfg->cur_page != page) {
		/* Change the page */
		err = cfg->i2c_write(cfg->hdmi_addr, (uint8_t)CURPAGE, &page);
		if (err < 0)
			return err;

		dev->cfg->cur_page = page;
	}

	for (i = 0; i < len; i++, data++) {
		err = cfg->i2c_read(cfg->hdmi_addr, (uint8_t)reg + i, data);
		if (err < 0)
			return err;
	}

	return i;
}

/**
 * @brief	Read Register
 *
 * @param	dev:	TDA998X device structure pointer
 * @param	reg:	Register and page address
 * @param	data:	Pointer to data to read to
 * @return	Number of bytes read or less-than-zero error status
 */
static int
read_reg(struct tda998x_dev *dev, enum tda998x_hdmi_reg reg, uint8_t *data)
{
	return tda998x_read(dev, reg, 1, data);
}

/**
 * @brief	Register Mask Write
 *		Write a value with mask bits to a register
 *
 * @param	dev:	TDA998X device structure pointer
 * @param	reg:	Register and page address
 * @param	mask:	Mask of bits to be transformed
 * @param	val:	Bitfield to be written within mask
 * @return	Number of bytes written or less-than-zero error status
 */
static int
write_reg_mask(struct tda998x_dev *dev,
		enum tda998x_hdmi_reg reg,
		uint8_t mask,
		uint8_t val)
{
	int err;
	uint8_t reg_val;

	err = read_reg(dev, reg, &reg_val);
	if (err < 0)
		return err;

	reg_val &= ~(mask);			/* clear bits in the mask */
	reg_val |= val & mask;			/* set masked value bits */

	return write_reg(dev, reg, reg_val);
}

/**
 * @brief	Register Mask Write from Table
 * 		Write a value with mask specified in table until terminator
 *
 * @param	dev:	TDA998X device structure pointer
 * @param	tab:	Table of register, mask, value parameters
 * @return	Number of items processed or less-than-zero error status
 */
static int
write_reg_table(struct tda998x_dev *dev, struct reg_mask_val *tab)
{
	int err, cnt = 0;
	struct reg_mask_val *item = tab;

	while (item && item->reg != INVALID_REG) {
		err = write_reg(dev, item->reg, item->val);
		if (err < 0)
			return err;

		item++;
		cnt++;
	}

	return cnt;
}

/**
 * @brief	CEC Write Data
 *
 * @param	dev:	TDA998X device structure pointer
 * @param	reg:	Start register and page address
 * @param	len:	Length of data to write to device
 * @param	data:	Pointer to data to write from
 * @return	Number of bytes written or less-than-zero error status
 */
static int
tda998x_cec_write(struct tda998x_dev *dev,
		enum tda998x_cec_reg reg,
		uint8_t len,
		uint8_t *data)
{
	int i, err;
	struct tda998x_cfg *cfg = dev->cfg;

	for (i = 0; i < len; i++, data++) {
		err = cfg->i2c_write(cfg->cec_addr, (uint8_t)reg + i, data);
		if (err < 0)
			return err;
	}

	return i;
}

/**
 * @brief	CEC Write Register
 *
 * @param	dev:	TDA998X device structure pointer
 * @param	reg:	Register and page address
 * @param	data:	Data value to write to register
 * @return	Number of bytes written or less-than-zero error status
 */
static int
cec_write_reg(struct tda998x_dev *dev, enum tda998x_cec_reg reg, uint8_t data)
{
	uint8_t tmp = data;

	return tda998x_cec_write(dev, reg, 1, &tmp);
}

/**
 * @brief	CEC Read Data
 *
 * @param	dev:	TDA998X device structure pointer
 * @param	reg:	Start register and page address
 * @param	len:	Length of data to read from device
 * @param	data:	Pointer to data to read to
 * @return	Number of bytes read or less-than-zero error status
 */
static int
tda998x_cec_read(struct tda998x_dev *dev,
		enum tda998x_cec_reg reg,
		uint8_t len,
		uint8_t *data)
{
	int i, err;
	struct tda998x_cfg *cfg = dev->cfg;

	for (i = 0; i < len; i++, data++) {
		err = cfg->i2c_read(cfg->cec_addr, (uint8_t)reg + i, data);
		if (err < 0)
			return err;
	}

	return i;
}

/**
 * @brief	CEC Read Register
 *
 * @param	dev:	TDA998X device structure pointer
 * @param	reg:	Register and page address
 * @param	data:	Pointer to data to read to
 * @return	Number of bytes read or less-than-zero error status
 */
static int
cec_read_reg(struct tda998x_dev *dev, enum tda998x_cec_reg reg, uint8_t *data)
{
	return tda998x_cec_read(dev, reg, 1, data);
}

/**
 * @brief	CEC Register Mask Write
 *		Write a specified value with specified mask bits to a register
 *
 * @param	dev:	TDA99X device structure pointer
 * @param	reg:	Register and page address
 * @param	mask:	Mask of bits to be transformed
 * @param	val:	Bitfield to be written within mask
 * @return	Number of bytes written or less-than-zero error status
 */
static int
cec_write_reg_mask(struct tda998x_dev *dev,
		enum tda998x_cec_reg reg,
		uint8_t mask,
		uint8_t val)
{
	int err;
	uint8_t reg_val;

	err = cec_read_reg(dev, reg, &reg_val);
	if (err < 0)
		return err;

	reg_val &= ~(mask);
	reg_val |= val & mask;

	return cec_write_reg(dev, reg, reg_val);
}
/**
 * @}
 */

/**
 * @defgroup TDA998x_Func_VidPort Video Port Configuration Functions
 * @{
 *
 * Internal port | RGB 4:4:4 | YCbCr 4:4:4 | YCbCr 4:2:2 Semi-planar | YCbCr 4:2:2 ITU656
 * ------------- | --------- | ----------- | ----------------------- | ------------------
 * VP[23]        | G[7]      | Y[7]        | Y[11]                   | YCbCr[11]
 * VP[22]        | G[6]      | Y[6]        | Y[10]                   | YCbCr[10]
 * VP[21]        | G[5]      | Y[5]        | Y[9]                    | YCbCr[9]
 * VP[20]        | G[4]      | Y[4]        | Y[8]                    | YCbCr[8]
 * VP[19]        | G[3]      | Y[3]        | Y[7]                    | YCbCr[7]
 * VP[18]        | G[2]      | Y[2]        | Y[6]                    | YCbCr[6]
 * VP[17]        | G[1]      | Y[1]        | Y[5]                    | YCbCr[5]
 * VP[16]        | G[0]      | Y[0]        | Y[4]                    | YCbCr[4]
 * VP[15]        | B[7]      | Cb[7]       | Y[3]                    | YCbCr[3]
 * VP[14]        | B[6]      | Cb[6]       | Y[2]                    | YCbCr[2]
 * VP[13]        | B[5]      | Cb[5]       | Y[1]                    | YCbCr[1]
 * VP[12]        | B[4]      | Cb[4]       | Y[0]                    | YCbCr[0]
 * VP[11]        | B[3]      | Cb[3]       | CbCr[11]
 * VP[10]        | B[2]      | Cb[2]       | CbCr[10]
 * VP[9]         | B[1]      | Cb[1]       | CbCr[9]
 * VP[8]         | B[0]      | Cb[0]       | CbCr[8]
 * VP[7]         | R[7]      | Cr[7]       | CbCr[7]
 * VP[6]         | R[6]      | Cr[6]       | CbCr[6]
 * VP[5]         | R[5]      | Cr[5]       | CbCr[5]
 * VP[4]         | R[4]      | Cr[4]       | CbCr[4]
 * VP[3]         | R[3]      | Cr[3]       | CbCr[3]
 * VP[2]         | R[2]      | Cr[2]       | CbCr[2]
 * VP[1]         | R[1]      | Cr[1]       | CbCr[1]
 * VP[0]         | R[0]      | Cr[0]       | CbCr[0]
 */

/**
 * @brief	Set Video Port Enable
 *
 * @param	dev:	Pointer to TDA998x device structure
 * @return 0 on success, error status otherwise
 */
static int
tda998x_set_vidport_enable(struct tda998x_dev *dev)
{
	int err;

	err = write_reg(dev, ENA_VP_0, 0xFF);
	if (err < 0)
		return err;

	err = write_reg(dev, ENA_VP_1, 0xFF);
	if (err < 0)
		return err;

	err = write_reg(dev, ENA_VP_2, 0xFF);
	if (err < 0)
		return err;

	return err;
}

/**
 * @brief	Set Video Port Mapping
 *
 * @param	dev:	Pointer to TDA998x device data structure
 * @param	swap:	Pointer to swap table representing video port pin map to
 * 			internal video port from [23:20] => [3:0]
 * @param	mirr:	Pointer to pin mirror table representing video port pins
 * 			[23:20] => [3:0]
 * @return 0 on success, error status otherwise
 */
static int
tda998x_set_vidport_map(struct tda998x_dev *dev,
		enum vip_cntrl_swap *swap,
		enum vip_cntrl_mirr *mirr)
{
	int i, err;
	uint8_t reg_val;

	/* Check parameters */
	for (i = 0; i < 3; i++) {
		reg_val = swap[2 * i] << VIP_CNTRL_SWAP_H_SHIFT;
		reg_val |= swap[(2 * i) + 1] << VIP_CNTRL_SWAP_L_SHIFT;
		reg_val |= mirr[2 * i] == VIP_CNTRL_MIRRORED ? VIP_CNTRL_MIRR_H : 0;
		reg_val |= mirr[(2 * i) + 1] == VIP_CNTRL_MIRRORED ? VIP_CNTRL_MIRR_L : 0;

		err = write_reg_mask(dev,
				VIP_CNTRL_0 + i,
				VIP_CNTRL_SWAP_MASK,
				reg_val);
	}

	return err;
}
/**
 * @}
 */

/**
 * @brief	Disable HDMI HDCP
 * 		Set HDMI HDCP mode off for DVI
 */
static int
tda998x_disable_hdcp(struct tda998x_dev *dev)
{
	int err;

	err = write_reg_mask(dev,
			TBG_CNTRL_1,
			TBG_CNTRL_1_DWIN_DIS, TBG_CNTRL_1_DWIN_DIS);
	if (err < 0)
		return err;

	err = write_reg_mask(dev,
			OTP_TX33,
			OTP_TX33_HDMI, 0);
	if (err < 0)
		return err;


	err = write_reg_mask(dev,
			ENC_CNTRL,
			ENC_CNTRL_CTL_CODE_MASK,
			0);
	if (err < 0)
		return err;

	return 0;
}

/**
 * @brief	Enable HDMI HDCP
 * 		Set HDMI HDCP mode on for HDMI
 *
 * @param	dev:	Pointer to TDA998x device structure
 * @return 0 on success, error status otherwise
 */
static int
tda998x_enable_hdcp(struct tda998x_dev *dev)
{
	int err;

	err = write_reg_mask(dev,
			TBG_CNTRL_1,
			TBG_CNTRL_1_DWIN_DIS,
			0);
	if (err < 0)
		return err;

	err = write_reg_mask(dev,
			ENC_CNTRL,
			ENC_CNTRL_CTL_CODE_MASK,
			ENC_CNTRL_CTL_CODE_MASK);
	if (err < 0)
		return err;

	err = write_reg_mask(dev,
			OTP_TX33,
			OTP_TX33_HDMI,
			OTP_TX33_HDMI);
	if (err < 0)
		return err;

	return 0;
}

/**
 * @brief	Set Video Input Fine Control
 *
 * @param	dev:	Pointer to TDA998x device structure
 * @return 0 on success, error status otherwise
 */
int
tda998x_set_vidin_fine(struct tda998x_dev *dev,
		uint8_t subpack_cnt,
		int toggle_clk)
{
	int err;

	err = write_reg_mask(dev,
			VIP_CNTRL_5,
			VIP_CNTRL_5_SP_CNT_MASK,
			subpack_cnt << VIP_CNTRL_5_SP_CNT_SHIFT);

	err = write_reg_mask(dev,
			VIP_CNTRL_3,
			VIP_CNTRL_3_SP_SYNC_MASK,
			(uint8_t)PIXSUBPKT_FIX_3);

	if (subpack_cnt <= 3) {
		err = write_reg_mask(dev,
                                 VIP_CNTRL_5,
                                 VIP_CNTRL_5_SP_CNT_MASK,
                                 subpack_cnt << VIP_CNTRL_5_SP_CNT_SHIFT);
		if (err < 0)
			return err;

		err = write_reg_mask(dev,
                                 VIP_CNTRL_3,
                                 VIP_CNTRL_3_SP_SYNC_MASK,
                                 PIXSUBPKT_FIX_3);
		if (err < 0)
			return err;
	} else {

		err = write_reg_mask(dev,
                                 VIP_CNTRL_5,
                                 VIP_CNTRL_5_SP_CNT_MASK,
                                 0);
        	if (err < 0)
        		return err;

        	err = write_reg_mask(dev,
                                 VIP_CNTRL_3,
                                 VIP_CNTRL_3_SP_SYNC_MASK,
                                 (uint8_t) (subpack_cnt - 4));
        	if (err < 0)
        		return err;
	}

	err = write_reg_mask(dev,
			 VIP_CNTRL_5,
			 VIP_CNTRL_5_CKCASE,
			 (uint8_t)toggle_clk);
	if (err < 0)
		return err;

	return 0;
}

/**
 * @brief	Set Video In Blanking
 *
 * @param	dev:	Pointer to TDA998x device structure
 * @return 0 on success, error status otherwise
 */
static int
tda998x_set_vidin_blanking(struct tda998x_dev *dev,
		enum vip_cntrl_4_blnkit blnk_src,
		enum vip_cntrl_4_blc blnk_code)
{
	if (dev == NULL)
		return -1;

	return write_reg_mask(dev,
			VIP_CNTRL_4,
			VIP_CNTRL_4_BLNKIT_MASK | VIP_CNTRL_4_BLC_MASK,
			(uint8_t) blnk_src | (uint8_t) blnk_code);
}

/**
 * @brief	Set TMDS Outputs
 *
 * @param	dev:	Pointer to TDA998x device structure
 * @param	tmds:	TMDS output value specified by
 *			@ref enum buffer_out_srl_force
 *			@arg TMDSOUT_NORMAL
 *			@arg TMDSOUT_NORMAL1
 *			@arg TMDSOUT_FORCED0
 *			@arg TMDSOUT_FORCED1
 * @return 0 on success, error status otherwise
 */
static int
tda998x_set_tmds_outputs(struct tda998x_dev *dev, enum buffer_out_srl_force tmds)
{
	int err;
	if (dev == NULL)
		return -1;

	err = write_reg_mask(dev,
			BUFFER_OUT,
			BUFFER_OUT_SRL_FORCE_MASK,
			(uint8_t) tmds);
	if (err < 0)
		return err;

	return 0;
}

/**
 * @brief	Set Video Output Synchronization
 *
 * @param	dev:	Pointer to TDA998x device structure
 * @param	hs_src:	Horizontal synchronization (HSYNC) configuration as
 * 			specified by @ref enum vs_src
 * 			@arg VS_SRC_INTERNAL
 * 			@arg VS_SRC_EXTERNAL
 * @param	vs_src:	Vertical synchronization (VSYNC) configuration
 * @param	de_src:	Data enable (DE) configuration
 * @param	toggle:	Toggle configuration
 * @param	fsync:	Frame synchronization configuration
 * @return 0 on success, error status otherwise
 */
int
tda998x_set_vidout_sync(struct tda998x_dev *dev,
		enum vs_src hs_src,
		enum vs_src vs_src,
		enum vs_src de_src,
		enum vs_tgl toggle,
		enum vs_fsync fsync)
{
	int err;
	uint8_t mask, reg_val;

	/*
	 * build register value
	 */
	mask = TBG_CNTRL_1_VH_TGL_MASK | TBG_CNTRL_1_VHX_EXT_MASK;
	reg_val = (de_src << 3) | (hs_src << 4) | (vs_src << 5) | toggle;
	err = write_reg_mask(dev,
			TBG_CNTRL_1,
			mask,
			reg_val);
	if (err < 0)
		return err;

	/* Must be last register set */
	err = write_reg_mask(dev,
			TBG_CNTRL_0,
			TBG_CNTRL_0_SYNC_MASK,
			(uint8_t)(fsync << 7));
	if (err < 0)
		return err;

	/* Toggle TMDS serialiser force flags - stability fix */
	err = write_reg_mask(dev,
			BUFFER_OUT,
			BUFFER_OUT_SRL_FORCE_MASK,
			(uint8_t) TMDSOUT_FORCED0);
	if (err < 0)
		return err;

	err = write_reg_mask(dev,
			BUFFER_OUT,
			BUFFER_OUT_SRL_FORCE_MASK,
			(uint8_t) TMDSOUT_NORMAL);
	if (err < 0)
		return err;

	if (fsync == VS_FSYNC_ONCE) {
		/* Toggle output Sync Once flag for settings to take effect */
		err = write_reg_mask(dev,
				TBG_CNTRL_0,
				TBG_CNTRL_0_SYNC_MASK,
				TBG_CNTRL_0_SYNC_MASK);
		if (err < 0)
			return err;

		err = write_reg_mask(dev,
				TBG_CNTRL_0,
				TBG_CNTRL_0_SYNC_MASK,
				0);
		if (err < 0)
			return err;
	}

	return 0;
}

/**
 * @brief	Set Video Output Configuration
 */
int
tda998x_set_vidout_config(struct tda998x_dev *dev,
		enum tda998x_sink sink,
		enum tda998x_vidout_mode vout_mode,
		enum hvf_cntrl_0_prefil prefil,
		enum hvf_cntrl_1_yuvblk yuv_blk,
		enum tda998x_vqr quant)
{
	int err;

	if (dev->sink == SINK_DVI) {
		/* Mute the audio FIFO */
		err = write_reg_mask(dev,
				AIP_CNTRL_0,
				AIP_CNTRL_0_RST_FIFO,
				AIP_CNTRL_0_RST_FIFO);
		if (err < 0)
			return err;

		/* Force RGB mode for DVI sink */
		vout_mode = VOUTMODE_RGB444;

		/* Set HDMI HDCP mode off for DVI */
		err = tda998x_disable_hdcp(dev);
		if (err < 0)
			return err;
	} else {
		/* Unmute the audio FIFO */
		err = write_reg_mask(dev,
				AIP_CNTRL_0,
				AIP_CNTRL_0_RST_FIFO,
				0);
		if (err < 0)
			return err;

		/* Set HDMI HDCP mode on for HDMI */
		err = tda998x_enable_hdcp(dev);
		if (err < 0)
			return err;
	}

	err = write_reg_mask(dev,
			HVF_CNTRL_0,
			HVF_CNTRL_0_PREFIL_MASK,
			(uint8_t) prefil);
	if (err < 0)
		return err;

	err = write_reg_mask(dev,
			HVF_CNTRL_1,
			HVF_CNTRL_1_YUVBLK,
			(uint8_t) yuv_blk);
	if (err < 0)
		return err;

	return 0;
}


int
tda998x_get_edid_sink(struct tda998x_dev *dev, enum tda998x_sink *sink)
{
	if (dev->edid_state == EDID_READ) {
		*sink = dev->edid_sink;
	} else {
		/* Not allowed if EdidStatus value is not valid */
		return -1;
	}

	return 0;
}


int
tda998x_set_input_output(struct tda998x_dev *dev,
	struct tda998x_vidin_cfg *vin_cfg,
	struct tda998x_vidout_cfg *vout_cfg,
	struct tda998x_audin_cfg *ain_cfg,
	enum tda998x_sink sink)
{
	int err;
	uint8_t pix_repeat;			/* Pixel repetition */
//	tmbslHdmiTxVoutDbits_t path_bits;	/* Data path bit width */
//	enum vip_cntrl_3_edge pix_edge;		/* Pixel sampling edge */
//	tmbslHdmiTxVsMeth_t syncMethod;		/* Sync method */
	enum tda998x_pix_tgl toggle;		/* Toggling */
//	uint8_t syncIn;				/* Embedded or external */
	enum tda998x_pix_subpkt subpkt;		/* Subpacket sync */
	enum vip_cntrl_4_blnkit blankit;	/* Blanking */
//	enum tda998x_pix_rate pix_rate;		/* PIXRATE_SINGLE */

	err = tda998x_set_tmds_outputs(dev, TMDSOUT_FORCED0);

	/* Set video output configuration */
	err = tda998x_set_vidout_config(dev,
			sink,
			vout_cfg->mode,
			PREFIL_OFF,
			YUVBLK_16,
			QRANGE_FS);

	/* Enable video ports */
	err = write_reg(dev, ENA_VP_0, 0xFF);
	if (err < 0)
		return err;

	err = write_reg(dev, ENA_VP_1, 0xFF);
	if (err < 0)
		return err;

	err = write_reg(dev, ENA_VP_2, 0xFF);
	if (err < 0)
		return err;

	/* Set video port mapping */
	err = tda998x_set_vidport_map(dev, port_map_rgb444, mirr_map_rgb444);
	if (err < 0)
		return err;

	/* Set default config */
//	pix_repeat = PIXREP_DEFAULT;
//	path_bits = VOUT_DBITS_12;
//	pix_edge = PIXEDGE_CLK_POS;
//	syncMethod = VSMETH_V_H;
//	toggle = PIXTOGL_ENABLE;

	/* External sync */
//	syncIn = 0;				/* External sync */
//	subpkt = HDMITX_PIXSUBPKT_SYNC_DE;	/* DE is available */
//	blankit = BLNKSRC_NOT_DE;

//	typedef enum
//	{
//	    HDMITX_PIXSUBPKT_FIX_0      = 0,        /**< Fix At 0 */
//	    HDMITX_PIXSUBPKT_FIX_1      = 1,        /**< Fix At 1 */
//	    HDMITX_PIXSUBPKT_FIX_2      = 2,        /**< Fix At 2 */
//	    HDMITX_PIXSUBPKT_FIX_3      = 3,        /**< Fix At 3 */
//	    HDMITX_PIXSUBPKT_SYNC_FIRST = 4,        /**< First Sync value */
//	    HDMITX_PIXSUBPKT_SYNC_HEMB  = 4,        /**< Sync By Hemb */
//	    HDMITX_PIXSUBPKT_SYNC_DE    = 5,        /**< Sync By Rising Edge DE */
//	    HDMITX_PIXSUBPKT_SYNC_HS    = 6,        /**< Sync By Rising Edge HS */
//	    HDMITX_PIXSUBPKT_NO_CHANGE  = 7,        /**< No Change */
//	    HDMITX_PIXSUBPKT_INVALID    = 8,        /**< Invalid   */
//	    HDMITX_PIXSUBPKT_SYNC_FIXED = 3         /**< Not used as a parameter value,
//	                                             *  but used internally when
//	                                             *  Fix at 0/1/2/3 values are set */
//	} tmbslHdmiTxPixSubpkt_t;

	/* Set fine image position */
	err = tda998x_set_vidin_fine(dev, subpkt, 0);
	if (err < 0)
		return err;

	/* Set input blanking */
	blankit = 0;
	err = tda998x_set_vidin_blanking(dev, blankit, BLNKCODE_ALL_0);
	if (err < 0)
		return err;

	/* Configure video input options and control the upsampler */
//	err = tda998x_set_vidin_config(dev,
//			vin_cfg->mode,
//			vout_cfg->format,
//			vin_cfg->format_3d,
//			pix_edge,
//			vin_cfg->pix_rate,
//			UPSAMPLE_AUTO);
/**
 * BEGIN: Set video input configuration
 */
	err = write_reg_mask(dev,
			VIP_CNTRL_3,
			VIP_CNTRL_3_EDGE,
			(uint8_t) PIXEDGE_POS);
	if (err < 0)
		return err;

	err = write_reg_mask(dev,
			VIP_CNTRL_4,
			VIP_CNTRL_4_CCIR656,
			0);
	if (err < 0)
		return err;

	err = write_reg_mask(dev,
			HVF_CNTRL_1,
			HVF_CNTRL_1_SEMI_PLANAR,
			0);
	if (err < 0)
		return err;

	err = write_reg_mask(dev,
			PLL_SERIAL_3,
			PLL_SERIAL_3_SRL_CCIR,
			0);
	if (err < 0)
		return err;

	err = write_reg_mask(dev,
			SEL_CLK,
			SEL_CLK_SEL_VRF_CLK_MASK,
			0);
	if (err < 0)
		return err;

	err = write_reg_mask(dev,
			VIP_CNTRL_4,
			VIP_CNTRL_4_656_ALT,
			0);
	if (err < 0)
		return err;

	err = write_reg_mask(dev,
			PLL_SERIAL_2,
			PLL_SERIAL_2_SRL_NOSC_MASK,
			(uint8_t) 1);

	/* set the pixel repetition */

	   /* Vs2    PR  Vtg Htg HFP VFP HREF VREF */
//	   {0,       0,  1,  1,  17,   2, 161, 36}, /* E_REGVFMT_640x480p_60Hz   */
//	   {0,       0,  1,  1,  17,   8, 139, 43}, /* E_REGVFMT_720x480p_60Hz   */
//	   {0,       0,  0,  0,  111,  2, 371, 26}, /* E_REGVFMT_1280x720p_60Hz  */

	err = write_reg_mask(dev,
			 PLL_SERIAL_2,
			 PLL_SERIAL_2_SRL_PR_MASK,
			 0);
	if (err < 0)
		return err;

	/* Set pixel repetition count for repetitor module */
	err = write_reg(dev, RPT_CNTRL, 0);

	err = write_reg_mask(dev,
			   PLL_SERIAL_1,
			   PLL_SERIAL_1_SRL_MAN_IZ,
			   0);
	if (err < 0)
		return err;

	err = write_reg_mask(dev,
			    PLL_SERIAL_3,
			    PLL_SERIAL_3_SRL_DE,
			    0);
	if (err < 0)
		return err;

	err = write_reg(dev, SERIALIZER, 0);
	if (err < 0)
		return err;

/**
 * END: Set video input configuration
 */
	/* Set up PLL for video format configuration */
	err = write_reg_mask(dev,
			VIP_CNTRL_4,
			VIP_CNTRL_4_CCIR656,
			0);
	if (err < 0)
		return err;

	err = write_reg_mask(dev,
			HVF_CNTRL_1,
			HVF_CNTRL_1_SEMI_PLANAR,
			0);
	if (err < 0)
		return err;

	err = write_reg_mask(dev,
			PLL_SERIAL_3,
			PLL_SERIAL_3_SRL_CCIR,
			0);
	if (err < 0)
		return err;

	err = write_reg_mask(dev,
			SEL_CLK,
			SEL_CLK_SEL_VRF_CLK_MASK,
			0);
	if (err < 0)
		return err;

	err = write_reg_mask(dev,
			VIP_CNTRL_4,
			VIP_CNTRL_4_656_ALT,
			0);
	if (err < 0)
		return err;

	err = write_reg_mask(dev,
			PLL_SERIAL_2,
			PLL_SERIAL_2_SRL_NOSC_MASK,
			1);


	err = write_reg_mask(dev,
			PLL_SERIAL_1,
			PLL_SERIAL_1_SRL_MAN_IZ,
			0);
	if (err < 0)
		return err;

	err = write_reg_mask(dev,
			PLL_SERIAL_3,
			PLL_SERIAL_3_SRL_DE,
			0);
	if (err < 0)
		return err;

	err = write_reg(dev, SERIALIZER, 0);
	if (err < 0)
		return err;
/**
 * BEGIN: SetInOut
 */
	err = write_reg_mask(dev,
			HVF_CNTRL_1,
			HVF_CNTRL_1_VQR_MASK,
			(uint8_t) QRANGE_RGB_YUV);
	if (err < 0)
		return err;

	err = write_reg_mask(dev,
			PLL_SERIAL_2,
			PLL_SERIAL_2_SRL_NOSC_MASK,
			0x01);

	/* Set pixel repetition */
	pix_repeat = 0;
	err = write_reg_mask(dev,
			PLL_SERIAL_2,
			PLL_SERIAL_2_SRL_PR_MASK,
			pix_repeat << 4);
	if (err < 0)
		return err;

	/* Set pixel repetition count for Repetitor module */
	err = write_reg(dev, RPT_CNTRL, pix_repeat);

	err = write_reg_mask(dev,
			PLL_SERIAL_1,
			PLL_SERIAL_1_SRL_MAN_IZ,
			0);
	if (err < 0)
		return err;

	err = write_reg_mask(dev,
			PLL_SERIAL_3,
			PLL_SERIAL_3_SRL_DE,
			0);
	if (err < 0)
		return err;

	err = write_reg(dev, SERIALIZER, 0);
	if (err < 0)
		return err;

	err = write_reg_mask(dev,
			SEL_CLK,
			SEL_CLK_SEL_VRF_CLK_MASK,
			0);
	if (err < 0)
		return err;

	err = write_reg(dev, VIDFORMAT, 0x00);
	err = write_reg(dev, VIDFORMAT, VIDFORMAT_VIDFORMAT_MASK);
	err = write_reg(dev, VIDFORMAT, VIDFORMAT_1280x720p_60Hz);
	if (err < 0)
		return err;

/**
 * BEGIN: setDeVs
 */
	err = write_reg(dev,
			VS_PIX_STRT_2_MSB,
			0);
	if (err < 0)
		return err;

	err = write_reg(dev,
			VS_PIX_STRT_2_LSB,
			0);
	if (err < 0)
		return err;

	err = write_reg(dev,
			VS_PIX_END_2_MSB,
			0);
	if (err < 0)
		return err;

	err = write_reg(dev,
			VS_PIX_END_2_LSB,
			0);
	if (err < 0)
		return err;
/**
 * END: setDeVs
 */

/**
 * BEGIN: Set matrix conversion
 */
	err = write_reg_mask(dev,
			MAT_CONTRL,
			MAT_CONTRL_MAT_BP,
			MAT_CONTRL_MAT_BP);
	if (err < 0)
		return err;
/**
 * END: Set matrix conversion
 */

/**
 * BEGIN: Set sampling
 */
	/* Set upsampler */
	err = write_reg_mask(dev,
			     HVF_CNTRL_0,
			     HVF_CNTRL_0_INTPOL_MASK,
			     0);
	if (err < 0)
		return err;

	/* Set downsampler */
	err = write_reg_mask(dev,
			     HVF_CNTRL_1,
			     HVF_CNTRL_1_FOR,
			     0);
	if (err < 0)
		return err;

/**
 * END: Set sampling
 */
	/* Set color component bit depth */
	err = write_reg_mask(dev,
			HVF_CNTRL_1,
			HVF_CNTRL_1_PAD_MASK,
			(uint8_t) DATAPATH_BITS_12);
	if (err < 0)
		return err;
/**
 * END: Set input and output
 */
	err = write_reg_mask(dev,
			HVF_CNTRL_1,
			HVF_CNTRL_1_VQR_MASK,
			(uint8_t) QRANGE_RGB_YUV);
	if (err < 0)
		return err;


/**
 * BEGIN: Set audio input
 */
	/* Only set audio for HDMI, not DVI */
//	if (sink == TMDL_HDMITX_SINK_HDMI)
//		err = tmdlHdmiTxSetAudioInput(instance, ain_cfg, sink);
/**
 * END: Set audio input
 */

/**
 * BEGIN: Set video in sync
 */
	err = write_reg_mask(dev,
			VIP_CNTRL_3,
			VIP_CNTRL_3_EMB,
			0);
	if (err < 0)
		return err;

	err = write_reg_mask(dev,
			TBG_CNTRL_0,
			TBG_CNTRL_0_SYNC_MTHD,
			0);
	if (err < 0)
		return err;

	err = write_reg_mask(dev,
			VIP_CNTRL_3,
			VIP_CNTRL_3_X_TGL | VIP_CNTRL_3_H_TGL | VIP_CNTRL_3_V_TGL,
			VIP_CNTRL_3_X_TGL | VIP_CNTRL_3_H_TGL | VIP_CNTRL_3_V_TGL);
	if (err < 0)
		return err;

	err = write_reg(dev, REFPIX_MSB, 0);
	if (err < 0)
		return err;

	err = write_reg(dev, REFPIX_LSB, 0);
	if (err < 0)
		return err;

	err = write_reg(dev, REFLINE_MSB, 0);
	if (err < 0)
		return err;

	err = write_reg(dev, REFLINE_LSB, 0);
	if (err < 0)
		return err;
/**
 * END: Set video in sync
 */

/**
 * BEGIN: Set video infoframe
 */

/**
 * END: Set video infoframe
 */

/**
 * BEGIN: Set video output sync
 */
	/* For each parameter that is not No Change, set its register */
	err = write_reg_mask(dev,
			TBG_CNTRL_1,
			TBG_CNTRL_1_VHX_EXT_MASK,
			0);
	if (err < 0)
		return err;

	err = write_reg_mask(dev,
			 TBG_CNTRL_1,
			 TBG_CNTRL_1_VH_TGL_MASK,
			 (uint8_t) toggle);
	if (err < 0)
		return err;

	/* Must be last register set */
	err = write_reg_mask(dev,
			TBG_CNTRL_0,
			TBG_CNTRL_0_SYNC_MASK,
			(uint8_t) SYNC_EACH_FRAME);
	if (err < 0)
		return err;

	/* Toggle TMDS serialiser force flags - stability fix */
	err = write_reg_mask(dev,
			BUFFER_OUT,
			BUFFER_OUT_SRL_FORCE_MASK,
			(uint8_t) TMDSOUT_FORCED0);
	if (err < 0)
		return err;

	err = write_reg_mask(dev,
			BUFFER_OUT,
			BUFFER_OUT_SRL_FORCE_MASK,
			(uint8_t) TMDSOUT_NORMAL);
	if (err < 0)
		return err;
/**
 * END: VideoOutSetSync
 */

	return 0;
}

/**
 * @todo Rework this input/output function
 */

/**
 * @brief	Initialize TDA998x HDMI Transmitter
 *
 * @param dev:		Pointer to device structure
 * @param vin_cfg:	Video Input configuration
 * @return 0 on success, error status otherwise
 */
int
tda998x_init(struct tda998x_dev *dev, struct tda998x_vidin_cfg *vin_cfg)
{
	int err;
	uint8_t reg_val;

	/* Reset ENAMODS */
	err = cec_write_reg(dev, ENAMODS, 0x40);
	if (err < 0)
		return err;

	/* Enable HDMI and RX sense and FRO */
	err = cec_write_reg_mask(dev,
			ENAMODS,
			ENAMODS_ENA_HDMI | ENAMODS_ENA_RXS | ENAMODS_DIS_FRO,
			ENAMODS_ENA_HDMI | ENAMODS_ENA_RXS);
	if (err < 0)
		return err;

	/**
	 * Reset device
	 */
	err = write_reg_mask(dev,
			SR_REG,
			SR_REG_SR_I2C_MS | SR_REG_SR_AUDIO,
			SR_REG_SR_I2C_MS | SR_REG_SR_AUDIO);
	if (err < 0)
		return err;

//	pDis->sysFuncTimer(50); /* ms */

	err = write_reg_mask(dev,
			SR_REG,
			SR_REG_SR_I2C_MS | SR_REG_SR_AUDIO,
			0);
	if (err < 0)
		return err;

	/* Soft reset */
	err = write_reg_mask(dev,
			MAIN_CNTRL0,
			MAIN_CNTRL0_SR,
			MAIN_CNTRL0_SR);
	if (err < 0)
		return err;

	/* pDis->sysFuncTimer(50); */ /* ms */

	err = write_reg_mask(dev,
			MAIN_CNTRL0,
			MAIN_CNTRL0_SR,
			0);
	if (err < 0)
		return err;

	/* pDis->sysFuncTimer(50); */ /* ms */

	/* Clear color bars */
	err = write_reg_mask(dev,
			HVF_CNTRL_0,
			HVF_CNTRL_0_SM,
			0);
	if (err < 0)
		return err;

	/*
	 * Read the device version registers
	 */
	err = read_reg(dev, VERSION, &reg_val);
	if (err < 0)
		return err;

	dev->version = reg_val;

	/* Version MSB value */
	err = read_reg(dev, VERSION_MSB, &reg_val);
	if (err < 0)
		return err;

	dev->version |= (uint16_t)reg_val << 8;

	err = write_reg(dev, ANA_GENERAL, 0x09U);	/** VSWING default value */
	if (err < 0)
		return err;

	/* Set the PLL before resetting the device */
	err = write_reg_table(dev, &pll_cfg_common[0]);
	if (err < 0)
		return err;

	err = write_reg_mask(dev,
			VIP_CNTRL_4,
			VIP_CNTRL_4_656_ALT,
			0);
	if (err < 0)
		return err;

	switch (vin_cfg->format) {
	case VFMT_06_720x480i_60Hz:
	case VFMT_07_720x480i_60Hz:
	case VFMT_21_720x576i_50Hz:
	case VFMT_22_720x576i_50Hz:
		err = write_reg_table(dev, &pll_cfg_480ix576i[0]);
		if (err < 0)
			return err;

		switch (vin_cfg->pix_rate) {
		case PIXRATE_SINGLE:
			/* Single edge mode, vinFmt 480i or 576i */
			err = write_reg(dev, PLL_SCG2, 0x11);
			if (err < 0)
				return err;
			break;

		case PIXRATE_SINGLE_REPEATED:
			/* Single repeated edge mode, vinFmt 480i or 576i */
			err = write_reg(dev, PLL_SCG2, 0x01);
			if (err < 0)
				return err;
			break;

		default:
			return -1;	/* Invalid pixel rate */
		}
		break;

	default:
		err = write_reg_table(dev, &pll_cfg_other[0]);
		if (err < 0)
			return err;

		switch (vin_cfg->pix_rate) {
		case PIXRATE_SINGLE:
			/* Single edge mode, (format other than 480i or 576i) */
			err = write_reg(dev, PLL_SCG2, 0x10);
			if (err < 0)
				return err;
			break;

		case PIXRATE_DOUBLE:
			/* Double edge mode (format other than 480i or 576i) */
			err = write_reg(dev, PLL_SCG2, 0x00);
			if (err < 0)
				return err;
			break;

		default:
			return -1;	/* Invalid pixel rate */
		}
		break;
	}

	/* DDC interface is disable for TDA9989 after reset, enable it */
	err = write_reg(dev, DDC_DISABLE, 0x00);
	if (err < 0)
		return err;

	/* Set DDC channel clock speed */
	err = write_reg(dev, OTP_TX3, DDC_SPEED_FACTOR);
	if (err < 0)
		return err;

	err = cec_write_reg(dev,
			FRO_IM_CLK_CTRL,
			FRO_IM_CLK_CTRL_IMCLK_SEL | FRO_IM_CLK_CTRL_GHOST_DIS);
	if (err < 0)
		return err;

	/* enable  sw _interrupt and  VS_interrupt for debug */
	err = write_reg(dev, INT_FLAGS_1, INT_FLAGS_1_SW_INT);
	if (err < 0)
		return err;

	/* enable edid read */
	err = write_reg(dev, INT_FLAGS_2, INT_FLAGS_2_EDID_BLK_RD);
	if (err < 0)
		return err;

	/* Read HPD RXS level */
	err = cec_read_reg(dev, RXSHPDLEV, &reg_val);
	if (err < 0)
		return err;

	err = cec_write_reg_mask(dev,
			RXSHPDINTENA,
			RXSHPDINTENA_ENA_RXS_INT | RXSHPDINTENA_ENA_HPD_INT,
			RXSHPDINTENA_ENA_RXS_INT | RXSHPDINTENA_ENA_HPD_INT);
	if (err < 0)
		return err;

	err = cec_read_reg(dev, RXSHPDLEV, &reg_val);
	if (err < 0)
		return err;

	/* Start by forcing the TMDS ouputs off */
	err = tda998x_set_tmds_outputs(dev, TMDSOUT_FORCED0);
	if (err < 0)
		return err;

	return (0);
}
/**
 * @}
 */

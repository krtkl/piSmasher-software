/**
 ******************************************************************************
 ******************************************************************************
 *
 * @file	gs2971.c
 * @author	Russell Bush
 * @email	bush@krtkl.com
 * @version	v1.0
 * @date    	Oct 4, 2017
 * @brief	GS2971 SDI Receiver
 * @license	FreeBSD
 *
 ******************************************************************************
 *
 * Copyright (c) 2017, krtkl inc.
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 * 1. Redistributions of source code must retain the above copyright notice,
 *    this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright notice,
 *    this list of conditions and the following disclaimer in the documentation
 *    and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
 * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
 * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
 * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
 * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
 * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
 * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
 * POSSIBILITY OF SUCH DAMAGE.
 *
 * The views and conclusions contained in the software and documentation are
 * those of the authors and should not be interpreted as representing official
 * policies, either expressed or implied, of the FreeBSD Project.
 *
 ******************************************************************************
 */

#include <stdio.h>
#include <stdlib.h>
#include <stdint.h>
#include <unistd.h>

#include "gs2971.h"

static int gs2971_read_reg(struct gs2971_dev *dev, enum gs2971_reg reg, uint16_t *data);
static int gs2971_write_reg(struct gs2971_dev *dev, enum gs2971_reg reg, uint16_t data);
static int gs2971_mask_write_reg(struct gs2971_dev *dev, enum gs2971_reg reg, uint16_t mask, uint16_t val);


/**
 * @brief	GS2971 SDI Receiver Initialization
 *
 * @param	dev:	GS2971 device structure pointer
 * @param	cfg:	Pointer to device configuration
 * @retval 0 on success, error status otherwise
 */
int gs2971_init(struct gs2971_dev *dev, struct gs2971_cfg *cfg)
{
	int err;

	if ((dev == NULL) || (cfg == NULL))
		return (-1);

	dev->cfg = cfg;

	err = gs2971_set_io_drive(dev, IO_DS_DOUT_LSB, IO_DS_DOUT_4mA);
	if (err < 0)
		return err;

	err = gs2971_set_io_drive(dev, IO_DS_DOUT_STAT, IO_DS_DOUT_4mA);
	if (err < 0)
		return err;

	err = gs2971_set_io_drive(dev, IO_DS_DOUT_MSB, IO_DS_DOUT_4mA);
	if (err < 0)
		return err;

	return (0);
}


/**
 * @brief	Set IO Drive Strength
 *
 * @param	dev:	GS2971 device structure pointer
 * @param	output:	Pin outputs to set drive strength
 * @param	drive:	Drive strength value to set
 * @retval 0 on success, error status otherwise
 */
int gs2971_set_io_drive(struct gs2971_dev *dev, enum gs29712_io_ds_out output, enum gs2971_io_ds drive)
{
	uint16_t mask, reg_val;

	/* Build the mask and register value from the drive strengths and output */
	mask = (IO_DS_MASK << output);
	reg_val = ((uint16_t)drive & IO_DS_MASK) << (uint8_t)output;

	return gs2971_mask_write_reg(dev, IO_DRIVE_STRENGTH, mask, reg_val);
}


static int gs2971_read_reg(struct gs2971_dev *dev, enum gs2971_reg reg, uint16_t *data)
{
	struct gs2971_cfg *cfg = dev->cfg;

	return cfg->spi_read(cfg->ss, (uint16_t)reg | GS2971_READ, data);
}


static int gs2971_write_reg(struct gs2971_dev *dev, enum gs2971_reg reg, uint16_t data)
{
	struct gs2971_cfg *cfg = dev->cfg;

	if ((uint16_t)reg & GS2971_READ_ONLY)
		return GS2971_INVALID_OP;

	return cfg->spi_write(cfg->ss, (uint16_t)reg, data);
}


static int gs2971_mask_write_reg(struct gs2971_dev *dev, enum gs2971_reg reg, uint16_t mask, uint16_t val)
{
	int err;
	uint16_t tmp;

	err = gs2971_read_reg(dev, reg, &tmp);
	if (err < 0) {
		printf("ERROR: Reading GS2971 register 0x%02x - %d\n", reg, err);
		return err;
	}

	tmp &= ~(mask);
	tmp |= (val & mask);

	return gs2971_write_reg(dev, reg, tmp);
}

/**
 *******************************************************************************
 *******************************************************************************
 *
 * @file	tda998x.c
 * @author	R. Bush
 * @email	bush@krtkl.com
 * @version	v1.0
 * @date	2017 November 10
 * @brief	TDA998x HDMI Transmitter
 * @license	FreeBSD
 *
 *******************************************************************************
 *
 * Copyright (c) 2017, krtkl inc.
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 * 1. Redistributions of source code must retain the above copyright notice,
 *	  this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright notice,
 *	  this list of conditions and the following disclaimer in the documentation
 *	  and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
 * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
 * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
 * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
 * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
 * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
 * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
 * POSSIBILITY OF SUCH DAMAGE.
 *
 * The views and conclusions contained in the software and documentation are
 * those of the authors and should not be interpreted as representing official
 * policies, either expressed or implied, of the FreeBSD Project.
 *
 *******************************************************************************
 */

#include <stdio.h>
#include <stdint.h>
#include <stdbool.h>
#include <unistd.h>

#include "tda998x.h"

/**
 * @defgroup	TDA998X NXP TDA998x HDMI Transmitter
 * @{
 */
#define PAGE_ADDR(__PAGE__, __ADDR__)		(((__PAGE__) << 8) | ((__ADDR__) & 0xFFU))
#define PAGE_OF(__REG__)			((uint8_t)(((__REG__) >> 8) & 0xFFU))

/**
 * @addtogroup	TDA998X_CEC_Core
 * @{
 */
#define INTERRUPTSTATUS_CEC			(1 << 0)
#define INTERRUPTSTATUS_HDMI			(1 << 1)

#define RXSHPDINTENA_ENA_RXS_INT		(1 << 0)
#define RXSHPDINTENA_ENA_HPD_INT		(1 << 1)

#define RXSHPDINT_RXS_INT			(1 << 0)
#define RXSHPDINT_HPD_INT			(1 << 1)

#define RXSHPDLEV_RXS_LEVEL			(1 << 0)
#define RXSHPDLEV_HPD_LEVEL			(1 << 1)

#define ENAMODS_ENA_CEC				(1 << 0)
#define ENAMODS_ENA_HDMI			(1 << 1)
#define ENAMODS_ENA_RXS				(1 << 2)
#define ENAMODS_DIS_CCLK			(1 << 5)
#define ENAMODS_DIS_FRO				(1 << 6)

#define FRO_IM_CLK_CTRL_FRO_DIV			(1 << 0)
#define FRO_IM_CLK_CTRL_IMCLK_SEL		(1 << 1)
#define FRO_IM_CLK_CTRL_ENA_OTP			(1 << 6)
#define FRO_IM_CLK_CTRL_GHOST_DIS		(1 << 7)

/**
 * @brief	CEC Core Registers
 */
enum tda998x_cec_reg {
	INTERRUPTSTATUS = 0xEE,
	RXSHPDINTENA = 0xFC,
	RXSHPDINT = 0xFD,
	RXSHPDLEV = 0xFE,
	ENAMODS = 0xFF,
	FRO_IM_CLK_CTRL = 0xFB,
};
/**
 * @}
 */

/**
 * @addtogroup	TDA998X_HDMI_Core
 * @{
 */

/**
 * @addtogroup	TDA998X_HDMI_Core_Registers
 * @{
 */

/**
 * @brief	HDMI Core Register Pages
 */
enum tda998x_hdmi_page {
	PAGE_00 = 0x00,
	PAGE_01 = 0x01,
	PAGE_02 = 0x02,
	PAGE_09 = 0x09,
	PAGE_10 = 0x10,
	PAGE_11 = 0x11,
	PAGE_12 = 0x12,
	PAGE_13 = 0x13,
	PAGE_INVALID = 0xFF
};

#define VERSION_NOT_SCALER			(1 << 4)
#define VERSION_NOT_HDCP			(1 << 5)

#define MAIN_CNTRL0_SR				(1 << 0)
#define MAIN_CNTRL0_DECS			(1 << 1)
#define MAIN_CNTRL0_DEHS			(1 << 2)
#define MAIN_CNTRL0_CECS			(1 << 3)
#define MAIN_CNTRL0_CEHS			(1 << 4)
#define MAIN_CNTRL0_SCALER			(1 << 7)

#define SR_REG_SR_AUDIO				(1 << 0)
#define SR_REG_SR_I2C_MS			(1 << 1)

#define DDC_DISABLE_DDC_DIS			(1 << 0)

#define CCLK_ON_CCLK_DDC_ON			(1 << 0)

#define I2C_MASTER_DIS_MM			(1 << 0)
#define I2C_MASTER_DIS_FILT			(1 << 1)
#define I2C_MASTER_APP_STRT_LAT			(1 << 2)

#define INT_FLAGS_0_ENCRYPT			(1 << 0)
#define INT_FLAGS_0_HPD				(1 << 1)
#define INT_FLAGS_0_T0				(1 << 2)
#define INT_FLAGS_0_BCAPS			(1 << 3)
#define INT_FLAGS_0_BSTATUS			(1 << 4)
#define INT_FLAGS_0_SHA_1			(1 << 5)
#define INT_FLAGS_0_PJ				(1 << 6)
#define INT_FLAGS_0_R0				(1 << 7)

#define INT_FLAGS_1_VS_RPT			(1 << 0)
#define INT_FLAGS_1_OTP				(1 << 1)
#define INT_FLAGS_1_SC_IN			(1 << 2)
#define INT_FLAGS_1_SC_OUT			(1 << 3)
#define INT_FLAGS_1_SC_VID			(1 << 4)
#define INT_FLAGS_1_SC_DEIL			(1 << 5)
#define INT_FLAGS_1_SW_INT			(1 << 6)
#define INT_FLAGS_1_HPD_IN			(1 << 7)

#define INT_FLAGS_2_RX_SENSE			(1 << 0)
#define INT_FLAGS_2_EDID_BLK_RD			(1 << 1)

#define INT_FLAGS_3_RXS_FIL			(1 << 0)

#define SW_INT_SW_INT				(1 << 0)

#define ENA_ACLK_ENA_ACLK			(1 << 0)
#define GND_ACLK_GND_ACLK			(1 << 0)

#define ENA_VP_0_ENA_VP0			(1 << 0)
#define ENA_VP_0_ENA_VP1			(1 << 1)
#define ENA_VP_0_ENA_VP2			(1 << 2)
#define ENA_VP_0_ENA_VP3			(1 << 3)
#define ENA_VP_0_ENA_VP4			(1 << 4)
#define ENA_VP_0_ENA_VP5			(1 << 5)
#define ENA_VP_0_ENA_VP6			(1 << 6)
#define ENA_VP_0_ENA_VP7			(1 << 7)

#define ENA_VP_1_ENA_VP8			(1 << 0)
#define ENA_VP_1_ENA_VP9			(1 << 1)
#define ENA_VP_1_ENA_VP10			(1 << 2)
#define ENA_VP_1_ENA_VP11			(1 << 3)
#define ENA_VP_1_ENA_VP12			(1 << 4)
#define ENA_VP_1_ENA_VP13			(1 << 5)
#define ENA_VP_1_ENA_VP14			(1 << 6)
#define ENA_VP_1_ENA_VP15			(1 << 7)

#define ENA_VP_2_ENA_VP16			(1 << 0)
#define ENA_VP_2_ENA_VP17			(1 << 1)
#define ENA_VP_2_ENA_VP18			(1 << 2)
#define ENA_VP_2_ENA_VP19			(1 << 3)
#define ENA_VP_2_ENA_VP20			(1 << 4)
#define ENA_VP_2_ENA_VP21			(1 << 5)
#define ENA_VP_2_ENA_VP22			(1 << 6)
#define ENA_VP_2_ENA_VP23			(1 << 7)

#define ENA_AP_ENA_AP0				(1 << 0)
#define ENA_AP_ENA_AP1				(1 << 1)
#define ENA_AP_ENA_AP2				(1 << 2)
#define ENA_AP_ENA_AP3				(1 << 3)
#define ENA_AP_ENA_AP4				(1 << 4)
#define ENA_AP_ENA_AP5				(1 << 5)
#define ENA_AP_ENA_AP6				(1 << 6)
#define ENA_AP_ENA_AP7				(1 << 7)

#define VIP_CNTRL_SWAP_L_SHIFT			(0)
#define VIP_CNTRL_MIRR_L			(1 << 3)
#define VIP_CNTRL_SWAP_H_SHIFT			(4)
#define VIP_CNTRL_MIRR_H			(1 << 7)

#define VIP_CNTRL_SWAP_MASK			(0x77U)
enum vip_cntrl_swap {
	VIP_CNTRL_VP23_20 = 0x00,
	VIP_CNTRL_VP19_16 = 0x01,
	VIP_CNTRL_VP15_12 = 0x02,
	VIP_CNTRL_VP11_8 = 0x03,
	VIP_CNTRL_VP7_4 = 0x04,
	VIP_CNTRL_VP3_0 = 0x05
};

enum vip_cntrl_mirr {
	VIP_CNTRL_NOT_MIRRORED = 0,		/**< No action */
	VIP_CNTRL_MIRRORED = 1			/**< Mirrored (i.e. In[a:b] -> Out[b:a]) */
};

#define VIP_CNTRL_3_X_TGL			(1 << 0)
#define VIP_CNTRL_3_H_TGL			(1 << 1)
#define VIP_CNTRL_3_V_TGL			(1 << 2)
#define VIP_CNTRL_3_EMB				(1 << 3)
#define VIP_CNTRL_3_SP_SYNC_MASK		(0x30U)
enum vip_cntrl_3_sp_sync {
	PIXSUBPKT_FIX_0 = 0,
    	PIXSUBPKT_FIX_1 = 0x10,
    	PIXSUBPKT_FIX_2 = 0x20,
    	PIXSUBPKT_FIX_3 = 0x30
};

#define VIP_CNTRL_3_DE_INT			(1 << 6)
#define VIP_CNTRL_3_EDGE			(1 << 7)

#define VIP_CNTRL_4_BLC_MASK			(0x03U)
enum vip_cntrl_4_blc {
	BLNKCODE_ALL_0 = 0x00,			/**< All Zero */
	BLNKCODE_RGB444 = 0x01,			/**< RGB444 */
	BLNKCODE_YUV444 = 0x02,			/**< YUV444 */
	BLNKCODE_YUV422 = 0x03			/**< YUV422 */
};

#define VIP_CNTRL_4_BLNKIT_MASK			(0x0CU)
enum vip_cntrl_4_blnkit {
	BLNKSRC_NOT_DE = 0x00,			/**< Not DE */
	BLNKSRC_VS_HS = 0x04,			/**< VS AND HS */
	BLNKSRC_VS_NOT_HS = 0x08,		/**< VS AND NOT HS */
	BLNKSRC_VS_HEMB_VEMB = 0x0C		/**< Hemb AND Vemb */
};

#define VIP_CNTRL_4_CCIR656			(1 << 4)
#define VIP_CNTRL_4_656_ALT			(1 << 5)
#define VIP_CNTRL_4_TST_656			(1 << 6)
#define VIP_CNTRL_4_TST_PAT			(1 << 7)

#ifdef TMFL_TDA19989
# define VIDFORMAT_3D_NEG_VS			(1 << 6)
# define VIDFORMAT_3D				(1 << 7)
#endif
#define VIDFORMAT_VIDFORMAT_MASK		(0x1FU)
enum tda998x_vidformat {
	VIDFORMAT_640x480p_60Hz = 0x00,
	VIDFORMAT_720x480p_60Hz = 0x01,
	VIDFORMAT_1280x720p_60Hz = 0x02,
	VIDFORMAT_1920x1080i_60Hz = 0x03,
	VIDFORMAT_720x480i_60Hz = 0x04,
	VIDFORMAT_720x240p_60Hz = 0x05,
	VIDFORMAT_1920x1080p_60Hz = 0x06,
	VIDFORMAT_720x576p_50Hz = 0x07,
	VIDFORMAT_1280x720p_50Hz = 0x08,
	VIDFORMAT_1920x1080i_50Hz = 0x09,
	VIDFORMAT_720x576i_50Hz = 0x0A,
	VIDFORMAT_720x288p_50Hz = 0x0B,
	VIDFORMAT_1920x1080p_50Hz = 0x0C
};

#define VIP_CNTRL_5_CKCASE			(1 << 0)
#define VIP_CNTRL_5_SP_CNT_MASK			(0x06U)
#define VIP_CNTRL_5_SP_CNT_SHIFT		(1)

#define MAT_CONTRL_MAT_SC			(0x03U)
#define MAT_CONTRL_MAT_BP			(1 << 2)

#define TBG_CNTRL_0_SYNC_ONCE			(1 << 7)
#define TBG_CNTRL_0_SYNC_MTHD			(1 << 6)
#define TBG_CNTRL_0_FRAME_DIS			(1 << 5)

#define TBG_CNTRL_1_VH_TGL_MASK			(0x07U)
#define TBG_CNTRL_1_VH_TGL_0			(1 << 0)
#define TBG_CNTRL_1_VH_TGL_1			(1 << 1)
#define TBG_CNTRL_1_VH_TGL_2			(1 << 2)
#define TBG_CNTRL_1_VHX_EXT_MASK		(0x38U)
#define TBG_CNTRL_1_VHX_EXT_DE			(1 << 3)
#define TBG_CNTRL_1_VHX_EXT_HS			(1 << 4)
#define TBG_CNTRL_1_VHX_EXT_VS			(1 << 5)
#define TBG_CNTRL_1_DWIN_DIS			(1 << 6)

#define I2C_TIMER_RI_MASK			(0x0FU)
#define I2C_TIMER_PJ_MASK			(0xF0U)

#define HVF_CNTRL_0_INTPOL_MASK			(0x03U)
#define HVF_CNTRL_0_PREFIL_MASK			(0x0CU)
enum hvf_cntrl_0_prefil {
	PREFIL_OFF = 0,
	PREFIL_121 = 0x04,
	PREFIL_109 = 0x08,
	PREFIL_CCIR601 = 0x0C
};

#define HVF_CNTRL_0_RWB				(1 << 6)
#define HVF_CNTRL_0_SM				(1 << 7)

#define HVF_CNTRL_1_FOR				(1 << 0)
#define HVF_CNTRL_1_YUVBLK			(1 << 1)
enum hvf_cntrl_1_yuvblk {
	YUVBLK_16 = 0,
	YUVBLK_0 = HVF_CNTRL_1_YUVBLK,
};

#define HVF_CNTRL_1_VQR_MASK			(0x0CU)
enum tvf_cntrl_1_vqr {
	QRANGE_FS = 0,			/**< Full Scale */
	QRANGE_RGB_YUV = 1,		/**< RGB Or YUV */
	QRANGE_YUV = 2,			/**< YUV */
	QRANGE_NO_CHANGE = 3,		/**< No Change */
    	QRANGE_INVALID = 4		/**< Invalid */
};

#define HVF_CNTRL_1_PAD_MASK			(0x30U)
#define HVF_CNTRL_1_SEMI_PLANAR			(1 << 6)

#define TIMER_H_TIM_H_MASK			(0x03U)
#define TIMER_H_WD_CLKSEL			(1 << 6)

#define DEBUG_PROBE_WOO_EN			(1 << 0)
#define DEBUG_PROBE_DI_DE			(1 << 1)
#define DEBUG_PROBE_VID_DE			(1 << 2)
#define DEBUG_PROBE_BYPASS			(1 << 3)
#define DEBUG_PROBE_SEL_MASK			(0x30U)

#define I2S_FORMAT_I2S_FORMAT_MASK		(0x0FU)
#define I2S_FORMAT_I2S_DATA_SIZE_MASK		(0x0CU)

#define AIP_CLKSEL_DST_RATE       		(1 << 6)
// AIP_CLKSEL_SEL_AIP_SHIFT	(3)
#define AIP_CLKSEL_SEL_AIP_MASK			(0x38U)
#define AIP_CLKSEL_SEL_POL_CLK			(1 << 2)
#define AIP_CLKSEL_SEL_FS_MASK			(0x03U)

#define SC_VIDFORMAT_LUT_SEL_MASK		(0xC0U)
#define SC_VIDFORMAT_VID_FORMAT_O_MASK		(0x38U)
#define SC_VIDFORMAT_VID_FORMAT_I_MASK		(0x0FU)

#define SC_CNTRL_PHASES_H			(1 << 4)
#define SC_CNTRL_IL_OUT_ON			(1 << 3)
#define SC_CNTRL_PHASES_V			(1 << 2)
#define SC_CNTRL_VS_ON				(1 << 1)
#define SC_CNTRL_DEIL_ON			(1 << 0)

// VIDFORMAT_VIDFORMAT				(0x07U)

#define TBG_CNTRL_0_SYNC_ONCE			(1 << 7)
#define TBG_CNTRL_0_SYNC_MTHD			(1 << 6)
#define TBG_CNTRL_0_FRAME_DIS			(1 << 5)
#define TBG_CNTRL_0_TOP_EXT			(1 << 3)
#define TBG_CNTRL_0_DE_EXT			(1 << 2)
#define TBG_CNTRL_0_TOP_SEL			(1 << 1)
#define TBG_CNTRL_0_TOP_TGL			(1 << 0)

#define PLL_SERIAL_1_SRL_FDN			(1 << 0)
#define PLL_SERIAL_1_SRL_IZ_MASK		(0x06U)
#define PLL_SERIAL_1_SRL_MAN_IZ			(1 << 6)

#define PLL_SERIAL_2_SRL_NOSC_MASK		(0x03U)
#define PLL_SERIAL_2_SRL_PR_MASK		(0xF0U)

#define PLL_SERIAL_3_SRL_CCIR			(1 << 0)
#define PLL_SERIAL_3_SRL_DE			(1 << 1)
#define PLL_SERIAL_3_SRL_PXIN_SEL		(1 << 4)

#define SERIALIZER_SRL_PHASE2_MASK		(0x0FU)
#define SERIALIZER_SRL_PHASE3_MASK		(0xF0U)

#define BUFFER_OUT_SRL_CLK_MASK			(0x03U)
#define BUFFER_OUT_SRL_FORCE_MASK		(0x0CU)
enum buffer_out_srl_force {
	TMDSOUT_NORMAL = 0x00,
	TMDSOUT_NORMAL1 = 0x04,
	TMDSOUT_FORCED0 = 0x08,
	TMDSOUT_FORCED1 = 0x0C
};

#define PLL_SCG1_SCG_FDN			(1 << 0)

#define PLL_SCG2_SCG_NOSC_MASK			(0x03U)
#define PLL_SCG2_SELPLLCLKIN			(1 << 4)
#define PLL_SCG2_BYPASS_SCG			(1 << 7)

#define VAI_PLL_PLLSRL_LOCK			(1 << 0)
#define VAI_PLL_PLLSCG_LOCK			(1 << 1)
#define VAI_PLL_PLLSRL_HVP			(1 << 4)
#define VAI_PLL_PLLSCG_HVP			(1 << 5)
#define VAI_PLL_PLLDE_HVP			(1 << 6)

#define AUDIO_DIV_AUDIO_DIV_MASK		(0x07U)

#define AIP_CNTRL_0_RST_FIFO			(1 << 0)
#define AIP_CNTRL_0_SWAP			(1 << 1)
#define AIP_CNTRL_0_LAYOUT			(1 << 2)
#define AIP_CNTRL_0_ACR_MAN			(1 << 5)
#define AIP_CNTRL_0_RST_CTS			(1 << 6)

#define TEST1_TST_ENAHVP			(1 << 0)
#define TEST1_TST_NOSC				(1 << 1)
#define TEST1_SRLDAT_MASK			(0xC0U)

#define TEST2_DIVTESTOE				(1 << 0)
#define TEST2_PWD1V8				(1 << 1)

#define SEL_CLK_SEL_CLK1			(1 << 0)
#define SEL_CLK_SEL_VRF_CLK_MASK		(0x06U)
#define SEL_CLK_ENA_SC_CLK			(1 << 3)


#define BUFF_OUT2_FORCE_DAT0_MASK		(0x03U)
#define BUFF_OUT2_FORCE_DAT1_MASK		(0x0CU)
#define BUFF_OUT2_FORCE_DAT2_MASK		(0x30U)

#define EDID_CTRL_EDID_RD			(1 << 0)

#define CA_I2S_CA_I2S_MASK			(0x1FU)
#define CA_I2S_HBR_CHSTAT_4			(1 << 5)

#define GC_AVMUTE_SETCLR_MUTE			(0x0CU)
#define GC_AVMUTE_CLR_MUTE			(1 << 0)
#define GC_AVMUTE_SET_MUTE			(1 << 1)

#define CTS_N_M_SEL_MASK			(0x30U)
#define CTS_N_K_SEL_MASK			(0x07U)

#define ENC_CNTRL_RST_ENC			(1 << 0)
#define ENC_CNTRL_RST_SEL			(1 << 1)
#define ENC_CNTRL_CTL_CODE_MASK			(0x0CU)

#define DIP_FLAGS_ACR				(1 << 0)
#define DIP_FLAGS_GC				(1 << 1)
#define DIP_FLAGS_ISRC1				(1 << 2)
#define DIP_FLAGS_ISRC2				(1 << 3)
#define DIP_FLAGS_ACP				(1 << 4)
#define DIP_FLAGS_NULL				(1 << 6)
#define DIP_FLAGS_FORCE_NULL			(1 << 7)

#define DIP_IF_FLAGS_IF1			(1 << 1)
#define DIP_IF_FLAGS_IF2			(1 << 2)
#define DIP_IF_FLAGS_IF3			(1 << 3)
#define DIP_IF_FLAGS_IF4			(1 << 4)
#define DIP_IF_FLAGS_IF5			(1 << 5)

#define OTP_TX0_SR_HDCP				(1 << 0)
#define DDC_SPEED_FACTOR			(39)
#define OTP_TX33_HDMI				(1 << 1)

#define GMD_CONTROL_ENABLE			(1 << 0)
#define GMD_CONTROL_BUF_SEL			(1 << 1)

/**
 * @brief	HDMI Core Registers
 */
enum tda998x_hdmi_reg {
	VERSION			= PAGE_ADDR(PAGE_00, 0x00),	/**< Device version */
	MAIN_CNTRL0		= PAGE_ADDR(PAGE_00, 0x01),	/**< Main control */
	VERSION_MSB		= PAGE_ADDR(PAGE_00, 0x02),
	PACKAGE_TYPE		= PAGE_ADDR(PAGE_00, 0x03),
	SR_REG			= PAGE_ADDR(PAGE_00, 0x0A),
	DDC_DISABLE		= PAGE_ADDR(PAGE_00, 0x0B),
	CCLK_ON			= PAGE_ADDR(PAGE_00, 0x0C),
	I2C_MASTER		= PAGE_ADDR(PAGE_00, 0x0D),
#ifdef TMFL_HDCP_OPTIMIZED_POWER
	FEAT_POWER_DOWN		= PAGE_ADDR(PAGE_00, 0x0E),
#endif
	INT_FLAGS_0		= PAGE_ADDR(PAGE_00, 0x0F),
	INT_FLAGS_1		= PAGE_ADDR(PAGE_00, 0x10),
	INT_FLAGS_2		= PAGE_ADDR(PAGE_00, 0x11),
	INT_FLAGS_3		= PAGE_ADDR(PAGE_00, 0x12),
	SW_INT			= PAGE_ADDR(PAGE_00, 0x15),
	ENA_ACLK		= PAGE_ADDR(PAGE_00, 0x16),
	ENA_VP_0		= PAGE_ADDR(PAGE_00, 0x18),
	ENA_VP_1		= PAGE_ADDR(PAGE_00, 0x19),
	ENA_VP_2		= PAGE_ADDR(PAGE_00, 0x1A),
	ENA_AP			= PAGE_ADDR(PAGE_00, 0x1E),
	VIP_CNTRL_0		= PAGE_ADDR(PAGE_00, 0x20),
	VIP_CNTRL_1		= PAGE_ADDR(PAGE_00, 0x21),
	VIP_CNTRL_2		= PAGE_ADDR(PAGE_00, 0x22),
	VIP_CNTRL_3		= PAGE_ADDR(PAGE_00, 0x23),
	VIP_CNTRL_4		= PAGE_ADDR(PAGE_00, 0x24),
	VIP_CNTRL_5		= PAGE_ADDR(PAGE_00, 0x25),
	MUX_AP			= PAGE_ADDR(PAGE_00, 0x26),
	MUX_VP_VIP_OUT		= PAGE_ADDR(PAGE_00, 0x27),
	MAT_CONTRL		= PAGE_ADDR(PAGE_00, 0x80),
	MAT_OI1_MSB		= PAGE_ADDR(PAGE_00, 0x81),
	MAT_P11_MSB		= PAGE_ADDR(PAGE_00, 0x87),
	MAT_OO1_MSB		= PAGE_ADDR(PAGE_00, 0x99),
	VIDFORMAT		= PAGE_ADDR(PAGE_00, 0xA0),
	REFPIX_MSB		= PAGE_ADDR(PAGE_00, 0xA1),
	REFPIX_LSB		= PAGE_ADDR(PAGE_00, 0xA2),
	REFLINE_MSB		= PAGE_ADDR(PAGE_00, 0xA3),
	REFLINE_LSB		= PAGE_ADDR(PAGE_00, 0xA4),
	NPIX_MSB		= PAGE_ADDR(PAGE_00, 0xA5),
	NPIX_LSB		= PAGE_ADDR(PAGE_00, 0xA6),
	NLINE_MSB		= PAGE_ADDR(PAGE_00, 0xA7),
	NLINE_LSB		= PAGE_ADDR(PAGE_00, 0xA8),
	VS_LINE_STRT_1_MSB	= PAGE_ADDR(PAGE_00, 0xA9),
	VS_LINE_STRT_1_LSB	= PAGE_ADDR(PAGE_00, 0xAA),
	VS_PIX_STRT_1_MSB	= PAGE_ADDR(PAGE_00, 0xAB),
	VS_PIX_STRT_1_LSB	= PAGE_ADDR(PAGE_00, 0xAC),
	VS_LINE_END_1_MSB	= PAGE_ADDR(PAGE_00, 0xAD),
	VS_LINE_END_1_LSB	= PAGE_ADDR(PAGE_00, 0xAE),
	VS_PIX_END_1_MSB	= PAGE_ADDR(PAGE_00, 0xAF),
	VS_PIX_END_1_LSB	= PAGE_ADDR(PAGE_00, 0xB0),
	VS_LINE_STRT_2_MSB	= PAGE_ADDR(PAGE_00, 0xB1),
	VS_LINE_STRT_2_LSB	= PAGE_ADDR(PAGE_00, 0xB2),
	VS_PIX_STRT_2_MSB	= PAGE_ADDR(PAGE_00, 0xB3),
	VS_PIX_STRT_2_LSB	= PAGE_ADDR(PAGE_00, 0xB4),
	VS_LINE_END_2_MSB	= PAGE_ADDR(PAGE_00, 0xB5),
	VS_LINE_END_2_LSB	= PAGE_ADDR(PAGE_00, 0xB6),
	VS_PIX_END_2_MSB	= PAGE_ADDR(PAGE_00, 0xB7),
	VS_PIX_END_2_LSB	= PAGE_ADDR(PAGE_00, 0xB8),
	HS_PIX_START_MSB	= PAGE_ADDR(PAGE_00, 0xB9),
	HS_PIX_START_LSB	= PAGE_ADDR(PAGE_00, 0xBA),
	HS_PIX_STOP_MSB		= PAGE_ADDR(PAGE_00, 0xBB),
	HS_PIX_STOP_LSB		= PAGE_ADDR(PAGE_00, 0xBC),
	VWIN_START_1_MSB	= PAGE_ADDR(PAGE_00, 0xBD),
	VWIN_START_1_LSB	= PAGE_ADDR(PAGE_00, 0xBE),
	VWIN_END_1_MSB		= PAGE_ADDR(PAGE_00, 0xBF),
	VWIN_END_1_LSB		= PAGE_ADDR(PAGE_00, 0xC0),
	VWIN_START_2_MSB	= PAGE_ADDR(PAGE_00, 0xC1),
	VWIN_START_2_LSB	= PAGE_ADDR(PAGE_00, 0xC2),
	VWIN_END_2_MSB		= PAGE_ADDR(PAGE_00, 0xC3),
	VWIN_END_2_LSB		= PAGE_ADDR(PAGE_00, 0xC4),
	DE_START_MSB		= PAGE_ADDR(PAGE_00, 0xC5),
	DE_START_LSB		= PAGE_ADDR(PAGE_00, 0xC6),
	DE_STOP_MSB		= PAGE_ADDR(PAGE_00, 0xC7),
	DE_STOP_LSB		= PAGE_ADDR(PAGE_00, 0xC8),
	COLBAR_WIDTH		= PAGE_ADDR(PAGE_00, 0xC9),
	TBG_CNTRL_0		= PAGE_ADDR(PAGE_00, 0xCA),
	TBG_CNTRL_1		= PAGE_ADDR(PAGE_00, 0xCB),
	VBL_OFFSET_START	= PAGE_ADDR(PAGE_00, 0xCC),
	VBL_OFFSET_END		= PAGE_ADDR(PAGE_00, 0xCD),
	HBL_OFFSET_START	= PAGE_ADDR(PAGE_00, 0xCE),
	HBL_OFFSET_END		= PAGE_ADDR(PAGE_00, 0xCF),
	DWIN_RE_DE		= PAGE_ADDR(PAGE_00, 0xD0),
	DWIN_FE_DE		= PAGE_ADDR(PAGE_00, 0xD1),
#ifdef TMFL_RGB_DDR_12BITS
	VSPACE_START_MSB	= PAGE_ADDR(PAGE_00, 0xD2),
	VSPACE_START_LSB	= PAGE_ADDR(PAGE_00, 0xD3),
	VSPACE_END_MSB		= PAGE_ADDR(PAGE_00, 0xD4),
	VSPACE_END_LSB		= PAGE_ADDR(PAGE_00, 0xD5),
	ENABLE_SPACE		= PAGE_ADDR(PAGE_00, 0xD6),
	VSPACE_Y_DATA		= PAGE_ADDR(PAGE_00, 0xD7),
	VSPACE_U_DATA		= PAGE_ADDR(PAGE_00, 0xD8),
	VSPACE_V_DATA		= PAGE_ADDR(PAGE_00, 0xD9),
#endif
	TIMER_RI_PJ		= PAGE_ADDR(PAGE_00, 0xE1),
	BCAPS_POLL		= PAGE_ADDR(PAGE_00, 0xE2),
	REG_100us		= PAGE_ADDR(PAGE_00, 0xE3),
	HVF_CNTRL_0		= PAGE_ADDR(PAGE_00, 0xE4),
	HVF_CNTRL_1		= PAGE_ADDR(PAGE_00, 0xE5),
	TIMER_H			= PAGE_ADDR(PAGE_00, 0xE8),
	TIMER_M			= PAGE_ADDR(PAGE_00, 0xE9),
	TIMER_L			= PAGE_ADDR(PAGE_00, 0xEA),
	TIMER_2SEC		= PAGE_ADDR(PAGE_00, 0xEB),
	TIMER_5SEC		= PAGE_ADDR(PAGE_00, 0xEC),
	NDIV_IM			= PAGE_ADDR(PAGE_00, 0xEE),
	NDIV_PF			= PAGE_ADDR(PAGE_00, 0xEF),
	RPT_CNTRL		= PAGE_ADDR(PAGE_00, 0xF0),
	LEAD_OFF		= PAGE_ADDR(PAGE_00, 0xF1),
	TRAIL_OFF		= PAGE_ADDR(PAGE_00, 0xF2),
	MISR_EXP_0		= PAGE_ADDR(PAGE_00, 0xF3),
	MISR_EXP_1		= PAGE_ADDR(PAGE_00, 0xF4),
	MISR_EXP_2		= PAGE_ADDR(PAGE_00, 0xF5),
	MISR_0			= PAGE_ADDR(PAGE_00, 0xF6),
	MISR_1			= PAGE_ADDR(PAGE_00, 0xF7),
	DEBUG_PROBE		= PAGE_ADDR(PAGE_00, 0xF8),
	GHOST_XADDR		= PAGE_ADDR(PAGE_00, 0xF9),
	MISR_2			= PAGE_ADDR(PAGE_00, 0xFA),
	I2S_FORMAT		= PAGE_ADDR(PAGE_00, 0xFC),
	AIP_CLKSEL		= PAGE_ADDR(PAGE_00, 0xFD),
	GHOST_ADDR		= PAGE_ADDR(PAGE_00, 0xFE),
	SC_VIDFORMAT		= PAGE_ADDR(PAGE_01, 0x00),
	SC_CNTRL		= PAGE_ADDR(PAGE_01, 0x01),
	SC_DELTA_PHASE_V	= PAGE_ADDR(PAGE_01, 0x02),
	SC_DELTA_PHASE_H	= PAGE_ADDR(PAGE_01, 0x03),
	SC_START_PHASE_H	= PAGE_ADDR(PAGE_01, 0x04),
	SC_NPIX_IN_LSB		= PAGE_ADDR(PAGE_01, 0x05),
	SC_NPIX_IN_MSB		= PAGE_ADDR(PAGE_01, 0x06),
	SC_NPIX_OUT_LSB		= PAGE_ADDR(PAGE_01, 0x07),
	SC_NPIX_OUT_MSB		= PAGE_ADDR(PAGE_01, 0x08),
	SC_NLINE_IN_LSB		= PAGE_ADDR(PAGE_01, 0x09),
	SC_NLINE_IN_MSB		= PAGE_ADDR(PAGE_01, 0x0A),
	SC_NLINE_OUT_LSB	= PAGE_ADDR(PAGE_01, 0x0B),
	SC_NLINE_OUT_MSB	= PAGE_ADDR(PAGE_01, 0x0C),
	SC_NLINE_SKIP		= PAGE_ADDR(PAGE_01, 0x0D),
	SC_SAMPLE_BUFFIL	= PAGE_ADDR(PAGE_01, 0x0E),
	SC_MAX_BUFFILL_P_0	= PAGE_ADDR(PAGE_01, 0x0F),
	SC_MAX_BUFFILL_P_1	= PAGE_ADDR(PAGE_01, 0x10),
	SC_MAX_BUFFILL_D_0	= PAGE_ADDR(PAGE_01, 0x11),
	SC_MAX_BUFFILL_D_1	= PAGE_ADDR(PAGE_01, 0x12),
	SC_SAMPLE_FIFOFILL	= PAGE_ADDR(PAGE_01, 0x13),
	SC_MAX_FIFOFILL_PI	= PAGE_ADDR(PAGE_01, 0x14),
	SC_MIN_FIFOFILL_PO1	= PAGE_ADDR(PAGE_01, 0x15),
	SC_MIN_FIFOFILL_PO2	= PAGE_ADDR(PAGE_01, 0x16),
	SC_MIN_FIFOFILL_PO3	= PAGE_ADDR(PAGE_01, 0x17),
	SC_MIN_FIFOFILL_PO4	= PAGE_ADDR(PAGE_01, 0x18),
	SC_MAX_FIFOFILL_DI	= PAGE_ADDR(PAGE_01, 0x19),
	SC_MAX_FIFOFILL_DO	= PAGE_ADDR(PAGE_01, 0x1A),
	SC_VS_LUT_0		= PAGE_ADDR(PAGE_01, 0x1B),
	SC_LAT_SCO		= PAGE_ADDR(PAGE_01, 0x48),
	VIDFORMAT_W		= PAGE_ADDR(PAGE_01, 0xA0),
	REFPIX_MSB_W		= PAGE_ADDR(PAGE_01, 0xA1),
	REFPIX_LSB_W		= PAGE_ADDR(PAGE_01, 0xA2),
	REFLINE_MSB_W		= PAGE_ADDR(PAGE_01, 0xA3),
	REFLINE_LSB_W		= PAGE_ADDR(PAGE_01, 0xA4),
	NPIX_MSB_W		= PAGE_ADDR(PAGE_01, 0xA5),
	NPIX_LSB_W		= PAGE_ADDR(PAGE_01, 0xA6),
	NLINE_MSB_W		= PAGE_ADDR(PAGE_01, 0xA7),
	NLINE_LSB_W		= PAGE_ADDR(PAGE_01, 0xA8),
	VWIN_START_1_MSB_W	= PAGE_ADDR(PAGE_01, 0xBD),
	VWIN_START_1_LSB_W	= PAGE_ADDR(PAGE_01, 0xBE),
	VWIN_END_1_MSB_W	= PAGE_ADDR(PAGE_01, 0xBF),
	VWIN_END_1_LSB_W	= PAGE_ADDR(PAGE_01, 0xC0),
	VWIN_START_2_MSB_W	= PAGE_ADDR(PAGE_01, 0xC1),
	VWIN_START_2_LSB_W	= PAGE_ADDR(PAGE_01, 0xC2),
	VWIN_END_2_MSB_W	= PAGE_ADDR(PAGE_01, 0xC3),
	VWIN_END_2_LSB_W	= PAGE_ADDR(PAGE_01, 0xC4),
	DE_START_MSB_W		= PAGE_ADDR(PAGE_01, 0xC5),
	DE_START_LSB_W		= PAGE_ADDR(PAGE_01, 0xC6),
	DE_STOP_MSB_W		= PAGE_ADDR(PAGE_01, 0xC7),
	DE_STOP_LSB_W		= PAGE_ADDR(PAGE_01, 0xC8),
	TBG_CNTRL_0_W		= PAGE_ADDR(PAGE_01, 0xCA),
	PLL_SERIAL_1		= PAGE_ADDR(PAGE_02, 0x00),
	PLL_SERIAL_2		= PAGE_ADDR(PAGE_02, 0x01),
	PLL_SERIAL_3		= PAGE_ADDR(PAGE_02, 0x02),
	SERIALIZER		= PAGE_ADDR(PAGE_02, 0x03),
	BUFFER_OUT		= PAGE_ADDR(PAGE_02, 0x04),
	PLL_SCG1		= PAGE_ADDR(PAGE_02, 0x05),
	PLL_SCG2		= PAGE_ADDR(PAGE_02, 0x06),
	PLL_SCGN1		= PAGE_ADDR(PAGE_02, 0x07),
	PLL_SCGN2		= PAGE_ADDR(PAGE_02, 0x08),
	PLL_SCGR1		= PAGE_ADDR(PAGE_02, 0x09),
	PLL_SCGR2		= PAGE_ADDR(PAGE_02, 0x0A),
	VAI_PLL_R		= PAGE_ADDR(PAGE_02, 0x0D),
	AUDIO_DIV		= PAGE_ADDR(PAGE_02, 0x0E),
	TEST1_RW		= PAGE_ADDR(PAGE_02, 0x0F),
	TEST2_RW		= PAGE_ADDR(PAGE_02, 0x10),
	SEL_CLK			= PAGE_ADDR(PAGE_02, 0x11),
	ANA_GENERAL		= PAGE_ADDR(PAGE_02, 0x12),
	BUFFER_OUT2_RW		= PAGE_ADDR(PAGE_02, 0x13),
	SRL_TSTPAT0_RW		= PAGE_ADDR(PAGE_02, 0x14),
	SRL_TSTPAT1_RW		= PAGE_ADDR(PAGE_02, 0x15),
	SRL_TSTPAT2_RW		= PAGE_ADDR(PAGE_02, 0x16),
	SRL_TSTPAT3_RW		= PAGE_ADDR(PAGE_02, 0x17),
	EDID_DATA_0_R		= PAGE_ADDR(PAGE_09, 0x00),
	EDID_CTRL_RW		= PAGE_ADDR(PAGE_09, 0xFA),
	DDC_ADDR_RW		= PAGE_ADDR(PAGE_09, 0xFB),
	DDC_OFFS_RW		= PAGE_ADDR(PAGE_09, 0xFC),
	DDC_SEGM_ADDR_RW	= PAGE_ADDR(PAGE_09, 0xFD),
	DDC_SEGM_RW		= PAGE_ADDR(PAGE_09, 0xFE),
	IF1_HB0_RW		= PAGE_ADDR(PAGE_10, 0x20),
	IF1_PB0_RW		= PAGE_ADDR(PAGE_10, 0x23),
	IF1_PB10_RW		= PAGE_ADDR(PAGE_10, 0x2D),
	IF2_HB0_RW		= PAGE_ADDR(PAGE_10, 0x40),
	IF2_PB0_RW		= PAGE_ADDR(PAGE_10, 0x43),
	IF3_HB0_RW		= PAGE_ADDR(PAGE_10, 0x60),
	IF3_PB0_RW		= PAGE_ADDR(PAGE_10, 0x63),
	IF4_HB0_RW		= PAGE_ADDR(PAGE_10, 0x80),
	IF4_PB0_RW		= PAGE_ADDR(PAGE_10, 0x83),
	IF5_HB0_RW		= PAGE_ADDR(PAGE_10, 0xA0),
	IF5_PB0			= PAGE_ADDR(PAGE_10, 0xA3),
	AIP_CNTRL_0		= PAGE_ADDR(PAGE_11, 0x00),
	CA_I2S			= PAGE_ADDR(PAGE_11, 0x01),
	CA_DSD			= PAGE_ADDR(PAGE_11, 0x02),
	OBA_PH			= PAGE_ADDR(PAGE_11, 0x03),
	LATENCY_RD		= PAGE_ADDR(PAGE_11, 0x04),
	ACR_CTS_0		= PAGE_ADDR(PAGE_11, 0x05),
	ACR_CTS_1		= PAGE_ADDR(PAGE_11, 0x06),
	ACR_CTS_2		= PAGE_ADDR(PAGE_11, 0x07),
	ACR_N_0			= PAGE_ADDR(PAGE_11, 0x08),
	ACR_N_1			= PAGE_ADDR(PAGE_11, 0x09),
	ACR_N_2			= PAGE_ADDR(PAGE_11, 0x0A),
	GC_AVMUTE		= PAGE_ADDR(PAGE_11, 0x0B),
	CTS_N_RW		= PAGE_ADDR(PAGE_11, 0x0C),
	ENC_CNTRL		= PAGE_ADDR(PAGE_11, 0x0D),
	DIP_FLAGS		= PAGE_ADDR(PAGE_11, 0x0E),
	DIP_IF_FLAGS		= PAGE_ADDR(PAGE_11, 0x0F),
	CH_STAT_B_0		= PAGE_ADDR(PAGE_11, 0x14),
	CH_STAT_B_1		= PAGE_ADDR(PAGE_11, 0x15),
	CH_STAT_B_3		= PAGE_ADDR(PAGE_11, 0x16),
	CH_STAT_B_4		= PAGE_ADDR(PAGE_11, 0x17),
	CH_STAT_B_2_ap0_l_RW	= PAGE_ADDR(PAGE_11, 0x18),
	CH_STAT_B_2_ap0_r_RW	= PAGE_ADDR(PAGE_11, 0x19),
	CH_STAT_B_2_ap1_l_RW	= PAGE_ADDR(PAGE_11, 0x1A),
	CH_STAT_B_2_ap1_r_RW	= PAGE_ADDR(PAGE_11, 0x1B),
	CH_STAT_B_2_ap2_l_RW	= PAGE_ADDR(PAGE_11, 0x1C),
	CH_STAT_B_2_ap2_r_RW	= PAGE_ADDR(PAGE_11, 0x1D),
	CH_STAT_B_2_ap3_l_RW	= PAGE_ADDR(PAGE_11, 0x1E),
	CH_STAT_B_2_ap3_r_RW	= PAGE_ADDR(PAGE_11, 0x1F),
	ISRC1_HB0_RW		= PAGE_ADDR(PAGE_11, 0x20),
	ISRC1_PB0_RW		= PAGE_ADDR(PAGE_11, 0x23),
	ISRC2_HB0_RW		= PAGE_ADDR(PAGE_11, 0x40),
	ISRC2_PB0_RW		= PAGE_ADDR(PAGE_11, 0x43),
	ACP_HB0_RW		= PAGE_ADDR(PAGE_11, 0x60),
	ACP_PB0_RW		= PAGE_ADDR(PAGE_11, 0x63),
	OTP_TX0			= PAGE_ADDR(PAGE_12, 0x97),
	OTP_TX1			= PAGE_ADDR(PAGE_12, 0x98),
	OTP_TX2			= PAGE_ADDR(PAGE_12, 0x99),
	OTP_TX3			= PAGE_ADDR(PAGE_12, 0x9A),
	OTP_TX33		= PAGE_ADDR(PAGE_12, 0xB8),
	GMD_0_HB0_RW		= PAGE_ADDR(PAGE_13, 0x00),
	GMD_0_PB0_RW		= PAGE_ADDR(PAGE_13, 0x03),
	GMD_CONTROL_RW		= PAGE_ADDR(PAGE_13, 0x1F),
	GMD_1_HB0_RW		= PAGE_ADDR(PAGE_13, 0x20),
	GMD_1_PB0_RW		= PAGE_ADDR(PAGE_13, 0x23),
	INVALID_REG		= PAGE_ADDR(PAGE_INVALID, 0xFF),
	CURPAGE			= PAGE_ADDR(PAGE_INVALID, 0xFF),
};


//enum _eShad
//{
//	INT_FLAGS_0  = 0,
//	INT_FLAGS_1  = 1,
//	INT_FLAGS_2  = 2,
//	VIP_CNTRL_0  = 3,
//	VIP_CNTRL_1  = 4,
//	VIP_CNTRL_2  = 5,
//	VIP_CNTRL_3  = 6,
//	VIP_CNTRL_4  = 7,
//	VIP_CNTRL_5  = 8,
//	MAT_CONTRL   = 9,
//	TBG_CNTRL_0  = 10,
//	TBG_CNTRL_1  = 11,
//	HVF_CNTRL_0  = 12,
//	HVF_CNTRL_1  = 13,
//	TIMER_H      = 14,
//	DEBUG_PROBE  = 15,
//	AIP_CLKSEL   = 16,
//	SC_VIDFORMAT = 17,
//	SC_CNTRL     = 18,
//	SP01_TBG_CNTRL_0  = 19,
//#ifdef TMFL_HDCP_SUPPORT
//	SP12_OTP_CNTRL    = 20,
//	SP12_CTRL         = 21,
//	SP12_BCAPS        = 22,
//	SNUM              = 23,   /* Number of shadow registers */
//	SNONE             = 23    /* Index value indicating no shadow register */
//#else /* TMFL_HDCP_SUPPORT */
//	SNUM              = 20,   /* Number of shadow registers */
//	SNONE             = 20    /* Index value indicating no shadow register */
//#endif /* TMFL_HDCP_SUPPORT */
//};

/**
 * @brief	Supported feature enumeration
 */
enum feat_support {
	FEAT_HDCP = 0,			/**< HDCP */
	FEAT_SCALER = 1,  		/**< Scaler */
	FEAT_AUDIO_OBA = 2, 		/**< One bit audio */
	FEAT_AUDIO_DST = 3,  		/**< DST audio */
	FEAT_AUDIO_HBR = 4,  		/**< HBR audio */
	FEAT_HDMI_1_1 = 5,  		/**< HDMI 1.1 */
	FEAT_HDMI_1_2A = 6, 		/**< HDMI 1.2a */
	FEAT_HDMI_1_3A = 7,  		/**< HDMI 1.3a */
	FEAT_DEEP_COLOR_30 = 8,  	/**< 30 bits deep color */
	FEAT_DEEP_COLOR_36 = 9,  	/**< 36 bits deep color */
	FEAT_DEEP_COLOR_48 = 11, 	/**< 48 bits deep color */
	FEAT_UPSAMPLER = 12, 		/**< Up sampler */
	FEAT_DOWNSAMPLER = 13, 		/**< Down sampler */
	FEAT_COLOR_CONVERSION = 14	/**< Color conversion matrix */
};

/**
 * @brief	Frame Sync
 */
enum vs_fsync {
	VS_FSYNC_EACH_FRAME = 0,	/**< Sync on each frame */
	VS_FSYNC_ONCE = 1,		/**< Sync once only     */
};

enum vs_src {
	VS_SRC_INTERNAL = 0,		/**< Internal */
	VS_SRC_EXTERNAL = 1,		/**< External */
	VS_SRC_NO_CHANGE = 2,		/**< No change */
	VS_SRC_INVALID = 3		/**< Invalid */
};

enum vs_tgl {
	VS_TGL_TABLE = 0,		/**< VS/HS polarity from table */
	VS_TGL_UNUSED_1 = 1,		/**< Unused */
	VS_TGL_UNUSED_2 = 2,		/**< Unused */
	VS_TGL_UNUSED_3 = 3,		/**< Unused */
	VS_TGL_NO_ACTION = 4,		/**< No toggle */
	VS_TGL_HS = 5,			/**< Toggle Hs */
	VS_TGL_VS = 6,			/**< Toggle Vs */
	VS_TGL_HS_VS = 7		/**< Toggle Hs & Vs */
};

struct reg_mask_val {
	enum tda998x_hdmi_reg	reg;
	uint8_t			val;
};

static const enum vip_cntrl_swap port_map_rgb444[] = {
	VIP_CNTRL_VP23_20,
	VIP_CNTRL_VP19_16,
	VIP_CNTRL_VP15_12,
	VIP_CNTRL_VP11_8,
	VIP_CNTRL_VP7_4,
	VIP_CNTRL_VP3_0
};

static const enum vip_cntrl_mirr mirr_map_rgb444[] = {
	VIP_CNTRL_NOT_MIRRORED,
	VIP_CNTRL_NOT_MIRRORED,
	VIP_CNTRL_NOT_MIRRORED,
	VIP_CNTRL_NOT_MIRRORED,
	VIP_CNTRL_NOT_MIRRORED,
	VIP_CNTRL_NOT_MIRRORED
};

/**
 * @addtogroup TDA998X_PLL_Configuration
 * @{
 */
struct reg_mask_val pll_cfg_common[] = {
	{ PLL_SERIAL_1,	0x00},
	{ PLL_SERIAL_2,	0x01},
	{ PLL_SERIAL_3,	0x00},
	{ SERIALIZER,	0x00},
	{ BUFFER_OUT,	0x00},
	{ PLL_SCG1,	0x00},
	{ AUDIO_DIV,	0x03},
	{ SEL_CLK,	0x09},
	{ INVALID_REG,	0x00 }
};

struct reg_mask_val pll_cfg_other[] = {
	{ PLL_SCGN1,	0xFA},
	{ PLL_SCGN2,	0x00},
	{ PLL_SCGR1,	0x5B},
	{ PLL_SCGR2,	0x00},
	{ INVALID_REG,	0x00 }
};

struct reg_mask_val pll_cfg_480ix576i[] = {
	{ PLL_SCGN1,	0x14 },
	{ PLL_SCGN2,	0x00 },
	{ PLL_SCGR1,	0x0A },
	{ PLL_SCGR2,	0x00 },
	{ INVALID_REG,	0x00 }
};
/**
 * @}
 */

/**
 * @brief	Write Data
 *
 * @param	dev:	TDA998X device structure pointer
 * @param	reg:	Start register and page address
 * @param	len:	Length of data to write to device
 * @param	data:	Pointer to data to write from
 * @return	Number of bytes written or less-than-zero error status
 */
static int
tda998x_write(struct tda998x_dev *dev,
		enum tda998x_hdmi_reg reg,
		uint8_t len,
		uint8_t *data)
{
	int i, err;
	struct tda998x_cfg *cfg = dev->cfg;
	uint8_t page = PAGE_OF(reg);

	if (dev->cfg->cur_page != page) {
		/* Change the page */
		err = cfg->i2c_write(cfg->hdmi_addr, (uint8_t)CURPAGE, &page);
		if (err < 0)
			return err;

		dev->cfg->cur_page = page;
	}

	for (i = 0; i < len; i++, data++) {
		err = cfg->i2c_write(cfg->hdmi_addr, (uint8_t)reg + i, data);
		if (err < 0)
			return err;
	}

	return i;
}

/**
 * @brief	Write Register
 *
 * @param	dev:	TDA998X device structure pointer
 * @param	reg:	Register and page address
 * @param	data:	Data value to write to register
 * @return	Number of bytes written or less-than-zero error status
 */
static int
write_reg(struct tda998x_dev *dev, enum tda998x_hdmi_reg reg, uint8_t data)
{
	uint8_t tmp = data;

	return tda998x_write(dev, reg, 1, &tmp);
}

/**
 * @brief	Read Data
 *
 * @param	dev:	TDA998X device structure pointer
 * @param	reg:	Start register and page address
 * @param	len:	Length of data to read from device
 * @param	data:	Pointer to data to read to
 * @return	Number of bytes read or less-than-zero error status
 */
static int
tda998x_read(struct tda998x_dev *dev,
		enum tda998x_hdmi_reg reg,
		uint8_t len,
		uint8_t *data)
{
	int i, err;
	struct tda998x_cfg *cfg = dev->cfg;
	uint8_t page = PAGE_OF(reg);

	if (dev->cfg->cur_page != page) {
		/* Change the page */
		err = cfg->i2c_write(cfg->hdmi_addr, (uint8_t)CURPAGE, &page);
		if (err < 0)
			return err;

		dev->cfg->cur_page = page;
	}

	for (i = 0; i < len; i++, data++) {
		err = cfg->i2c_read(cfg->hdmi_addr, (uint8_t)reg + i, data);
		if (err < 0)
			return err;
	}

	return i;
}

/**
 * @brief	Read Register
 *
 * @param	dev:	TDA998X device structure pointer
 * @param	reg:	Register and page address
 * @param	data:	Pointer to data to read to
 * @return	Number of bytes read or less-than-zero error status
 */
static int
read_reg(struct tda998x_dev *dev, enum tda998x_hdmi_reg reg, uint8_t *data)
{
	return tda998x_read(dev, reg, 1, data);
}

/**
 * @brief	Register Mask Write
 *		Write a value with mask bits to a register
 *
 * @param	dev:	TDA998X device structure pointer
 * @param	reg:	Register and page address
 * @param	mask:	Mask of bits to be transformed
 * @param	val:	Bitfield to be written within mask
 * @return	Number of bytes written or less-than-zero error status
 */
static int
write_reg_mask(struct tda998x_dev *dev,
		enum tda998x_hdmi_reg reg,
		uint8_t mask,
		uint8_t val)
{
	int err;
	uint8_t reg_val;

	err = read_reg(dev, reg, &reg_val);
	if (err < 0)
		return err;

	reg_val &= ~(mask);			/* clear bits in the mask */
	reg_val |= val & mask;			/* set masked value bits */

	return write_reg(dev, reg, reg_val);
}

/**
 * @brief	Register Mask Write from Table
 * 		Write a value with mask specified in table until terminator
 *
 * @param	dev:	TDA998X device structure pointer
 * @param	tab:	Table of register, mask, value parameters
 * @return	Number of items processed or less-than-zero error status
 */
static int
write_reg_table(struct tda998x_dev *dev, struct reg_mask_val *tab)
{
	int err, cnt = 0;
	struct reg_mask_val *item = tab;

	while (item && item->reg != INVALID_REG) {
		err = write_reg(dev, item->reg, item->val);
		if (err < 0)
			return err;

		item++;
		cnt++;
	}

	return cnt;
}

/**
 * @brief	CEC Write Data
 *
 * @param	dev:	TDA998X device structure pointer
 * @param	reg:	Start register and page address
 * @param	len:	Length of data to write to device
 * @param	data:	Pointer to data to write from
 * @return	Number of bytes written or less-than-zero error status
 */
static int
tda998x_cec_write(struct tda998x_dev *dev,
		enum tda998x_cec_reg reg,
		uint8_t len,
		uint8_t *data)
{
	int i, err;
	struct tda998x_cfg *cfg = dev->cfg;

	for (i = 0; i < len; i++, data++) {
		err = cfg->i2c_write(cfg->cec_addr, (uint8_t)reg + i, data);
		if (err < 0)
			return err;
	}

	return i;
}

/**
 * @brief	CEC Write Register
 *
 * @param	dev:	TDA998X device structure pointer
 * @param	reg:	Register and page address
 * @param	data:	Data value to write to register
 * @return	Number of bytes written or less-than-zero error status
 */
static int
cec_write_reg(struct tda998x_dev *dev, enum tda998x_cec_reg reg, uint8_t data)
{
	uint8_t tmp = data;

	return tda998x_cec_write(dev, reg, 1, &tmp);
}

/**
 * @brief	CEC Read Data
 *
 * @param	dev:	TDA998X device structure pointer
 * @param	reg:	Start register and page address
 * @param	len:	Length of data to read from device
 * @param	data:	Pointer to data to read to
 * @return	Number of bytes read or less-than-zero error status
 */
static int
tda998x_cec_read(struct tda998x_dev *dev,
		enum tda998x_cec_reg reg,
		uint8_t len,
		uint8_t *data)
{
	int i, err;
	struct tda998x_cfg *cfg = dev->cfg;

	for (i = 0; i < len; i++, data++) {
		err = cfg->i2c_read(cfg->cec_addr, (uint8_t)reg + i, data);
		if (err < 0)
			return err;
	}

	return i;
}

/**
 * @brief	CEC Read Register
 *
 * @param	dev:	TDA998X device structure pointer
 * @param	reg:	Register and page address
 * @param	data:	Pointer to data to read to
 * @return	Number of bytes read or less-than-zero error status
 */
static int
cec_read_reg(struct tda998x_dev *dev, enum tda998x_cec_reg reg, uint8_t *data)
{
	return tda998x_cec_read(dev, reg, 1, data);
}

/**
 * @brief	CEC Register Mask Write
 *		Write a specified value with specified mask bits to a register
 *
 * @param	dev:	TDA99X device structure pointer
 * @param	reg:	Register and page address
 * @param	mask:	Mask of bits to be transformed
 * @param	val:	Bitfield to be written within mask
 * @return	Number of bytes written or less-than-zero error status
 */
static int
cec_write_reg_mask(struct tda998x_dev *dev,
		enum tda998x_cec_reg reg,
		uint8_t mask,
		uint8_t val)
{
	int err;
	uint8_t reg_val;

	err = cec_read_reg(dev, reg, &reg_val);
	if (err < 0)
		return err;

	reg_val &= ~(mask);
	reg_val |= val & mask;

	return cec_write_reg(dev, reg, reg_val);
}

/**
 * @addtogroup TDA998X_Video_Port
 * @{
 */


static uint8_t
reg_vid_fmt(tmbslHdmiTxVidFmt_t fmt,
		tmbslHdmiTx3DStructure_t structure3D,
		UInt8 *idx,
		UInt8 *idx3d,
		struct sync_desc **sync)
{
   struct vic2reg *hash;
   int i;

   (*idx)=REGVFMT_INVALID;
   if (idx3d) (*idx3d)=REGVFMT_INVALID;
   if (IS_TV(fmt)) {
      VIC2REG_LOOP(vic2reg_TV,idx);
      if (idx3d) {
         if (structure3D == HDMITX_3D_FRAME_PACKING) {
            /* any 3D FP prefetch ? */
            VIC2REG_LOOP(vic2reg_TV_FP,idx3d);
         }
      }
   }
#ifdef FORMAT_PC
   else {
      VIC2REG_LOOP(vic2reg_PC,idx);
   }
#endif
   /* PR1570 FIXED */
   if (sync) {
	   if PREFETCH(*idx) {
		   *sync = (struct sync_desc *)ref_sync;
	   }
#ifdef FORMAT_PC
	   else if PCFORMAT(*idx) {
		   *sync = (struct sync_desc *)ref_sync_PC;
		   /* *idx = *idx - E_REGVFMT_MAX_EXTRA; */ //FRo bad use of idx
	   }
#endif //FORMAT_PC
	   else {
		   *sync = (struct sync_desc *)ref_sync_extra;
	   }
   }
   return ((*idx)==REGVFMT_INVALID);
}




/**
 * Internal port | RGB 4:4:4 | YCbCr 4:4:4 | YCbCr 4:2:2 Semi-planar | YCbCr 4:2:2 ITU656
 * ------------- | --------- | ----------- | ----------------------- | ------------------
 * VP[23]        | G[7]      | Y[7]        | Y[11]                   | YCbCr[11]
 * VP[22]        | G[6]      | Y[6]        | Y[10]                   | YCbCr[10]
 * VP[21]        | G[5]      | Y[5]        | Y[9]                    | YCbCr[9]
 * VP[20]        | G[4]      | Y[4]        | Y[8]                    | YCbCr[8]
 * VP[19]        | G[3]      | Y[3]        | Y[7]                    | YCbCr[7]
 * VP[18]        | G[2]      | Y[2]        | Y[6]                    | YCbCr[6]
 * VP[17]        | G[1]      | Y[1]        | Y[5]                    | YCbCr[5]
 * VP[16]        | G[0]      | Y[0]        | Y[4]                    | YCbCr[4]
 * VP[15]        | B[7]      | Cb[7]       | Y[3]                    | YCbCr[3]
 * VP[14]        | B[6]      | Cb[6]       | Y[2]                    | YCbCr[2]
 * VP[13]        | B[5]      | Cb[5]       | Y[1]                    | YCbCr[1]
 * VP[12]        | B[4]      | Cb[4]       | Y[0]                    | YCbCr[0]
 * VP[11]        | B[3]      | Cb[3]       | CbCr[11]
 * VP[10]        | B[2]      | Cb[2]       | CbCr[10]
 * VP[9]         | B[1]      | Cb[1]       | CbCr[9]
 * VP[8]         | B[0]      | Cb[0]       | CbCr[8]
 * VP[7]         | R[7]      | Cr[7]       | CbCr[7]
 * VP[6]         | R[6]      | Cr[6]       | CbCr[6]
 * VP[5]         | R[5]      | Cr[5]       | CbCr[5]
 * VP[4]         | R[4]      | Cr[4]       | CbCr[4]
 * VP[3]         | R[3]      | Cr[3]       | CbCr[3]
 * VP[2]         | R[2]      | Cr[2]       | CbCr[2]
 * VP[1]         | R[1]      | Cr[1]       | CbCr[1]
 * VP[0]         | R[0]      | Cr[0]       | CbCr[0]
 */
int
tda998x_set_video_port_enable(struct tda998x_dev *dev)
{
	int err;

	err = write_reg(dev, ENA_VP_0, 0xFF);
	if (err < 0)
		return err;

	err = write_reg(dev, ENA_VP_1, 0xFF);
	if (err < 0)
		return err;

	err = write_reg(dev, ENA_VP_2, 0xFF);
	if (err < 0)
		return err;

	return err;
}

static int
tda998x_set_video_port_map(struct tda998x_dev *dev, enum vip_cntrl_swap *swap, enum vip_cntrl_mirr *mirr)
{
	int i, err;
	uint8_t reg_val;

	/* Check parameters */
	for (i = 0; i < 3; i++) {
		reg_val = swap[2 * i] << VIP_CNTRL_SWAP_H_SHIFT;
		reg_val |= swap[(2 * i) + 1] << VIP_CNTRL_SWAP_L_SHIFT;
		reg_val |= mirr[2 * i] == VIP_CNTRL_MIRRORED ? VIP_CNTRL_MIRR_H : 0;
		reg_val |= mirr[(2 * i) + 1] == VIP_CNTRL_MIRRORED ? VIP_CNTRL_MIRR_L : 0;

		err = write_reg_mask(dev,
				VIP_CNTRL_0 + i,
				VIP_CNTRL_SWAP_MASK,
				reg_val);
	}

	return err;
}
/**
 * @}
 */

/**
 * @brief	Disable HDMI HDCP
 * 		Set HDMI HDCP mode off for DVI
 */
static int
tda998x_disable_hdcp(struct tda998x_dev *dev)
{
	int err;

	err = write_reg_mask(dev,
			TBG_CNTRL_1,
			TBG_CNTRL_1_DWIN_DIS, TBG_CNTRL_1_DWIN_DIS);
	if (err < 0)
		return err;

	err = write_reg_mask(dev,
			OTP_TX33,
			OTP_TX33_HDMI, 0);
	if (err < 0)
		return err;

	return 0;
}

/**
 * @brief	Enable HDMI HDCP
 * 		Set HDMI HDCP mode on for HDMI
 */
static int
tda998x_enable_hdcp(struct tda998x_dev *dev)
{
	int err;

	err = write_reg_mask(dev,
			TBG_CNTRL_1,
			TBG_CNTRL_1_DWIN_DIS, 0);
	if (err < 0)
		return err;

	err = write_reg_mask(dev,
			ENC_CNTRL,
			ENC_CNTRL_CTL_CODE_MASK,
			ENC_CNTRL_CTL_CODE_MASK);
	if (err < 0)
		return err;

	err = write_reg_mask(dev,
			OTP_TX33,
			OTP_TX33_HDMI,
			OTP_TX33_HDMI);
	if (err < 0)
		return err;
}

int
tda998x_set_vidout_cfg(struct tda998x_dev *dev,
		enum tda998x_sink sink,
		enum hvf_cntrl_0_prefil prefil,
		enum hvf_cntrl_1_yuvblk yuvblk)
{
	int err;

	if (sink == SINK_EDID) {
		if (dev->edid_state == EDID_NOT_READ)
			dev->sink = SINK_DVI;
		else
			dev->sink = dev->edid_sink;
	} else {
		dev->sink = sink;
	}

	/* Is DVI sink required? */
	if (dev->sink == SINK_DVI) {
		/* Mute the audio FIFO */
		err = write_reg_mask(dev,
				AIP_CNTRL_0,
				AIP_CNTRL_0_RST_FIFO,
				AIP_CNTRL_0_RST_FIFO);
		if (err < 0)
			return err;

		err = tda998x_disable_hdcp(dev);
		if (err < 0)
			return err;

		err = write_reg_mask(dev,
				ENC_CNTRL,
				ENC_CNTRL_CTL_CODE_MASK,
				0);
	} else {
		/* Unmute the audio FIFO */
		err = write_reg_mask(dev,
				AIP_CNTRL_0,
				AIP_CNTRL_0_RST_FIFO,
				0);
		if (err < 0)
			return err;

		err = tda998x_enable_hdcp(dev);
		if (err < 0)
			return err;
	}

#ifdef HDCP_OPTIMIZED_POWER
       /*
          power management :
          freeze/wakeup SPDIF clock
       */
	err = write_reg_mask(dev,
			FEAT_POWER_DOWN,
			FEAT_POWER_DOWN_PREFILT,
			(preFilter == HDMITX_VOUT_PREFIL_OFF));
	if (err < 0)
		return err;
#endif
	err = write_reg_mask(dev,
			 HVF_CNTRL_0,
			 HVF_CNTRL_0_PREFIL_MASK,
			 (uint8_t)prefil);
	if (err < 0)
		return err;

	err = write_reg_mask(dev,
			HVF_CNTRL_1,
			HVF_CNTRL_1_YUVBLK,
			(uint8_t)yuvblk);
	if (err < 0)
		return err;

	return 0;
}

int
tda998x_set_vidin_fine(struct tda998x_dev *dev,
		uint8_t subpack_cnt,
		int toggle_clk)
{
	int err;

//#define VIP_CNTRL_3_X_TGL			(1 << 0)
//#define VIP_CNTRL_3_H_TGL			(1 << 1)
//#define VIP_CNTRL_3_V_TGL			(1 << 2)
//#define VIP_CNTRL_3_EMB				(1 << 3)
//#define VIP_CNTRL_3_SP_SYNC_MASK		(0x30U)
//#define VIP_CNTRL_3_DE_INT			(1 << 6)
//#define VIP_CNTRL_3_EDGE			(1 << 7)

//#define VIP_CNTRL_5_CKCASE			(1 << 0)
//#define VIP_CNTRL_5_SP_CNT_MASK			(0x06U)

	err = write_reg_mask(dev,
			VIP_CNTRL_5,
			VIP_CNTRL_5_SP_CNT_MASK,
			subpack_cnt << VIP_CNTRL_5_SP_CNT_SHIFT);

	err = write_reg_mask(dev,
			VIP_CNTRL_3,
			VIP_CNTRL_3_SP_SYNC_MASK,
			(uint8_t)PIXSUBPKT_FIX_3);

	/* IF subpacketCount is Fix at 0/1/2/3 THEN set subpacket count register
	 * to 0/1/2/3 and set subpacket sync register to 3
	 */
	if (subpack_cnt <= 3) {
		err = write_reg_mask(dev,
                                 VIP_CNTRL_5,
                                 VIP_CNTRL_5_SP_CNT_MASK,
                                 subpack_cnt << VIP_CNTRL_5_SP_CNT_SHIFT);
		if (err < 0)
			return err;

		err = write_reg_mask(dev,
                                 VIP_CNTRL_3,
                                 VIP_CNTRL_3_SP_SYNC_MASK,
                                 PIXSUBPKT_FIX_3);
		if (err < 0)
			return err;
	} else {

		/* ELSE IF subpacketCount is Sync by Hemb/ Sync by Rising Edge DE/
		 * Sync by Rising Edge HS THEN set the unused subpacket count to zero and
		 * set subpacket sync register to 0/1/2
		 */
		err = write_reg_mask(dev,
                                 VIP_CNTRL_5,
                                 VIP_CNTRL_5_SP_CNT_MASK,
                                 0);
        	if (err < 0)
        		return err;

//        	typedef enum
//        	{
//        	    HDMITX_PIXSUBPKT_FIX_0      = 0,        /**< Fix At 0 */
//        	    HDMITX_PIXSUBPKT_FIX_1      = 1,        /**< Fix At 1 */
//        	    HDMITX_PIXSUBPKT_FIX_2      = 2,        /**< Fix At 2 */
//        	    HDMITX_PIXSUBPKT_FIX_3      = 3,        /**< Fix At 3 */
//        	    HDMITX_PIXSUBPKT_SYNC_FIRST = 4,        /**< First Sync value */
//        	    HDMITX_PIXSUBPKT_SYNC_HEMB  = 4,        /**< Sync By Hemb */
//        	    HDMITX_PIXSUBPKT_SYNC_DE    = 5,        /**< Sync By Rising Edge DE */
//        	    HDMITX_PIXSUBPKT_SYNC_HS    = 6,        /**< Sync By Rising Edge HS */
//        	    HDMITX_PIXSUBPKT_NO_CHANGE  = 7,        /**< No Change */
//        	    HDMITX_PIXSUBPKT_INVALID    = 8,        /**< Invalid   */
//        	    HDMITX_PIXSUBPKT_SYNC_FIXED = 3         /**< Not used as a parameter value,
//        	                                             *  but used internally when
//        	                                             *  Fix at 0/1/2/3 values are set */
//        	} tmbslHdmiTxPixSubpkt_t;

        	err = write_reg_mask(dev,
                                 VIP_CNTRL_3,
                                 VIP_CNTRL_3_SP_SYNC_MASK,
                                 (uint8_t)(subpack_cnt - 4));
        	if (err < 0)
        		return err;
	}

	err = write_reg_mask(dev,
			 VIP_CNTRL_5,
			 VIP_CNTRL_5_CKCASE,
			 (uint8_t)toggle_clk);
	if (err < 0)
		return err;

	return 0;
}

/**
 * @brief	Is Feature Supported
 */
int
tda998x_feat_is_supported(struct tda998x_dev *dev, enum feat_support feat)
{
	switch (feat) {
	case FEAT_HDCP:
		return !(dev->features & VERSION_NOT_HDCP);
	case FEAT_SCALER:
		return !(dev->features & VERSION_NOT_SCALER);
	case FEAT_AUDIO_OBA: return true;
	case FEAT_AUDIO_DST: return false;
	case FEAT_AUDIO_HBR:
#ifdef HBR_SUPPORT
		return true;
#else
		return false;
#endif
	case FEAT_HDMI_1_1: return true;
	case FEAT_HDMI_1_2A: return true;
	case FEAT_HDMI_1_3A: return false;
	case FEAT_DEEP_COLOR_30: return false;
	case FEAT_DEEP_COLOR_36: return false;
	case FEAT_DEEP_COLOR_48: return false;
	case FEAT_UPSAMPLER: return true;
	case FEAT_DOWNSAMPLER: return true;
	case FEAT_COLOR_CONVERSION: return true;
	default: return false;
	}

	return -1;
}

/**
 * @brief	Set Color Depth
 */
static int
tda998x_set_color_depth(struct tda998x_dev *dev, uint8_t color_depth)
{
	return 0;
}

/**
 * @brief	Set Video In Blanking
 */
static int
tda998x_set_vidin_blanking(struct tda998x_dev *dev,
		enum vip_cntrl_4_blnkit blnk_src,
		enum vip_cntrl_4_blc blnk_code)
{
	if (dev == NULL)
		return -1;

	return write_reg_mask(dev,
			 VIP_CNTRL_4,
			 VIP_CNTRL_4_BLNKIT_MASK | VIP_CNTRL_4_BLC_MASK,
			 (uint8_t)blnk_src | (uint8_t)blnk_code);
}

/**
 * @brief	Set TMDS Outputs
 */
static int
tda998x_set_tmds_outputs(struct tda998x_dev *dev, enum buffer_out_srl_force tmds_out)
{
	if (dev == NULL)
		return -1;

	return write_reg_mask(dev,
			BUFFER_OUT,
			BUFFER_OUT_SRL_FORCE_MASK,
			(uint8_t)tmds_out);
}

static int tda998x_set_tmds_serializer(struct tda998x_dev *dev, uint8_t phase2, uint8_t phase3)
{
    return 0;
}


static int
tda998x_get_refline_refpix(void)
//(
//    tmdlHdmiTxVidFmt_t      vinFmt,
//    tmdlHdmiTxVinMode_t     vinMode,
//    tmdlHdmiTxVidFmt_t      voutFmt,
//    UInt8                   syncIn,
//    tmdlHdmiTxPixRate_t     pixRate,
//    UInt16                  *pRefPix,
//    UInt16                  *pRefLine,
//    UInt16                  *pScRefPix,
//    UInt16                  *pScRefLine,
//    Bool                    *pbVerified
//)
{
//    UInt8 shortVinFmt;
//    UInt8 shortVoutFmt;
//    int i;
//    Bool bFound;
//    tmdlHdmiTxVidFmt_t      vinFmtIndex, voutFmtIndex;
//
//    /* Search for all values to match in table, until table end is reached
//     * when both refPix values are zero */
//    *pRefPix    = 0;
//    *pRefLine   = 0;
//    *pScRefPix  = 0;
//    *pScRefLine = 0;
//
//    /* If match is not found in table, we can assume a verified non-scaler
//     * combination */
//    *pbVerified = 1;
//    bFound = False;
//
//    if ((voutFmt  <  TMDL_HDMITX_VFMT_TV_NO_REG_MIN)
//        || ((voutFmt >= HDMITX_VFMT_35_2880x480p_60Hz) && (voutFmt <= HDMITX_VFMT_38_2880x576p_50Hz)))
//    {
//        vinFmtIndex  = dlHdmiTxCalcVidFmtIndex(vinFmt);
//        voutFmtIndex = dlHdmiTxCalcVidFmtIndex(voutFmt);
//        shortVinFmt  = kVfmtToShortFmt_TV[vinFmtIndex];
//        shortVoutFmt = kVfmtToShortFmt_TV[voutFmtIndex];
//
//        for (i = 0; kRefpixRefline[i].shortVinFmt != TV_INVALID; i++)
//        {
//            if ((kRefpixRefline[i].shortVinFmt == shortVinFmt)
//                &&  (UNPKMODE(kRefpixRefline[i].modeRateSyncVerf) == vinMode)
//                &&  (kRefpixRefline[i].shortVoutFmt == shortVoutFmt)
//                &&  (UNPKRATE(kRefpixRefline[i].modeRateSyncVerf) == pixRate)
//                &&  (UNPKSYNC(kRefpixRefline[i].modeRateSyncVerf) == syncIn))
//            {
//                *pRefPix    = kRefpixRefline[i].refPix;
//                *pRefLine   = kRefpixRefline[i].refLine;
//                *pScRefPix  = kRefpixRefline[i].scRefPix;
//                *pScRefLine = kRefpixRefline[i].scRefLine;
//                *pbVerified = UNPKVERF(kRefpixRefline[i].modeRateSyncVerf);
//                bFound = True;
//                break;
//            }
//        }
//    }
//
//    return bFound;
}

int
tda998x_set_vidout_sync(struct tda998x_dev *dev,
		enum vs_src srcH,
		enum vs_src srcV,
		enum vs_src srcX,
		enum vs_tgl toggle,
		enum vs_fsync fsync)
{
	int err;
	uint8_t reg_idx;
	struct sync_desc *sync;

	/**
	 * @todo Determine method for setting write-only registers when setting
	 * bits/fields withing register.
	 */
	/* For each parameter that is not No Change, set its register */
	if (srcH != VSSRC_NO_CHANGE) {
		err = write_reg_mask(dev,
				TBG_CNTRL_1_W,
				TBG_CNTRL_1_VHX_EXT_HS,
				(uint8_t)srcH);
		if (err < 0)
			return err;
	}

	if (srcV != HDMITX_VSSRC_NO_CHANGE) {
		err = write_reg_mask(dev,
				TBG_CNTRL_1_W,
				TBG_CNTRL_1_VHX_EXT_VS,
				(uint8_t)srcV);
		RETIF_REG_FAIL(err)
	}

	if (srcX != HDMITX_VSSRC_NO_CHANGE) {
		err = write_reg_mask(dev,
				TBG_CNTRL_1_W,
				TBG_CNTRL_1_VHX_EXT_DE,
				(uint8_t)srcX);
		RETIF_REG_FAIL(err)
	}

	/* Hs Vs polarity fix */
	/* set polarity back when VIDFORMAT_TABLE (E_REG_P00_VIDFORMAT_W) is not used */
	RETIF_BADPARAM(reg_vid_fmt(pDis->vinFmt,HDMITX_3D_NONE,&reg_idx,0,&sync));
	//if (EXTRA(reg_idx)) { //FRO EXTRA changed
	if (!(PREFETCH(reg_idx))) {
		toggle=(tmbslHdmiTxVsTgl_t)(TBG_CNTRL_1_vh_tgl &                    \
				(0x04 | sync[BASE(reg_idx)].v_toggle | sync[BASE(reg_idx)].h_toggle));
	}

	if (toggle != HDMITX_VSTGL_NO_CHANGE) {
		err = write_reg_mask(dev,
				TBG_CNTRL_1_W,
				TBG_CNTRL_1_vh_tgl,
				(uint8_t)toggle);
/*         printk("DBG toogl CNTRL1:%d\n",toggle); */
		RETIF_REG_FAIL(err)
	}

	if (once != HDMITX_VSONCE_NO_CHANGE) {
		/* Must be last register set */
		err = write_reg_mask(dev,
				TBG_CNTRL_0_W,
				TBG_CNTRL_0_sync_once,
				(uint8_t)once);
		RETIF_REG_FAIL(err)
	}

	/* Toggle TMDS serialiser force flags - stability fix */
	err = write_reg_mask(dev,
			BUFFER_OUT_RW,
			BUFFER_OUT_srl_force,
			(uint8_t)TMDSOUT_FORCED0);
	RETIF_REG_FAIL(err)

	err = write_reg_mask(dev,
			BUFFER_OUT_RW,
			BUFFER_OUT_srl_force,
			(uint8_t)TMDSOUT_NORMAL);
	RETIF_REG_FAIL(err)

	if (once == HDMITX_VSONCE_ONCE) {
		/* Toggle output Sync Once flag for settings to take effect */
		err = write_reg_mask(dev,
				TBG_CNTRL_0_W,
				TBG_CNTRL_0_sync_once,
				(uint8_t)VSONCE_EACH_FRAME);
		RETIF_REG_FAIL(err)
		err = write_reg_mask(dev,
				TBG_CNTRL_0_W,
				TBG_CNTRL_0_sync_once,
				(uint8_t)VSONCE_ONCE);
		RETIF_REG_FAIL(err)
	}

	return TM_OK;
}

/**
 * @brief	Set Input/Output
 */
int
tda998x_set_inout(struct tda998x_dev *dev,
		struct tda998x_vin_cfg *vin_cfg,
		struct tda998x_vout_cfg *vout_cfg,
		enum tda998x_sink sink)
{
	int err;

	err = tda998x_set_color_depth(dev, false);
	if (err < 0)
		return err;

	/* Set the TMDS outputs to a forced state */
	err = tda998x_set_tmds_outputs(dev, TMDSOUT_FORCED0);
	if (err < 0)
		return err;

	/* Fine-tune the TMDS serializer */
	err = tda998x_set_tmds_serializer(dev, 4, 8);
	if (err < 0)
		return err;

	/* Set video output configuration */
	err = tda998x_set_vidout_config(dev,
			sink,
			vout_cfg->mode,
			PREFIL_OFF,
			YUVBLK_16,
			QRANGE_FS);
	if (err < 0)
		return err;

	/* Set default config */
//	pixRepeat = HDMITX_PIXREP_DEFAULT;
//	pathBits = HDMITX_VOUT_DBITS_12;
//	pixelEdge = HDMITX_PIXEDGE_CLK_POS;
//	syncMethod = HDMITX_VSMETH_V_H;
//	toggle = HDMITX_PIXTOGL_ENABLE;

	/* Set sync details */
	if (vin_cfg.sync_src == SYNCSRC_EMBEDDED) {
		syncIn = EMB;
		spSync = PIXSUBPKT_SYNC_HEMB;
		blankit = BLNKSRC_VS_HEMB_VEMB;
		syncMethod = VSMETH_V_XDE;
	} else {
		syncIn = EXT;
		spSync = PIXSUBPKT_SYNC_DE;	/* DE is available */
		blankit = BLNKSRC_NOT_DE;
	}

	/* Port swap table */
	switch (vin_cfg.mode) {
	case VINMODE_CCIR656:
		break;

	case VINMODE_RGB444:
		swap = &port_map_rgb444[0];
		mirr = &mirr_map_rgb444[0];
		break;

	case VINMODE_YUV444:
		swap = &port_map_rgb444[0];
		mirr = &mirr_map_rgb444[0];
		break;

	case VINMODE_YUV422:
		break;

	default:
		break;
	}

	err = tda998x_set_video_port_enable(dev);
	if (err < 0)
		return err;

	err = tda998x_set_video_port_map(dev, swap, mirr);
	if (err < 0)
		return err;

	/* Set fine image position */
	err = tda998x_set_video_in_fine(dev, spSync, PIXTOGL_NO_ACTION);
	if (err < 0)
		return err;

	/* Set input blanking */
	err = tda998x_set_video_in_blanking(dev, blankit, BLNKCODE_ALL_0);
	if (err < 0)
		return err;

	/* Configure video input options and control the upsampler */
	err = tda998x_set_video_in_config(dev,
			vin_cfg.mode,
			vout_cfg.format,
			vin_cfg.format_3d,
			pixelEdge,
			vin_cfg.pix_rate,
			HDMITX_UPSAMPLE_AUTO);

	/* Set input output - may give NOT_SUPPORTED error */
	err = tda998x_set_inout(dev,
			vin_cfg.format,
			vin_cfg.format_3d,
			HDMITX_SCAMODE_AUTO,
			vout_cfg.format,
			pixRepeat,
			HDMITX_MATMODE_AUTO,
			pathBits,
			vout_cfg.vqr);

	/* Only set audio for HDMI, not DVI */
	if (sinkType == SINK_HDMI) {
		err = tda998x_set_audio_in(dev, ain_cfg, sink);
		if (err < 0)
			return err;
	}

	/* Output fine adjustment */
	pix_rate = vin_cfg.pix_rate;
	if (vin_cfg.pix_rate == HDMITX_PIXRATE_SINGLE_REPEATED)
		pix_rate = HDMITX_PIXRATE_SINGLE;

	if (vin_cfg.format_3d != HDMITX_3D_FRAME_PACKING) {
		err = tda998x_get_refline_refpix(videoInputConfig.format,
					videoInputConfig.mode,
					videoOutputConfig.format,
					syncIn,
					(tmdlHdmiTxPixRate_t)pixRateSingleDouble,
					&uRefPix,
					&uRefLine,
					&uScRefPix,
					&uScRefLine,
					&bVerified);
		if (err > 0){
			/* From 720p50/60 or 1080i50/60 up-scaling to 1080p50/60, when external sync,
			   toggleV, toggleH and toggleX need to be set to 0 */
			if (syncIn == EXT) {
				switch (vin_cfg.format) {
				case VFMT_04_1280x720p_60Hz:
				case VFMT_19_1280x720p_50Hz:
				case VFMT_05_1920x1080i_60Hz:
				case VFMT_20_1920x1080i_50Hz:
					if ((vin_cfg.format == VFMT_16_1920x1080p_60Hz) ||
							(vin_cfg.format == VFMT_31_1920x1080p_50Hz)) {
						toggle = PIXTOGL_NO_ACTION;
					}
					break;

				default:
					toggle = PIXTOGL_ENABLE;
					break;
				}
			}

			/* Combination found in table for scaler: configure input manually */
			err = tmbslHdmiTxVideoInSetSyncManual(instance,
							(tmbslHdmiTxSyncSource_t)videoInputConfig.syncSource,
							syncMethod,
							toggle,
							toggle,
							toggle,
							uRefPix,
							uRefLine);
		}
	} else {
		/* Not found so assume non-scaler and auto-configure input */
		err = tmbslHdmiTxVideoInSetSyncAuto(instance,
						(tmbslHdmiTxSyncSource_t)videoInputConfig.syncSource,
						(tmbslHdmiTxVidFmt_t)videoInputConfig.format,
						(tmbslHdmiTxVinMode_t)videoInputConfig.mode,
						(tmbslHdmiTx3DStructure_t)videoInputConfig.structure3D);
	}

	/* Only set infoframes for HDMI, not DVI */
	if (sinkType == TMDL_HDMITX_SINK_HDMI) {
		/* Set avi infoframe */
		erre = dlHdmiTxSetVideoInfoframe(instance, videoOutputConfig.format, videoOutputConfig.mode);
	}

	err = tmbslHdmiTxScalerGetMode(instance, &scalerMode);

	/* Ignore scaler TMBSL_ERR_HDMI_NOT_SUPPORTED error */
	if ((errCode == TM_OK) && (scalerMode == HDMITX_SCAMODE_ON)) {
		/* Enable scaler mode */
		err = tmbslHdmiTxScalerInDisable(instance, False);

        		/* Correction to interlace */
        		topSel = HDMITX_TOPSEL_INTERNAL;
		if ((videoOutputConfig.format == VFMT_05_1920x1080i_60Hz) ||
				(videoOutputConfig.format == VFMT_20_1920x1080i_50Hz)) {
			/* video input format is range-checked by tmbslHdmiTxVideoSetInOut above */
			vinFmtIndex = dlHdmiTxCalcVidFmtIndex(videoInputConfig.format);
			if ((kVfmtToShortFmt_TV[vinFmtIndex] == TV_480p_60Hz) ||
					(kVfmtToShortFmt_TV[vinFmtIndex] == TV_576p_50Hz)) {
				/* Correct for 1080i output for p->i conversion only */
				topSel = HDMITX_TOPSEL_VRF;
			}
		}

		/* Set scaler field positions */
		err = tmbslHdmiTxScalerSetFieldOrder(instance,
					HDMITX_INTEXT_NO_CHANGE,
					HDMITX_INTEXT_NO_CHANGE,
					topSel,
					HDMITX_TOPTGL_NO_CHANGE);

		/* Scaler fine adjustment */
		err = tmbslHdmiTxScalerSetFine(instance, uScRefPix, uScRefLine);

		if ((vout_cfg.format == VFMT_16_1920x1080p_60Hz) ||
				(vout_cfg.format == VFMT_31_1920x1080p_50Hz)) {
			phasesH = HDMITX_H_PHASES_16;
		} else {
			phasesH = HDMITX_H_PHASES_15;
		}

		/* Set scaler phase */
		err = tmbslHdmiTxScalerSetPhase(instance, phasesH);

		/* Set scaler latency */
		err = tmbslHdmiTxScalerSetLatency(instance, 0x22);

		/* Set scaler synchronisation option */
		err = tmbslHdmiTxScalerSetSync(instance,
					syncMethod,
					HDMITX_VSONCE_EACH_FRAME);

		/* With scaler, use Only Once setting for tmbslHdmiTxVideoOutSetSync */
		once = HDMITX_VSONCE_ONCE;
	} else {
		once = HDMITX_VSONCE_EACH_FRAME;
	}

	/* Set video synchronisation */
	err = tda998x_set_vidout_sync(dev,
			VS_SRC_INTERNAL,
			VS_SRC_INTERNAL,
			VS_SRC_INTERNAL,
			VS_TGL_TABLE,
			once);
	return err;
}

/**
 * @brief	Initialize TDA1998x HDMI Transmitter
 *
 * @param dev:
 * @param cfg:
 * @return 0 on success, error status otherwise
 */
int
tda998x_init(struct tda998x_dev *dev, struct tda998x_vin_cfg *vin_cfg)
{
	int err;
	uint8_t reg_val;

	/* Reset ENAMODS */
	err = cec_write_reg(dev, ENAMODS, 0x40);
	if (err < 0)
		return err;

	/* Enable HDMI and RX sense and FRO */
	err = cec_write_reg_mask(dev,
			ENAMODS,
			ENAMODS_ENA_HDMI | ENAMODS_ENA_RXS | ENAMODS_DIS_FRO,
			ENAMODS_ENA_HDMI | ENAMODS_ENA_RXS);
	if (err < 0)
		return err;

	/**
	 * Reset device
	 */
	err = write_reg_mask(dev,
			SR_REG,
			SR_REG_SR_I2C_MS | SR_REG_SR_AUDIO,
			SR_REG_SR_I2C_MS | SR_REG_SR_AUDIO);
	if (err < 0)
		return err;

//	pDis->sysFuncTimer(50); /* ms */

	err = write_reg_mask(dev,
			SR_REG,
			SR_REG_SR_I2C_MS | SR_REG_SR_AUDIO,
			0);
	if (err < 0)
		return err;

	/* Soft reset */
	err = write_reg_mask(dev,
			MAIN_CNTRL0,
			MAIN_CNTRL0_SR,
			MAIN_CNTRL0_SR);
	if (err < 0)
		return err;

	/* pDis->sysFuncTimer(50); */ /* ms */

	err = write_reg_mask(dev,
			MAIN_CNTRL0,
			MAIN_CNTRL0_SR,
			0);
	if (err < 0)
		return err;

	/* pDis->sysFuncTimer(50); */ /* ms */

	/* Clear color bars */
	err = write_reg_mask(dev,
			HVF_CNTRL_0,
			HVF_CNTRL_0_SM,
			0);
	if (err < 0)
		return err;

	/*
	 * Read the device version registers
	 */
	err = read_reg(dev, VERSION, &reg_val);
	if (err < 0)
		return err;

	dev->version = reg_val;

	/* Version MSB value */
	err = read_reg(dev, VERSION_MSB, &reg_val);
	if (err < 0)
		return err;

	dev->version |= (uint16_t)reg_val << 8;

	err = write_reg(dev, ANA_GENERAL, 0x09U);	/** VSWING default value */
	if (err < 0)
		return err;

	/* Set the PLL before resetting the device */
	err = write_reg_table(dev, &pll_cfg_common[0]);
	if (err < 0)
		return err;

	err = write_reg_mask(dev,
			VIP_CNTRL_4,
			VIP_CNTRL_4_656_ALT,
			0);
	if (err < 0)
		return err;

	switch (vin_cfg->format) {
	case VFMT_06_720x480i_60Hz:
	case VFMT_07_720x480i_60Hz:
	case VFMT_21_720x576i_50Hz:
	case VFMT_22_720x576i_50Hz:
		err = write_reg_table(dev, &pll_cfg_480ix576i[0]);
		if (err < 0)
			return err;

		switch (vin_cfg->pix_rate) {
		case PIXRATE_SINGLE:
			/* Single edge mode, vinFmt 480i or 576i */
			err = write_reg(dev, PLL_SCG2, 0x11);
			if (err < 0)
				return err;
			break;

		case PIXRATE_SINGLE_REPEATED:
			/* Single repeated edge mode, vinFmt 480i or 576i */
			err = write_reg(dev, PLL_SCG2, 0x01);
			if (err < 0)
				return err;
			break;

		default:
			/* Invalid pixel rate */
			return -1;
		}
		break;

	default:
		err = write_reg_table(dev, &pll_cfg_other[0]);
		if (err < 0)
			return err;

		switch (vin_cfg->pix_rate) {
		case PIXRATE_SINGLE:
			/* Single edge mode, (format other than 480i or 576i) */
			err = write_reg(dev, PLL_SCG2, 0x10);
			if (err < 0)
				return err;
			break;

		case PIXRATE_DOUBLE:
			/* Double edge mode (format other than 480i or 576i) */
			err = write_reg(dev, PLL_SCG2, 0x00);
			if (err < 0)
				return err;
			break;

		default:
			/* Single repeated edge mode doesn't exist for other vinFmt */
			return -1;
		}
		break;
	}

	/* DDC interface is disable for TDA9989 after reset, enable it */
	err = write_reg(dev, DDC_DISABLE, 0x00);
	if (err < 0)
		return err;

	/* Set DDC channel clock speed */
	err = write_reg(dev, OTP_TX3, DDC_SPEED_FACTOR);
	if (err < 0)
		return err;

	/* TDA19989 N1 only */
//	if (version == VERSION_TDA19989) {
//		/* 0: enable multi master mode */
//		err = write_reg_mask(dev,
//				I2C_MASTER,
//				I2C_MASTER_DIS_MM,
//				0);
//		if (err < 0)
//			return err;
//	}

	err = cec_write_reg(dev,
			FRO_IM_CLK_CTRL,
			FRO_IM_CLK_CTRL_IMCLK_SEL | FRO_IM_CLK_CTRL_GHOST_DIS);
	if (err < 0)
		return err;

	/* enable  sw _interrupt and  VS_interrupt for debug */
	err = write_reg(dev, INT_FLAGS_1, INT_FLAGS_1_SW_INT);
	if (err < 0)
		return err;

	/* enable edid read */
	err = write_reg(dev, INT_FLAGS_2, INT_FLAGS_2_EDID_BLK_RD);
	if (err < 0)
		return err;

	/* Read HPD RXS level */
	err = cec_read_reg(dev, RXSHPDLEV, &reg_val);
	if (err < 0)
		return err;

	/* Read Hot Plug input status to know the actual level that caused the interrupt */
//	pDis->hotPlugStatus = (regVal & RXSHPDLEV_HPD_LEVEL) ?
//		HDMITX_HOTPLUG_ACTIVE : HDMITX_HOTPLUG_INACTIVE;

	/*Read RXS_FIL status to know the actual level that caused the interrupt */
//	pDis->rxSenseStatus = (regVal & RXSHPDLEV_RXS_LEVEL) ?
//		 HDMITX_RX_SENSE_ACTIVE : HDMITX_RX_SENSE_INACTIVE;

	err = cec_write_reg_mask(dev,
			RXSHPDINTENA,
			RXSHPDINTENA_ENA_RXS_INT | RXSHPDINTENA_ENA_HPD_INT,
			RXSHPDINTENA_ENA_RXS_INT | RXSHPDINTENA_ENA_HPD_INT);
	if (err < 0)
		return err;

	err = cec_read_reg(dev, RXSHPDLEV, &reg_val);
	if (err < 0)
		return err;

	/* Start by forcing the TMDS ouputs off */
	err = tda998x_set_tmds_outputs(dev, TMDSOUT_FORCED0);
	if (err < 0)
		return err;

	return (0);
}



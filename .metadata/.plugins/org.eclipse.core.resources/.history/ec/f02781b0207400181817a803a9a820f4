/**
 *******************************************************************************
 *******************************************************************************
 *
 * @file    tda1997x.c
 * @author  R. Bush
 * @email   bush@krtkl.com
 * @version v1.0
 * @date    2017 September 14
 * @brief   TDA1997x HDMI Receiver
 * @license FreeBSD
 *
 *******************************************************************************
 *
 * Copyright (c) 2017, krtkl inc.
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 * 1. Redistributions of source code must retain the above copyright notice,
 *    this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright notice,
 *    this list of conditions and the following disclaimer in the documentation
 *    and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
 * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
 * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
 * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
 * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
 * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
 * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
 * POSSIBILITY OF SUCH DAMAGE.
 *
 * The views and conclusions contained in the software and documentation are
 * those of the authors and should not be interpreted as representing official
 * policies, either expressed or implied, of the FreeBSD Project.
 *
 *******************************************************************************
 */

#include <stdio.h>
#include <stdint.h>
#include <unistd.h>

#include "tda1997x.h"


//static struct tda1997x_irq_event sus_events[NIRQ_SOURCE_FLAGS] = {
//	{
//		.irq = IRQ_SUS_STATE,
//		.en = 0,
//		.callback = NULL
//	},
//	{
//		.irq = IRQ_SUS_INPUT,
//		.en = 0,
//		.callback = NULL
//	}
//};
//
//static struct tda1997x_irq_event ddc_events[NIRQ_SOURCE_FLAGS] = {
//};
//
//static struct tda1997x_irq_event rate_events[NIRQ_SOURCE_FLAGS] = {
//};
//
//static struct tda1997x_irq_event mode_events[NIRQ_SOURCE_FLAGS] = {
//};
//
//static struct tda1997x_irq_event info_events[NIRQ_SOURCE_FLAGS] = {
//};
//
//static struct tda1997x_irq_event audio_events[NIRQ_SOURCE_FLAGS] = {
//};
//
//static struct tda1997x_irq_event hdcp_events[NIRQ_SOURCE_FLAGS] = {
//};
//
//static struct tda1997x_irq_event afe_events[NIRQ_SOURCE_FLAGS] = {
//};
//
//
///* This should get updated when enabling and disabling events */
//static struct tda1997x_irq_source irq_sources[NIRQ_TOP_FLAGS] = {
//	{ (uint16_t)IRQ_FLG_CLR_SUS,	(uint16_t)IRQ_MASK_SUS,		sus_events },
//	{ (uint16_t)IRQ_FLG_CLR_DDC,	(uint16_t)IRQ_MASK_DDC,		ddc_events },
//	{ (uint16_t)IRQ_FLG_CLR_RATE,	(uint16_t)IRQ_MASK_RATE,	rate_events },
//	{ (uint16_t)IRQ_FLG_CLR_MODE,	(uint16_t)IRQ_MASK_MODE,	mode_events },
//	{ (uint16_t)IRQ_FLG_CLR_INFO, 	(uint16_t)IRQ_MASK_INFO,	info_events },
//	{ (uint16_t)IRQ_FLG_CLR_AUDIO,	(uint16_t)IRQ_MASK_AUDIO,	audio_events },
//	{ (uint16_t)IRQ_FLG_CLR_HDCP,	(uint16_t)IRQ_MASK_HDCP,	hdcp_events },
//	{ (uint16_t)IRQ_FLG_CLR_AFE,	(uint16_t)IRQ_MASK_AFE,		afe_events },
//};


#ifdef DEBUG
static const char *audio_freq[] = {
	"NO CHANGE",
	"32k Hz",
	"44.1 kHz",
	"48 kHz",
	"88.2 kHz",
	"96 kHz",
	"176 kHz",
	"192 kHz"
};
#endif

static uint8_t vp_conf444[9] = {
	VP_CTRL_RED_MSB,			/* [23:20] */
	VP_CTRL_RED_ISB,			/* [19:16] */
	VP_CTRL_LOZ,				/* Not used */
	VP_CTRL_GREEN_MSB,			/* [15:12] */
	VP_CTRL_GREEN_ISB,			/* [11:8] */
	VP_CTRL_LOZ,				/* Not used */
	VP_CTRL_BLUE_MSB,			/* [7:4] */
	VP_CTRL_BLUE_ISB,			/* [3:0] */
	VP_CTRL_LOZ,				/* Not used */
};


//static uint8_t vp_conf422[9] = {
//	VP_CTRL_HIZ,				/* [23:20] */
//	VP_CTRL_Y_MSB,				/* [19:16] */
//	VP_CTRL_LOZ,				/* Not used */
//	VP_CTRL_Y_ISB,				/* [15:12] */
//	VP_CTRL_CBCR_MSB,			/* [11:8] */
//	VP_CTRL_LOZ,				/* Not used */
//	VP_CTRL_CBCR_ISB,			/* [7:4] */
//	VP_CTRL_HIZ,				/* [3:0] */
//	VP_CTRL_LOZ,				/* Not used */
//};

static uint8_t vp_conf_mute[9] = {
	VP_CTRL_HIZ,				/* [23:20] */
	VP_CTRL_HIZ,				/* [19:16] */
	VP_CTRL_LOZ,				/* Not used */
	VP_CTRL_HIZ,				/* [15:12] */
	VP_CTRL_HIZ,				/* [11:8] */
	VP_CTRL_LOZ,				/* Not used */
	VP_CTRL_HIZ,				/* [7:4] */
	VP_CTRL_HIZ,				/* [3:0] */
	VP_CTRL_LOZ,				/* Not used */
};

static uint8_t blank_rgb[6] = {
	0x00,
	0x40,
	0x00,
	0x40,
	0x00,
	0x40
};

static uint8_t blank_yuv[6] = {
	0x00,
	0x40,
	0x02,
	0x00,
	0x02,
	0x00
};

static int16_t color_conv444[COLOR_CONV_MATRIX_LENGTH] = {
	-256,	-2048,	-2048,			/*Input Offset*/
	4096,	-2860,	-1378,			/*Matrix:ITU-601 YCbCr limited range =>  RGB limited range */
	4096,	5615,	0,
	4096,	0,	7097,
	256,	256,	256			/*Output Offset*/
 };

static uint8_t clk_rate[6] = {
	0x00,
	0x57,
	0xE4,
	0x03,
	0x95,
	0xF8
};

const struct tda1997x_mtp_seed hdcp_seed_tab[TDA1997X_SEED_TABLE_LEN] = {
	{ 0xF0,	0x1234 },
	{ 0xF1,	0xDBE6 },
	{ 0xF2,	0xDBE6 },
	{ 0,	0x1234 },
	{ 0,	0 },
	{ 0,	0 },
	{ 0,	0 },
	{ 0,	0 },
	{ 0,	0 },
	{ 0,	0 }
};


/**
 * @brief	EDID block
 */
static uint8_t edid_block[127] = {
	0x00,	0xFF,	0xFF,	0xFF,	0xFF,	0xFF,	0xFF,	0x00,			/* Fixed header */
	0x3B,	0x10,									/* Manufacturer ID */
	0x03,	0x4E,									/* Manufacturer product code */
	0x01,	0x00,	0x00,	0x00,							/* Serial number */
	0x30,	0x15,									/* Manufacture week/year */
	0x01,	0x03,									/* EDID version */
	0x80,										/* Video input parameters */
	0x00,										/* Maximum horizontal size */
	0x00,										/* Maximum vertical size */
	0x00,										/* Display gamma */
	0x1A,										/* Supported features */
	0xEE,	0x95,	0xA3,	0x54,	0x4C,	0x99,	0x26,	0x0F,	0x50,	0x54,	/* Chromaticity coordinates */
	0x20,	0x00,	0x00,								/* Established timing */
	0x01,	0x01,	0x01,	0x01,	0x01,	0x01,	0x01,	0x01,			/* Standard timing information */
	0x01,	0x01,	0x01,	0x01,	0x01,	0x01,	0x01,	0x01,			/* Standard timing information (cont.) */
	0x02,	0x3A,	0x80,	0x18,	0x71,	0x38,	0x2D,	0x40,	0x58,		/* Timing descriptor */
	0x2C,	0x45,	0x00,	0xC4,	0x8E,	0x21,	0x00,	0x00,	0x1E,		/* Timing descriptor (cont.) */
	0x00,	0x00,	0x00,	0xFC,	0x00,	0x70,	0x69,	0x53,	0x6d,		/* Monitor name descriptor */
	0x61,	0x73,	0x68,	0x65,	0x72,	0x0a,	0x20,	0x20,	0x20,		/* Monitor name descriptor (cont.) */
	0x00,	0x00,	0x00,	0xFD,	0x00,	0x32,	0x3C,	0x0F,	0x44,		/* Range limits descriptor */
	0x0F,	0x00,	0x0A,	0x20,	0x20,	0x20,	0x20,	0x20,	0x20,		/* Range limits descriptor (cont.) */
	0x00,	0x00,	0x00,	0xFE,	0x00,	0x31,	0x30,	0x38,	0x30,		/* Unspecified text descriptor */
	0x70,	0x44,	0x43,	0x78,	0x76,	0x43,	0x33,	0x44,	0x0A,		/* Unspecified text descriptor (cont.) */
	0x01,										/* Extensions to follow */
};


/**
 * @brief	EDID extension block
 */
static uint8_t edid_ext[127] = {
	0x02,	0x03,								/* Extension tag and version */
	0x30,									/* DTD offset */
	0xF0,									/* Global declarations */
	0x70,									/* Vendor specific data */
	0x03,	0x0C,	0x00,							/* IEEE registration identifier */
	0x00,	0x00,								/* SPA AB CD */
	0xB8,
	0x21,									/* Max TMDS frequency (165 MHz) */
	0x00,									/* Latency field present */
	0xA0,	0x06,	0x01,	0x40,						/* Latency values */
	0x30,	0x40,	0x60,	0x70,
	0x83,	0x01,	0x00,	0x00,						/* Speaker allocation */
	0xE3,	0x05,	0x1F,	0x01,						/* Coloremitry data block */
	0x4E,									/* Video data block */
	0x10,									/* 1920x1080p @ 60 Hz */
	0x1F,									/* 1920x1080p @ 50 Hz */
	0x20,									/* 1920x1080p @ 24 Hz */
	0x22,									/* 1920x1080p @ 30 Hz */
	0x21,									/* 1920x1080p @ 25 Hz */
	0x04,									/* 1280x720p @ 60 Hz */
	0x13,									/* 1280x720p @ 50 Hz */
	0x03,									/* 720x480p @ 60 Hz */
	0x12,									/* 720x576p @ 50 Hz */
	0x05,									/* 1920x1080i @ 60 Hz */
	0x14,									/* 1920x1080i @ 50 Hz */
	0x07,									/* 720x480i @ 60 Hz */
	0x16,									/* 720x576i @ 50 Hz */
	0x01,									/* 640x480p @ 60 Hz */
	0x23,	0x09,	0x07,	0x07,						/* Audio data block */
	0x02,	0x3A,	0x80,	0xD0,	0x72,	0x38,	0x2D,	0x40,	0x10,	/* DTD (148.5 MHz) */
	0x2C,	0x45,	0x80,	0xC4,	0x8E,	0x21,	0x00,	0x00,	0x1E,
	0x01,	0x1D,	0x80,	0x3E,	0x73,	0x38,	0x2D,	0x40,	0x7E,	/* DTD (74.25 MHz) */
	0x2C,	0x45,	0x80,	0xC4,	0x8E,	0x21,	0x00,	0x00,	0x1E,
	0x01,	0x1D,	0x80,	0x18,	0x71,	0x38,	0x2D,	0x40,	0x58,	/* DTD (74.25 MHz) */
	0x2C,	0x45,	0x00,	0xC4,	0x8E,	0x21,	0x00,	0x00,	0x1E,
	0x01,	0x1D,	0x80,	0xD0,	0x72,	0x38,	0x2D,	0x40,	0x10,	/* DTD (74.25 MHz) */
	0x2C,	0x45,	0x80,	0xC4,	0x8E,	0x21,	0x00,	0x00,	0x1E,
	0x00,	0x00,	0x00,	0x00,	0x00,	0x00,	0x00,			/* Padding */
};

static uint8_t ddc_config[8] = {
	0x19,						/* EDID_VERSION */
	0x41,						/* EDID_ENABLE */
	0x44,						/* EDID_BLOCK_SELECT */
	0x00,						/* empty */
	0x04,						/* HPD_POWER */
	0x08,						/* HPD_AUTO_CTRL */
	0x00,						/* HPD_DURATION */
	0x00						/* RX_HPD_HEAC */
};


static uint8_t rt_config[6] = {
	0x78,						/* RT_AUTO_CTRL */
	0x03,						/* EQ_MAN_CTRL0 */
	0x33,						/* EQ_MAN_CTRL1 */
	0xF0,						/* OUTPUT_CFG */
	0x00,						/* MUTE_CTRL */
	0x00						/* SLAVE_ADDR */
};


static uint16_t spa_edid[2] = {
	0x0100,
	0x0000,
};


/**
 * @brief	Write Data
 *
 * @param	dev:	TDA1997X device structure pointer
 * @param	reg:	Start register and page address
 * @param	len:	Length of data to write to device
 * @param	data:	Pointer to data to write from
 * @return	Number of bytes written or less-than-zero error status
 */
static int tda1997x_write(struct tda1997x_dev *dev, enum tda1997x_hdmi_reg reg, uint8_t len, uint8_t *data)
{
	int i, err;
	struct tda1997x_cfg *cfg = dev->cfg;
	uint8_t page = (uint8_t)PAGE_OF(reg);

	if (dev->cur_page != (enum tda1997x_page)page) {
		/* Change the page */
		err = cfg->i2c_write(cfg->i2c_addr, (uint8_t)CURPAGE, &page);
		if (err < 0) {
			printf("[ERROR] %s() %s %d - writing page %02x (%d)\n", __func__, __FILE__, __LINE__, page, err);
			return err;
		}

		dev->cur_page = (enum tda1997x_page)page;
	}

	for (i = 0; i < len; i++, data++) {
		err = cfg->i2c_write(cfg->i2c_addr, (uint8_t)reg + i, data);
		if (err < 0) {
			printf("[ERROR] %s() %s %d\n", __func__, __FILE__, __LINE__);
			return err;
		}
	}

	return i;
}


/**
 * @brief	Write Register
 *
 * @param	dev:	TDA1997X device structure pointer
 * @param	reg:	Register and page address
 * @param	data:	Data value to write to register
 * @return	Number of bytes written or less-than-zero error status
 */
static int tda1997x_write_reg(struct tda1997x_dev *dev, enum tda1997x_hdmi_reg reg, uint8_t data)
{
	uint8_t tmp = data;

	return tda1997x_write(dev, reg, 1, &tmp);
}


/**
 * @brief	Read Data
 *
 * @param	dev:	TDA1997X device structure pointer
 * @param	reg:	Start register and page address
 * @param	len:	Length of data to read from device
 * @param	data:	Pointer to data to read to
 * @return	Number of bytes read or less-than-zero error status
 */
static int tda1997x_read(struct tda1997x_dev *dev, enum tda1997x_hdmi_reg reg, uint8_t len, uint8_t *data)
{
	int i, err;
	struct tda1997x_cfg *cfg = dev->cfg;
	uint8_t page = (uint8_t)PAGE_OF(reg);

	if (dev->cur_page != (enum tda1997x_page)page) {
		/* Change the page */
		err = cfg->i2c_write(cfg->i2c_addr, (uint8_t)CURPAGE, &page);
		if (err < 0)
			return err;

		dev->cur_page = (enum tda1997x_page)page;
	}

	for (i = 0; i < len; i++, data++) {
		err = cfg->i2c_read(cfg->i2c_addr, (uint8_t)reg + i, data);
		if (err < 0)
			return err;
	}

	return i;
}


/**
 * @brief	Read Register
 *
 * @param	dev:	TDA1997X device structure pointer
 * @param	reg:	Register and page address
 * @param	data:	Pointer to data to read to
 * @return	Number of bytes read or less-than-zero error status
 */
static int tda1997x_read_reg(struct tda1997x_dev *dev, enum tda1997x_hdmi_reg reg, uint8_t *data)
{
	return tda1997x_read(dev, reg, 1, data);;
}


/**
 * @brief	Register Mask Write
 * 		Write a specified value with specified mask bits to a register
 *
 * @param	dev:	TDA1997X device structure pointer
 * @param	reg:	Register and page address
 * @param	mask:	Mask of bits to be transformed
 * @param	val:	Bitfield to be written within mask
 * @return	Number of bytes written or less-than-zero error status
 */
static int tda1997x_mask_write_reg(struct tda1997x_dev *dev, enum tda1997x_hdmi_reg reg, uint8_t mask, uint8_t val)
{
	int err;
	uint8_t reg_val;

	err = tda1997x_read_reg(dev, reg, &reg_val);
	if (err < 0)
		return err;

	reg_val &= ~(mask);
	reg_val |= val & mask;

	return tda1997x_write_reg(dev, reg, reg_val);
}


/**
 * @brief	CEC Write Data
 *
 * @param	dev:	TDA1997X device structure pointer
 * @param	reg:	Start register and page address
 * @param	len:	Length of data to write to device
 * @param	data:	Pointer to data to write from
 * @return	0 on success, non-zero error status otherwise
 */
static int tda1997x_cec_write(struct tda1997x_dev *dev, enum tda1997x_cec_reg reg, uint8_t len, uint8_t *data)
{
	int i, err;
	struct tda1997x_cfg *cfg = dev->cfg;

	for (i = 0; i < len; i++, data++) {
		err = cfg->i2c_write(cfg->cec_addr, (uint8_t)reg + i, data);
		if (err < 0)
			return err;
	}

	return i;
}


/**
 * @brief	CEC Write Register
 *
 * @param	dev:	TDA1997X device structure pointer
 * @param	reg:	Register and page address
 * @param	data:	Data value to write to register
 * @return	0 on success, non-zero error status otherwise
 */
static int tda1997x_cec_write_reg(struct tda1997x_dev *dev, enum tda1997x_cec_reg reg, uint8_t data)
{
	uint8_t tmp = data;

	return tda1997x_cec_write(dev, reg, 1, &tmp);
}


/**
 * @brief	CEC Read Data
 *
 * @param	dev:	TDA1997X device structure pointer
 * @param	reg:	Start register and page address
 * @param	len:	Length of data to read from device
 * @param	data:	Pointer to data to read to
 * @return	0 on success, non-zero error status otherwise
 */
static int tda1997x_cec_read(struct tda1997x_dev *dev, enum tda1997x_cec_reg reg, uint8_t len, uint8_t *data)
{
	int i, err;
	struct tda1997x_cfg *cfg = dev->cfg;

	for (i = 0; i < len; i++, data++) {
		err = cfg->i2c_read(cfg->cec_addr, (uint8_t)reg + i, data);
		if (err < 0)
			return err;
	}

	return i;
}


/**
 * @brief	CEC Read Register
 *
 * @param	dev:	TDA1997X device structure pointer
 * @param	reg:	Register and page address
 * @param	data:	Pointer to data to read to
 * @return	0 on success, non-zero error status otherwise
 */
static int tda1997x_cec_read_reg(struct tda1997x_dev *dev, enum tda1997x_cec_reg reg, uint8_t *data)
{
	return tda1997x_cec_read(dev, reg, 1, data);;
}


/**
 * @brief	CEC Register Mask Write
 *		Write a specified value with specified mask bits to a register
 *
 * @param	dev:	TDA1997X device structure pointer
 * @param	reg:	Register and page address
 * @param	mask:	Mask of bits to be transformed
 * @param	val:	Bitfield to be written within mask
 * @return	0 on success, non-zero error status otherwise
 */
static int tda1997x_cec_mask_write_reg(struct tda1997x_dev *dev, enum tda1997x_cec_reg reg, uint8_t mask, uint8_t val)
{
	int err;
	uint8_t reg_val;

	err = tda1997x_cec_read_reg(dev, reg, &reg_val);
	if (err < 0)
		return err;

	reg_val &= ~(mask);
	reg_val |= val & mask;

	return tda1997x_cec_write_reg(dev, reg, reg_val);
}





/**
 * @brief	Clear Interrupt Register
 *
 * @param	dev:	TDA1997X device structure pointer
 * @param	reg:	Register to clear
 * @param	val:	Pointer to data to write from register
 * @return	0 on success, non-zero error status otherwise
 */
int tda1997x_clear_irq(struct tda1997x_dev *dev, enum tda1997x_hdmi_reg reg, uint8_t *val)
{
	int err;
	uint8_t tmp;

	err = tda1997x_read_reg(dev, reg, &tmp);
	if (err < 0)
		return err;

	err = tda1997x_write_reg(dev, reg, tmp);
	if (err < 0)
		return err;

	*val = tmp;

	return (0);
}


/**
 * @brief	Software Reset
 *
 * @param	dev:	TDA1997X device structure pointer
 * @param	rst:	Reset (> 0) or enable (0)
 * @return	0 on success, non-zero error status otherwise
 */
int tda1997x_soft_rst(struct tda1997x_dev *dev, uint8_t rst)
{
	return tda1997x_write_reg(dev, HDMI_SOFT_RST, rst);
}


/**
 * @brief	Infoframe Reset
 *
 * @param	dev:		TDA1997X device structure pointer
 * @param	info_rst:	Infoframe reset bitfield
 * @param	sus_en:		Start up sequence enabled
 * @return	0 on success, non-zero error status otherwise
 */
int tda1997x_info_rst(struct tda1997x_dev *dev, uint8_t rst)
{
	int err;
	uint8_t reg_val;

	err = tda1997x_mask_write_reg(dev, HDMI_INFO_RST, rst, rst);
	if (err < 0)
		return err;

	err = tda1997x_mask_write_reg(dev, HDMI_INFO_RST, rst, 0);
	if (err < 0)
		return err;

	/* Clear interrupts if infoframes have been reset */
	if (rst & INFO_RST_INFOFRAME) {
		err = tda1997x_clear_irq(dev, IRQ_FLG_CLR_MODE, &reg_val);
		if (err < 0)
			return err;
	}

	return (0);
}


/**
 * @brief	Enable Startup Sequence
 *
 * @param	dev:	TDA1997x device structure pointer
 * @param	en:		Enable (> 0) or disable (0)
 * @return	0 on success, non-zero error status otherwise
 */
static int tda1997x_sus_en(struct tda1997x_dev *dev, uint8_t en)
{
	if (en)
		return tda1997x_mask_write_reg(dev, RATE_CTRL, SUS_ENABLE, SUS_ENABLE);
	else
		return tda1997x_mask_write_reg(dev, RATE_CTRL, SUS_ENABLE, 0);
}


/**
 * @brief	Configure Video Port
 *
 * @param	dev:		TDA1997X device structure pointer
 * @param	vp_conf:	Pointer to array of video port control values
 * @return	0 on success, non-zero error status otherwise
 */
int tda1997x_cfg_vp(struct tda1997x_dev *dev, uint8_t *vp_conf)
{
	return tda1997x_write(dev, VP35_32_CTRL, 9, vp_conf);
}


/**
 * @brief	Configure Colorspace Conversion
 *
 * @param	dev:		TDA1997X device structure pointer
 * @param	mtx:		Pointer to start of conversion matrix or NULL for bypass
 * @return 	0 on success, non-zero error status otherwise
 */
int tda1997x_cfg_conv(struct tda1997x_dev *dev, int16_t *mtx)
{
	int err;
	uint8_t i;
	uint8_t reg_val[30];

	/* Matrix bypass if called with NULL */
	if (mtx == NULL)
		return tda1997x_mask_write_reg(dev, VDP_CTRL, VDP_CTRL_MATRIX_BYPASS, VDP_CTRL_MATRIX_BYPASS);

	/* Turn off matrix bypass before setting the matrix coefficients */
	err = tda1997x_mask_write_reg(dev, VDP_CTRL, VDP_CTRL_MATRIX_BYPASS, 0);
	if (err < 0)
		return err;

	for (i = 0; i < 15; i++, mtx++) {
		reg_val[2 * i] = (uint8_t)((uint16_t)(*mtx) >> 8);		/* coeff MSB register */
		reg_val[(2 * i) + 1] = (uint8_t)((uint16_t)(*mtx) & 0x00FF);	/* coeff LSB register */
	}

//	err = tda1997x_write(dev, MAT_OI1_MSB, 0x30, reg_val);
//	if (err < 0)
//		return err;

	return (0);
}


/**
 * @brief	Configure Video Output Format
 *
 * @param	dev:	TDA1997X device structure pointer
 * @return	0 on success, non-zero error code otherwise
 */
int tda1997x_cfg_vid_out(struct tda1997x_dev *dev)
{
	int err;

	/* Bypass formatter (not needed in RGB444 with no blanking or timing ref) */
	err = tda1997x_mask_write_reg(dev, VDP_CTRL, VDP_CTRL_FORMATTER_BYPASS, VDP_CTRL_FORMATTER_BYPASS);
	if (err < 0)
		return err;

	/* Configure color space conversion (bypass) */
	err = tda1997x_cfg_conv(dev, color_conv444);
	if (err < 0)
		return err;

	/* Set blanking codes */
	err = tda1997x_write(dev, BLK_GY_MSB, 6, blank_rgb);
	if (err < 0)
		return err;

	/* Configure pixel repeater */
	err = tda1997x_mask_write_reg(dev, PIX_REPEAT, PIX_REPEAT_UP_SEL_MASK, (uint8_t)PIX_REPEAT_UP_SEL_REPEATCHROMA);
	if (err < 0)
		return err;

	err = tda1997x_mask_write_reg(dev, PIX_REPEAT, PIX_REPEAT_PIX_REP_MASK, 0);
	if (err < 0)
		return err;

	/* Configure prefilter */
	err = tda1997x_cfg_prefilter(dev, FILTERS_CTRL_PREFILTER_OFF, FILTERS_CTRL_PREFILTER_OFF);
	if (err < 0)
		return err;

	/* Configure video output */
	err = tda1997x_mask_write_reg(dev,
					OF_CTRL,
					OF_CTRL_BLANKING_INSERT |
					OF_CTRL_TIMINGREF_INSERT |
					OF_CTRL_FORMAT_MASK,
					OF_CTRL_TIMINGREF_INSERT | (uint8_t)OF_CTRL_FORMAT_444);
	if (err < 0)
		return err;

	err = tda1997x_write_reg(dev, VHREF_CTRL, 0x16);
	if (err < 0)
		return err;

	/* Configure pixel clock generator and delay */
	err = tda1997x_write_reg(dev, CLKOUT_CTRL, 0x30);
	if (err < 0)
		return err;

	/* Configure DE output signal */
	err = tda1997x_write_reg(dev, DE_FREF_SEL, 0x82);
	if (err < 0)
		return err;

	/* Configure HS output signal */
	err = tda1997x_write_reg(dev, HS_HREF_SEL, 0x82);
	if (err < 0)
		return err;

	/* Configure VS output signal */
	err = tda1997x_write_reg(dev, VS_VREF_SEL, 0x82);
	if (err < 0)
		return err;

	return (0);
}


/**
 * @brief	Configure Prefilter
 *
 * @param	dev:		TDA1997X device structure pointer
 * @param	bu:		B/Cb channel prefilter configuration
 * @param	rv:		R/Cr channel prefilter configuration
 * @return	0 on success, non-zero error status otherwise
 */
int tda1997x_cfg_prefilter(struct tda1997x_dev *dev, enum tda1997x_filters_ctrl_prefil bu, enum tda1997x_filters_ctrl_prefil rv)
{
	int err;
	uint8_t reg_val = ((uint8_t)bu << 2) | ((uint8_t)rv);

	/* Configure prefilter */
	err = tda1997x_write_reg(dev, FILTERS_CTRL, reg_val);
	if (err < 0)
		return err;

	if ((bu == FILTERS_CTRL_PREFILTER_OFF) && (rv == FILTERS_CTRL_PREFILTER_OFF))
		reg_val = VDP_CTRL_PREFILTER_BYPASS;
	else
		reg_val = 0;

	/* Set or clear prefilter bypass bit */
	err = tda1997x_mask_write_reg(dev, VDP_CTRL, VDP_CTRL_PREFILTER_BYPASS, reg_val);
	if (err < 0)
		return err;

	return (0);
}


/**
 * @brief	Configure Audio Format
 *
 * @param	dev:	TDA1997X device structure pointer
 * @return	0 on success, non-zero error status otherwise
 */
int tda1997x_cfg_audio_fmt(struct tda1997x_dev *dev)
{
	int err;
	uint8_t reg_val;

	/**
	 * BEGIN: Configure Audio Formatter
	 */
	/* Configure audio path */
	err = tda1997x_write_reg(dev, AUDIO_PATH, 0x01);
	if (err < 0)
		return err;

	/* Configure audio layout */
	err = tda1997x_write_reg(dev, AUDIO_LAYOUT, AUDIO_LAYOUT_SP_FLAG);
	if (err < 0)
		return err;

	/* Configure FIFO latency */
	err = tda1997x_write_reg(dev, FIFO_LATENCY_VALUE, 0x80U);
	if (err < 0)
		return err;

	/**
	 * Configure FIFO control for audio
	 * @todo Determine the correct register setting for FIFO_LATENCY_CTRL
	 * that will eliminate glitches and interruptions in audio stream
	 */
	err = tda1997x_write_reg(dev, FIFO_LATENCY_CTRL, 0x03);
	if (err < 0)
		return err;

	/* Configure audio selection */
	err = tda1997x_write_reg(dev, AUDIO_SEL, 0x00);
	if (err < 0)
		return err;

	/* Configure audio enable */
	err = tda1997x_write_reg(dev,
				AUDIO_OUT_ENABLE,
				AUDIO_OUT_ENABLE_ACLK |
				AUDIO_OUT_ENABLE_WS |
				AUDIO_OUT_ENABLE_AP0);
	if (err < 0)
		return err;

	err = tda1997x_read_reg(dev, AUDIO_OUT_LOW_HIZ, &reg_val);
	if (err < 0)
		return err;

	/* Reset test mode */
	err = tda1997x_write_reg(dev, TEST_MODE, 0x00);
	if (err < 0)
		return err;

	err = tda1997x_mask_write_reg(dev, TEST_NCTS_CTRL, 0x03, 0);
	if (err < 0)
		return err;
	/**
	 * END: Configure Audio Formatter
	 */

	/**
	 * BEGIN: Configure Audio Clock Mode
	 */

	err = tda1997x_write_reg(dev, AUDIO_CLOCK_MODE, (uint8_t)AUDIO_CLOCK_MODE_128FS);
	if (err < 0)
		return err;
	/**
	 * END: Configure Audio Clock Mode
	 */

	return (0);
}


/**
 * @brief	Configure Audio Selection
 *
 * @param	dev:	TDA1997X device structure pointer
 * @param	mode:	Audio selection mode enumeration value
 * @return	0 on success, non-zero error status otherwise
 */
int tda1997x_cfg_audio_mode(struct tda1997x_dev *dev, enum tda1997x_audio_sel_mode mode)
{
	return tda1997x_mask_write_reg(dev, AUDIO_SEL, AUDIO_SEL_MODE_MASK, (uint8_t)mode);
}


/**
 * @brief	Get Audio Status
 *
 * @param	dev:	TDA1997X device structure pointer
 * @param	status:	Pointer to audio status to write value
 * @return	0 on success, non-zero error status otherwise
 */
int tda1997x_get_audio_flags(struct tda1997x_dev *dev, uint8_t *status)
{
	return tda1997x_read_reg(dev, AUDIO_FLAGS, status);
}


/**
 * @brief	Get Audio Frequency
 *
 * @param	dev:	TDA1997X device structure pointer
 * @param	freq:	Pointer to frequency to write value
 * @return	0 on success, non-zero error status otherwise
 */
int tda1997x_get_audio_freq(struct tda1997x_dev *dev, enum tda1997x_audio_freq *freq)
{
	int err;
	uint8_t reg_val;

	err = tda1997x_read_reg(dev, AUDIO_FREQ, &reg_val);
	if (err < 0)
		return err;

	*freq = (enum tda1997x_audio_freq)reg_val;

	return (0);
}


/**
 * @brief	Get Audio Channel Status
 *
 * @param	dev:	TDA1997X device structure pointer
 * @return	0 on success, non-zero error status otherwise
 */
int tda1997x_get_chan_status(struct tda1997x_dev *dev)
{
	int err;
	uint8_t reg_val[12];

	err = tda1997x_read(dev, CH_STAT_BYTE0, 12, reg_val);
	if (err < 0)
		return err;

	return (0);
}


/**
 * @brief	Reset Audio FIFO
 *
 * @param	dev:	TDA1997X device structure pointer
 * @return	0 on success, non-zero error status otherwise
 */
static int tda1997x_audio_fifo_rst(struct tda1997x_dev *dev)
{
	int err;

	err = tda1997x_mask_write_reg(dev, HDMI_INFO_RST, INFO_RST_AUDIO_FIFO_MASK, INFO_RST_AUDIO_FIFO_MASK);
	if (err < 0)
		return err;

	err = tda1997x_mask_write_reg(dev, HDMI_INFO_RST, INFO_RST_AUDIO_FIFO_MASK, 0);
	if (err < 0)
		return err;

	return (0);
}


/**
 * @brief	Calculate EDID Block Checksum
 *
 * @param	dev:	TDA1997X device structure pointer
 * @param	cksum:	Pointer to data to write checksum value
 * @return	None
 */
static int tda1997x_edid_cksum(struct tda1997x_dev *dev, uint8_t *edid, uint8_t *cksum)
{
	uint8_t i;
	uint8_t tmp = 0;
	uint8_t *pedid = edid;

	if ((edid == NULL) || (cksum == NULL))
		return (-1);

	for (i = 0; i < 127; i++)
		tmp += *pedid++;

	/* Write 2's complement to the checksum */
	*cksum = (0xFFU - tmp) + 1;

	return (0);
}


/**
 * @brief	Configure EDID
 *
 * @param	dev:		TDA1997X device structure pointer
 * @param	edid:		Pointer to start of EDID block, expected to be 127 bytes
 * @param	edid_ext:	Pointer to start of EDID extension, expected to be 127 bytes
 * @return	0 on success, non-zero error status otherwise
 */
static int tda1997x_cfg_edid(struct tda1997x_dev *dev, uint8_t *edid, uint8_t *edid_ext)
{
	int err;
	uint8_t cksum;				/**< Checksum values for each EDID block and SPA */

	/* Check arguments */
	if ((dev == NULL) ||
		(edid == NULL) ||
		(edid_ext == NULL))
		return (-1);

	/* Required number of EDID extensions after EDID block */
	if (edid[126] != 1)
		return (-2);

	/* Calculate the checksum for EDID block 0 */
	err = tda1997x_edid_cksum(dev, edid, &cksum);
	if (err < 0)
		return err;

	err = tda1997x_write(dev, EDID_IN_BYTE0, 127, edid);
	if (err < 0)
		return err;

	/* Write block 0 checksum byte */
	err = tda1997x_write_reg(dev, EDID_IN_CHECKSUM0, cksum);
	if (err < 0)
		return err;

	/* Calculate the checksum for EDID extension */
	err = tda1997x_edid_cksum(dev, edid_ext, &cksum);
	if (err < 0)
		return err;

	err = tda1997x_write(dev, EDID_IN_BYTE128, 127, edid_ext);
	if (err < 0)
		return err;

	/* Write block 1 checksum byte */
	err = tda1997x_write_reg(dev, EDID_IN_CHECKSUM1, cksum);
	if (err < 0)
		return err;

	return (0);
}


/**
 * @brief	Configure Source Physical Address
 *
 * @param	dev:	TDA1997X device structure pointer
 * @param	edid1:	Pointer to start of EDID extension block
 * @param	offset:	Offset of SPA within the EDID extension block
 * @param	spa:	Pointer to array of SPAs
 * @return	0 on success, non-zero error status otherwise
 */
static int tda1997x_cfg_spa(struct tda1997x_dev *dev, uint8_t *edid1, uint8_t offset, uint16_t* spa)
{
	int err;
	uint8_t reg_val[7];
	uint8_t i, tmp = 0;

	if ((dev == NULL) ||
		(edid1 == NULL) ||
		(spa == NULL))
		return (-1);

	/* Build SPA offset and value registers */
	reg_val[0] = offset;
	reg_val[1] = (uint8_t)(spa[0] >> 8);
	reg_val[2] = (uint8_t)(spa[0] & 0xFFU);

	reg_val[4] = (uint8_t)(spa[1] >> 8);
	reg_val[5] = (uint8_t)(spa[1] & 0xFFU);

	/* First calculate the EDID block 1 checksum without the SPA bytes */
	for (i = 0; i < 127; i++)
		if ((i == offset) || (i == (offset + 1)))
			continue;
		else
			tmp += edid1[i];

	/* Add the checksums for the SPAs separately */
	reg_val[3] = tmp + (((spa[0] >> 8) + spa[0]) & 0xFFU);
	reg_val[6] = tmp + (((spa[1] >> 8) + spa[1]) & 0xFFU);

	/* Calculate 2's complement */
	reg_val[3] = (uint8_t)((0xFFU - reg_val[3]) + 1);
	reg_val[6] = (uint8_t)((0xFFU - reg_val[6]) + 1);

	err = tda1997x_write(dev, EDID_IN_SPA_SUB, 7, reg_val);
	if (err < 0)
		return err;

	return (0);
}





/**
 * @brief	Read Infoframe
 *
 * @param	dev:	TDA1997X device structure pointer
 * @return	0 on success, non-zero error status otherwise
 */
static int tda1997x_read_infoframe(struct tda1997x_dev *dev, enum tda1997x_hdmi_reg reg, union tda1997x_infoframe *info)
{
	int err;
	uint8_t head[4];
	uint8_t *data;

	if ((dev == NULL) || (info == NULL))
		return (-1);

	/* Read the infoframe header to determine the type and length */
	err = tda1997x_read(dev, reg, 4, head);
	if (err < 0)
		return err;

	/* Parse the header to determine */
	info->any.type = head[0];
	info->any.version = head[1];
	info->any.len = head[2];
	info->any.cksum = head[3];

	/* If invalid type, don't bother reading data */
	if ((info->any.type < INFOFRAME_TYPE_VENDOR) || (info->any.type > INFOFRAME_TYPE_MPS))
		return (0);

	if ((info->any.len > 0) && (info->any.len <= 27)) {
		data = info->any.data;
		err = tda1997x_read(dev, reg + 4, info->any.len, data);
		if (err < 0)
			return err;
	}

	return (0);
}


/**
 * @brief	Parse Infoframe
 *
 * @param	dev:	TDA1997X device structure pointer
 * @param	info:	Pointer to infoframe union data
 * @return	0 on success, non-zero error status otherwise
 */
int tda1997x_parse_infoframe(struct tda1997x_dev *dev, union tda1997x_infoframe *info)
{
	return (0);
}


/**
 * @brief	Parse Audio Infoframe
 *
 * @param	dev:	TDA1997X device structure pointer
 * @param	info:	Pointer to audio infoframe structure
 * @return	0 on success, non-zero error status otherwise
 */
int tda1997x_parse_aud_infoframe(struct tda1997x_dev *dev, struct tda1997x_info_aud *info)
{
	int err;

	/* Set the audio output based to match the infoframe */
	err = tda1997x_write_reg(dev, AUDIO_PATH, info->chan_alloc);
	if (err < 0)
		return err;

	/* Reset the audio FIFO */
	err = tda1997x_audio_fifo_rst(dev);
	if (err < 0)
		return err;

	return (0);
}


/**
 * @brief	Print Infoframe
 *
 * @param	dev:	TDA1997X device structure pointer
 * @return	0 on success, non-zero error status otherwise
 */
int tda1997x_print_infoframe(struct tda1997x_dev *dev)
{
	return (0);
}


/**
 * @brief	Initialize TDA1997x HDMI Receiver
 *
 * @param	dev:	TDA1997X device structure pointer
 * @param	cfg:	TDA1997X configuration structure pointer to use for
 * 			initialization
 * @return 0 on success, non-zero error status otherwise
 */
int tda1997x_init(struct tda1997x_dev *dev, struct tda1997x_cfg *cfg)
{
	int err;
	uint8_t i, reg_val, mask;
	uint16_t hdcp_kds;			/**< HDCP key decryption seed */

	dev->cfg = cfg;				/* Attach configuration to receiver */
	dev->cur_page = PAGE_INVALID;		/* Force initial read/write to set page */

	/* Open the device and perform basic initialization */

	/* Apply WA to get correct I2C access to Rx HDMI*/
	err = tda1997x_write_reg(dev, MAN_SUS_HDMI_SEL, MAN_SUS_HDMI_DIS_HDCP | MAN_SUS_HDMI_RST_HDCP);
	if (err < 0)
		return err;

	err = tda1997x_write_reg(dev, MAN_SUS_HDMI_SEL, 0x00);
	if (err < 0)
		return err;

	err = tda1997x_write_reg(dev, VDP_CTRL, 0x1f);
	if (err < 0)
		return err;

//	/* Read and store CEC slave address */
//	err = tda1997x_read_reg(dev, SLAVE_ADDR, &reg_val);
//	if (err < 0)
//		return err;
//
//	/* Update CEC address if necessary */
//	if ((uint8_t)((reg_val >> 4) & 0x03) != (dev->cfg->cec_addr & 0x03)) {
//		err = tda1997x_mask_write_reg(dev, SLAVE_ADDR, 0x30, (uint8_t)((dev->cfg->cec_addr << 4) & 0x30));
//		if (err < 0)
//			return err;
//	}

	/* Disable HPD */
	err = tda1997x_write_reg(dev, HPD_AUTO_CTRL, HPD_AUTO_UNSEL);
	if (err < 0)
		return err;

	/* Wrap these consecutive register writes */
	err = tda1997x_write_reg(dev, SUS_SET_RGB2, 0x06);
	if (err < 0)
		return err;

	err = tda1997x_write_reg(dev, SUS_SET_RGB3, 0x06);
	if (err < 0)
		return err;

	err = tda1997x_write_reg(dev, RT_MAN_CTRL, 0x43);
	if (err < 0)
		return err;

	err = tda1997x_write_reg(dev, OF_CTRL, 0x40);
	if (err < 0)
		return err;

	/* Begin CEC */
	/* Enable sync measurement timing */
	err = tda1997x_cec_write_reg(dev, PWR_CONTROL, 0x04);
	if (err < 0)
		return err;

	/* Adjust CEC clock divider */
	err = tda1997x_cec_write_reg(dev, OSC_DIVIDER, 0x03);
	if (err < 0)
		return err;

	err = tda1997x_cec_write_reg(dev, EN_OSC_PERIOD_LSB, 0xA0);
	if (err < 0)
		return err;
	/* End CEC */

	err = tda1997x_write_reg(dev, TIMER_D, 0x54);
	if (err < 0)
		return err;
	/*
	 * Enable power switch - SRAM content is always valid
	 * (in case E-MTP is not or mis-programmed)
	 */
	err = tda1997x_cec_mask_write_reg(dev, CONTROL, 0x20, 0x20);
	if (err < 0)
		return err;

	usleep(1000 * 50);					/* Short delay to allow power to settle */

	/* Initialize top level interrupts */
	err = tda1997x_write_reg(dev,
				IRQ_MASK_TOP,
				IRQ_TOP_SUS |
				IRQ_TOP_RATE |
				IRQ_TOP_MODE |
				IRQ_TOP_INFO |
				IRQ_TOP_AUDIO |
				IRQ_TOP_HDCP);
	if (err < 0)
		return err;

	err = tda1997x_write_reg(dev, IRQ_MASK_SUS, IRQ_SUS_MTP | IRQ_SUS_FORMAT | IRQ_SUS_END);
	if (err < 0)
		return err;

	/* Enable rate stability change interrupts for input */
	err = tda1997x_write_reg(dev, IRQ_MASK_RATE, IRQ_RATE_RXDA);
	if (err < 0)
		return err;

	/* Enable interrupts for audio, SPD, and AVI infoframes */
	err = tda1997x_write_reg(dev, IRQ_MASK_INFO, IRQ_INFO_AUD | IRQ_INFO_SPD | IRQ_INFO_AVI);
	if (err < 0)
		return err;

	/* Enable audio interrupts */
	err = tda1997x_write_reg(dev,
				IRQ_MASK_AUDIO,
				IRQ_AUDIO_FIFO_ERROR |
				IRQ_AUDIO_FIFO_UNMUTE |
				IRQ_AUDIO_CHAN_STATUS |
				IRQ_AUDIO_MUTE |
				IRQ_AUDIO_FLAGS |
				IRQ_AUDIO_FREQ_CHANGE);
	if (err < 0)
		return err;

	/* Enable HDCP interrupts */
	err = tda1997x_write_reg(dev, IRQ_MASK_HDCP, IRQ_HDCP_STATE_C5);
	if (err < 0)
		return err;

	/* Enable mode interrupts */
	err = tda1997x_write_reg(dev, IRQ_MASK_MODE, IRQ_MODE_FLAGS);
	if (err < 0)
		return err;

	for (i = 0; i < 9; i++) {
		/* Clear pending top level interrupts */
		err = tda1997x_write_reg(dev, IRQ_FLG_CLR_TOP + i, 0xff);
		if (err < 0)
			return err;
	}

	/* Initialize TMDS */
	err = tda1997x_write(dev, CLK_MIN_RATE_MSB, 6, clk_rate);
	if (err < 0)
		return err;

	/* Deep color filter */
	err = tda1997x_write_reg(dev, DEEP_COLOR_CTRL, 0x31);
	if (err < 0)
		return err;

	/* Disable test pattern */
	err = tda1997x_write_reg(dev, SERVICE_MODE, 0x00);
	if (err < 0)
		return err;

	err = tda1997x_write_reg(dev, INFO_CTRL, 0xff);
	if (err < 0)
		return err;

	err = tda1997x_write_reg(dev, INFO_EXCEED, 0x03);
	if (err < 0)
		return err;

	/* No HDCP acknowledge when disabled, reset startup sequence */
	err = tda1997x_info_rst(dev, INFO_RST_NACK_HDCP);
	if (err < 0)
		return err;

	/* Reset startup sequence if indicated */
	err = tda1997x_sus_en(dev, 0);
	if (err < 0)
		return err;

	/* Mute video port on start */
	err = tda1997x_cfg_vp(dev, vp_conf_mute);
	if (err < 0)
		return err;

	/* MTP start read */
	/* Clear HDCP download MTP flag to start reading */
	err = tda1997x_mask_write_reg(dev, IRQ_FLG_CLR_HDCP, IRQ_HDCP_DLMTP, IRQ_HDCP_DLMTP);
	if (err < 0)
		return err;

	/* Download MTP into SRAM by setting HMTP_CTRL_DL_ALL */
	err = tda1997x_write_reg(dev, HMTP_CTRL, BIT(0));
	if (err < 0)
		return err;

	/* Check HDCP flag INT_FLG_CLR_HDCP_DLMTP */
	do {
		err = tda1997x_read_reg(dev, IRQ_FLG_CLR_HDCP, &reg_val);
		if (err < 0)
			return err;
	} while ((reg_val & IRQ_HDCP_DLMTP) != IRQ_HDCP_DLMTP);

	/* Get HDCP seed */
	err = tda1997x_read_reg(dev, MTP_SEED_INDEX, &reg_val);
	if (err < 0)
		return err;

	/* Search the seed table for the index value */
	for (i = 0; i < TDA1997X_SEED_TABLE_LEN; i++) {
		if ((hdcp_seed_tab[i].seed == 0) && (hdcp_seed_tab[i].lookup == 0))
			break;

		if (hdcp_seed_tab[i].lookup == (uint16_t)reg_val) {
			/* Store the encryption key seed */
			hdcp_kds = hdcp_seed_tab[i].seed;
			break;
		}
	}

	/* Disable HDCP */
	err = tda1997x_write_reg(dev, HDCP_CTRL, HDCP_CTRL_DECRYPTKEY_ON);
	if (err < 0)
		return err;

	/* Write key decryption seed MSB */
	err = tda1997x_write_reg(dev, HDCP_KDS_MSB, (uint8_t)(hdcp_kds >> 8));
	if (err < 0)
		return err;

	/* Write key decryption seed LSB */
	err = tda1997x_write_reg(dev, HDCP_KDS_LSB, (uint8_t)(hdcp_kds & 0xFF));
	if (err < 0)
		return err;

	/* Set the HDCP DDC address */
	err = tda1997x_write_reg(dev, HDCP_DDC_ADDR, TDA1997X_HDCP_DDC_ADDR);
	if (err < 0)
		return err;

	/* Clear HDCP interrupt status bits that may have been raised during this process */
	err = tda1997x_clear_irq(dev, IRQ_FLG_CLR_HDCP, &reg_val);
	if (err < 0)
		return err;

	/* THE DEVICE IS INITIALIZED AT THIS POINT */

	/* Set HPD low */
	err = tda1997x_mask_write_reg(dev, HPD_POWER, HPD_POWER_BYPASS_MASK, 0);
	if (err < 0)
		return err;

	/* Set HPD low */
	err = tda1997x_mask_write_reg(dev, HPD_MAN_CTRL, HPD_MAN_GAIN_MASK, 0);
	if (err < 0)
		return err;

	err = tda1997x_write_reg(dev, HDCP_BCAPS, HDCP_BCAPS_DEFAULT | HDCP_BCAPS_FAST_REAUTH);
	if (err < 0)
		return err;

	/* Configure HDMI */
	err = tda1997x_mask_write_reg(dev,
					HDMI_CTRL,
					HDMI_CTRL_HDCP_MASK | HDMI_CTRL_MUTE_MASK,
					(uint8_t)HDMI_CTRL_MUTE_OFF | (uint8_t)HDMI_CTRL_HDCP_AUTO);
	if (err < 0)
		return err;

	/* EDID Nack OFF */
	err = tda1997x_mask_write_reg(dev, EDID_ENABLE, 0x83, 0x83);
	if (err < 0)
		return err;

	/**
	 * @todo HDCP configuration and activation
	 */
	/* 1. Enable HDCP NACK */
	err = tda1997x_mask_write_reg(dev, HDMI_INFO_RST, INFO_RST_NACK_HDCP, INFO_RST_NACK_HDCP);
	if (err < 0)
		return err;

	/* 2. Disable HDCP */

	/* 3. Set private key index */

	usleep(1000 * 20);

	/* 4. Disable HDCP NACK */
	err = tda1997x_mask_write_reg(dev, HDMI_INFO_RST, INFO_RST_NACK_HDCP, 0);
	if (err < 0)
		return err;

	/* 5. Configure HDCP error protection */

	/* Reset SUS to force format detection */
	err = tda1997x_sus_en(dev, 0);
	if (err < 0)
		return err;

	err = tda1997x_sus_en(dev, SUS_ENABLE);
	if (err < 0)
		return err;

	err = tda1997x_mask_write_reg(dev, HPD_AUTO_CTRL, HPD_AUTO_OTHER, HPD_AUTO_OTHER);
	if (err < 0)
		return err;

	err = tda1997x_cfg_edid(dev, edid_block, edid_ext);
	if (err < 0)
		return err;

	err = tda1997x_cfg_spa(dev, &edid_block[128], 8, spa_edid);
	if (err < 0)
		return err;

	/* Load EDID configuration data */
	err = tda1997x_write(dev, EDID_IN_VERSION, 8, ddc_config);
	if (err < 0)
		return err;

	err = tda1997x_write(dev, RT_AUTO_CTRL, 6, rt_config);
	if (err < 0)
		return err;

	err = tda1997x_mask_write_reg(dev, HPD_POWER, HPD_POWER_BYPASS_MASK, 0x04);
	if (err < 0)
		return err;

	err = tda1997x_write_reg(dev, INPUT_SEL, 0x00);
	if (err < 0)
		return err;

//	/* Configure HDCP without resetting SUS */
//	err = tda1997x_info_rst(dev, INFO_RST_NACK_HDCP, SUS_ENABLE);
//	if (err < 0)
//		return err;

	/* Enable HDCP Nack */

	/* Disable HDCP */

	/* Index the private key */

	/* Encrypted, enable HDCP */

	/* Enable HDCP acknowledge when HDCP is enabled */

	/* Configure HDCP error protection */
	mask = INPUT_SEL_VDPR_FMT_MASK | INPUT_SEL_HDMIOUT;
	err = tda1997x_mask_write_reg(dev, INPUT_SEL, mask, INPUT_SEL_FORMAT_RESET);
	if (err < 0)
		return err;

	/* Mute output */
	mask = OF_CTRL_OUTPUT_ACTIVE | OF_CTRL_VIDEO_HIZ;
	err = tda1997x_mask_write_reg(dev, OF_CTRL, mask, OF_CTRL_VIDEO_HIZ);
	if (err < 0)
		return err;

	/**
	 * @todo Configure video output with structure data
	 */
	err = tda1997x_cfg_vid_out(dev);
	if (err < 0)
		return err;

	/* Define video port */
	err = tda1997x_cfg_vp(dev, vp_conf444);
	if (err < 0)
		return err;

	/* Unmute output */
	err = tda1997x_mask_write_reg(dev, OF_CTRL, OF_CTRL_OUTPUT_ACTIVE | OF_CTRL_VIDEO_HIZ, OF_CTRL_OUTPUT_ACTIVE);
	if (err < 0)
		return err;

	/**
	 *  Configure audio
	 * @todo Pass audio configuration data to tda1997x_cfg_audio_fmt
	 */
	err = tda1997x_cfg_audio_fmt(dev);
	if (err < 0)
		return err;

	/* Reset infoframes */
	err = tda1997x_info_rst(dev, INFO_RST_AI);
	if (err < 0)
		return err;

	err = tda1997x_info_rst(dev, INFO_RST_INFOFRAME);
	if (err < 0)
		return err;

	err = tda1997x_info_rst(dev, INFO_RST_AUDIO);
	if (err < 0)
		return err;

	err = tda1997x_info_rst(dev, INFO_RST_GAMUT);
	if (err < 0)
		return err;

	err = tda1997x_sus_en(dev, SUS_ENABLE);
	if (err < 0)
		return err;

	err = tda1997x_read_reg(dev, HDMI_FLAGS, &reg_val);
	if (err < 0)
		return err;

	return (0);
}


/**
 * @brief	Startup Sequence Interrupt Handler
 *
 * @param	dev:	TDA1997X device structure pointer
 * @param	flags:	Flags read from the interrupt flags register
 * @return	0 on success, non-zero error status otherwise
 */
static int tda1997x_sus_irq(struct tda1997x_dev *dev, uint8_t flags)
{
	int err;
	uint8_t i, status;

	if (flags & IRQ_SUS_STATE) {
		/* SUS state changed */
	}

	if (flags & IRQ_SUS_INPUT) {
		/* Selected input changed */
	}

	if (flags & IRQ_SUS_ACTIVITY) {
		/* Activity of selected input changed */
	}

	if (flags & IRQ_SUS_END) {

		/* Reset the audio FIFO */
		err = tda1997x_audio_fifo_rst(dev);
		if (err < 0)
			return err;

		err = tda1997x_read_reg(dev, SUS_STATUS, &status);
		if (err < 0)
			return err;

		if ((status & SUS_STATUS_STATE_MASK) == SUS_STATUS_LAST_STATE) {

			err = tda1997x_read_reg(dev, GAIN_OVR_EN, &status);
			if (err < 0)
				return err;

			/* Gain mode manual */
			if (status == 0x01U) {

				/* Set the gain mode to automatic */
				err = tda1997x_write_reg(dev, GAIN_OVR_EN, 0x00);
				if (err < 0)
					return err;

				/* Reset the startup sequence */
				err = tda1997x_sus_en(dev, 0);
				if (err < 0)
					return err;

				usleep(1000 * 5);

				err = tda1997x_sus_en(dev, SUS_ENABLE);
				if (err < 0)
					return err;
			} else {
				/* Gain mode is already set to automatic. Read gains */
				for (i = 0; i < 3; i++) {
					err = tda1997x_read_reg(dev, GAIN_CH0 + i, &status);
					if (err < 0)
						return err;
				}
			}
		}

		/* Detect the resolution */

		/* Set the resolution to detected input */

		/* Colorspace conversion */
		err =  tda1997x_cfg_conv(dev, color_conv444);
		if (err < 0)
			return err;

		/* Set blanking codes */
		err = tda1997x_write(dev, BLK_GY_MSB, 6, blank_rgb);
		if (err < 0)
			return err;

		/* The state of the HDMI is now LOCKED */
	}

	if (flags & IRQ_SUS_RT_PULSE) {
	}

	if (flags & IRQ_SUS_MTP) {
	}

	if (flags & IRQ_SUS_FORMAT) {

		/* Ignore format interrupts during MTP process */
		if (!(flags & IRQ_SUS_MTP)) {

			err = tda1997x_read_reg(dev, SUS_STATUS, &status);
			if (err < 0)
				return err;

			if ((status & SUS_STATUS_STATE_MASK) == SUS_STATUS_LAST_STATE)
				flags &= ~(IRQ_SUS_FORMAT);

			/* Detect the resolution */

			/* Set the resolution to detected input */

			/* Colorspace conversion */
			err =  tda1997x_cfg_conv(dev, color_conv444);
			if (err < 0)
				return err;

			/* Set blanking codes */
			err = tda1997x_write(dev, BLK_GY_MSB, 6, blank_rgb);
			if (err < 0)
			return err;

			/* The state of the HDMI is now LOCKED */
		}
	}

	return (0);
}


/**
 * @brief	Parse Infoframe
 *
 * @param	dev:	TDA1997X device structure pointer
 * @param	flags:	Flags read from interrupt flags register
 * @return	0 on success, non-zero error status otherwise
 */
static int tda1997x_infoframe_irq(struct tda1997x_dev *dev, uint8_t flags)
{
	int err;
	uint8_t i;
	uint8_t reg_val;
	enum tda1997x_hdmi_reg reg = VS_IF_HDMI_UPDATE;
	union tda1997x_infoframe info;

	for (i = 0; i < NIRQ_SOURCE_FLAGS; i++) {
		/* Check if interrupt flag is set */
		if (flags & (1 << i)) {

			/* Check the update register */
			err = tda1997x_read_reg(dev, reg, &reg_val);
			if (err < 0)
				return err;

			/* Read the infoframe if updated (start from infoframe type register) */
//			if (reg_val) {
				err = tda1997x_read_infoframe(dev, reg + 1, &info);
				if (err < 0)
					return err;

//				err = tda1997x_parse_infoframe(dev, &info);
//				if (err < 0)
//					return err;
//			}
		}

		reg += 32;				/* Go to next infoframe update register */
	}

	return (0);
}


/**
 * @brief	Audio Interrupt Handler
 *
 * @param	dev:	TDA19997X device structure pointer
 * @param	flags:	Flags read from the interrupt flags register
 * @return	0 on success, non-zero error status otherwise
 */
int tda1997x_audio_irq(struct tda1997x_dev *dev, uint8_t flags)
{
	int err;
	uint8_t status;
	enum tda1997x_audio_freq freq;

	if (flags & IRQ_AUDIO_FIFO_ERROR) {

		err = tda1997x_read_reg(dev, SUS_STATUS, &status);
		if (err < 0)
			return err;

		/* Last state reached */
		if ((status & SUS_STATUS_STATE_MASK) == SUS_STATUS_LAST_STATE) {

			/* Reset the audio FIFO */
//			err = tda1997x_audio_fifo_rst(dev);
//			if (err < 0)
//				return err;
		}
	}

	if (flags & IRQ_AUDIO_FIFO_UNMUTE) {
		/* Audio FIFO unmuted */
	}

	if ((flags & IRQ_AUDIO_CHAN_STATUS) &&
			!(flags & (IRQ_AUDIO_FIFO_ERROR | IRQ_AUDIO_MUTE))) {

		err = tda1997x_read_reg(dev, AUDIO_STATUS, &status);
		if (err < 0)
			return err;

		/* Read channel status */
		err = tda1997x_get_chan_status(dev);
		if (err < 0)
			return err;
	}

	if (flags & IRQ_AUDIO_MUTE) {

		err = tda1997x_read_reg(dev, SUS_STATUS, &status);
		if (err < 0)
			return err;

		/* Last state reached */
		if ((status & SUS_STATUS_STATE_MASK) == SUS_STATUS_LAST_STATE) {

			/* Reset the audio FIFO */
//			err = tda1997x_audio_fifo_rst(dev);
//			if (err < 0)
//				return err;
		}
	}

	if (flags & IRQ_AUDIO_FLAGS) {
		/* Get the audio flags */
		err = tda1997x_get_audio_flags(dev, &status);
		if (err < 0)
			return err;
	}

	if (flags & IRQ_AUDIO_FREQ_CHANGE) {

		/* Get the audio frequency */
		err = tda1997x_get_audio_freq(dev, &freq);
		if (err < 0)
			return err;

		if (freq != AUDIO_FREQ_HEADER) {
		}
	}

	return (0);
}


/**
 * @brief	AFE Interrupt Handler
 *
 * @param	dev:	TDA1997X device structure pointer
 * @param	flags:	Flags read from the interrupt flags register
 * @return	0 on success, non-zero error otherwise
 */
int tda1997x_afe_irq(struct tda1997x_dev *dev, uint8_t flags)
{
	return (0);
}


/**
 * @brief	Handle TDA1997x Interrupt
 *
 * @param	dev:	TDA1997X device structure pointer
 * @return 0 on success, non-zero error status otherwise
 */
int tda1997x_handle_irq(struct tda1997x_dev *dev)
{
	int err;
	uint8_t irq_flags_top, reg_val;
	uint8_t status;

	do {
		/* Read top level flags */
		err = tda1997x_read_reg(dev, IRQ_FLG_CLR_TOP, &irq_flags_top);
		if (err < 0)
			return err;

		/* Start-up sequence source handling */
		if (irq_flags_top & IRQ_TOP_SUS) {
			/* Read the SUS interrupt flags register and clear */
			err = tda1997x_clear_irq(dev, IRQ_FLG_CLR_SUS, &reg_val);
			if (err < 0)
				return err;

			err = tda1997x_sus_irq(dev, reg_val);
			if (err < 0)
				return err;
		}

		if (irq_flags_top & IRQ_TOP_RATE) {
			err = tda1997x_clear_irq(dev, IRQ_FLG_CLR_RATE, &reg_val);
			if (err < 0)
				return err;

			if (reg_val & IRQ_RATE_RXDA) {
				/* Read interrupt status registers */
				err = tda1997x_read_reg(dev, CLK_A_STATUS, &status);
				if (err < 0)
					return err;

				err = tda1997x_read_reg(dev, CLK_B_STATUS, &status);
				if (err < 0)
					return err;

				err = tda1997x_read_reg(dev, SUS_STATUS, &status);
				if (err < 0)
					return err;
			}
		}

		if (irq_flags_top & IRQ_TOP_MODE) {
			err = tda1997x_clear_irq(dev, IRQ_FLG_CLR_MODE, &reg_val);
			if (err < 0)
				return err;

			if (reg_val & IRQ_MODE_FLAGS) {
				err = tda1997x_read_reg(dev, HDMI_FLAGS, &status);
				if (err < 0)
					return err;

//				if (status & (HDMI_FLAGS_AUD_FIFO_OVR | HDMI_FLAGS_AUD_FIFO_LOW)) {
//					err = tda1997x_audio_fifo_rst(dev);
//					if (err < 0)
//						return err;
//				}
			}
		}

		/* Infoframe interrupt source handling */
		if (irq_flags_top & IRQ_TOP_INFO) {
			/* Read the infoframe interrupt flags register and clear */
			err = tda1997x_clear_irq(dev, IRQ_FLG_CLR_INFO, &reg_val);
			if (err < 0)
				return err;

			err = tda1997x_infoframe_irq(dev, reg_val);
			if (err < 0)
				return err;
		}

		/* Audio interrupt source handling */
		if (irq_flags_top & IRQ_TOP_AUDIO) {
			/* Read the audio interrupt flags register and clear */
			err = tda1997x_clear_irq(dev, IRQ_FLG_CLR_AUDIO, &reg_val);
			if (err < 0)
				return err;

			err = tda1997x_audio_irq(dev, reg_val);
			if (err < 0)
				return err;
		}

		/* AFE interrupt source handling */
		if (irq_flags_top & IRQ_TOP_AFE) {
			err = tda1997x_clear_irq(dev, IRQ_FLG_CLR_AFE, &reg_val);
			if (err < 0)
				return err;

			err = tda1997x_afe_irq(dev, reg_val);
			if (err < 0)
				return err;
		}
	} while (irq_flags_top != 0);

	return (0);
}


/**
 * @brief
 */
int tda1997x_interrupt(struct tda1997x_dev *dev, struct tda1997x_irq_source *tab)
{
	int err;
	uint8_t i, j;
	uint8_t irq_top_flags = 0;
	uint8_t flags;
	struct tda1997x_irq_source *src = tab;			/* Point to start of table */
	struct tda1997x_irq_event *evt;

	/* Vector the interrupt from the top level */

	for (i = 0; i < NIRQ_TOP_FLAGS; i++, src++) {

		evt = src->events;					/* Point to start of event list */

		if (irq_top_flags & (1 << i)) {

			/* Clear the interrupt source in the FLG_CLR register */
			err = tda1997x_clear_irq(dev, src->clr_reg, &flags);
			if (err < 0)
				return err;

			for (j = 0; j < NIRQ_SOURCE_FLAGS; j++, evt++) {
				if ((flags & (1 << j)) && evt->en)
					if (evt->callback != NULL)
						evt->callback(dev, flags);
			}
		}
	}

	return (0);
}

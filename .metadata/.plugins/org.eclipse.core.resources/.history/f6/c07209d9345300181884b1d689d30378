/**
 * Copyright (C) 2006 NXP N.V., All Rights Reserved.
 * This source code and any compilation or derivative thereof is the proprietary
 * information of NXP N.V. and is confidential in nature. Under no circumstances
 * is this software to be  exposed to or placed under an Open Source License of
 * any type without the expressed written permission of NXP N.V.
 *
 * \file          tmdlHdmiCEC_cfg.c
 *
 * \version       Revision: 1
 *
 * \date          Date: 
 *
 * \brief         devlib driver component API for the CEC message
 *
 * \section refs  Reference Documents
 * 
 *
 * \section info  Change Information
 *
 * \verbatim

   History:       tmdlHdmiCEC_cfg.c
 *

   \endverbatim
 *
*/

/*============================================================================*/
/*                             INCLUDE FILES                                  */
/*============================================================================*/
#include "tmdlHdmiCEC_IW.h"
#include "tmNxTypes.h"
#include "tmdlHdmiCEC.h"
#include "tmdlHdmiCEC_cfg.h"


/*============================================================================*/
/*                                MACRO                                       */
/*============================================================================*/
/* macro for quick error handling */
#define RETIF(cond, rslt) if ((cond)){return (rslt);}

/*============================================================================*/
/*                          FUNCTIONS DECLARATIONS                            */
/*============================================================================*/
tmErrorCode_t CECI2cReadFunction(tmdlHdmiCecSysArgs_t *pSysArgs);
tmErrorCode_t CECI2cWriteFunction(tmdlHdmiCecSysArgs_t *pSysArgs);

/*****************************************************************************/
/*****************************************************************************/
/*                 THIS PART CAN BE MODIFIED BY CUSTOMER                     */
/*****************************************************************************/
/*****************************************************************************/
/* The following includes are used by I2C access function. If    				*/
/* you need to rewrite these functions for your own SW infrastructure, then   */
/* it can be removed 															*/
#include <stdio.h>
#include <stdlib.h>
#include <stdint.h>
#include <unistd.h>
#include <string.h>
#include <errno.h>

#include "i2c-dev.h"

/* I2C adress of the unit */
#ifdef TMFL_CEC_TDA9996
	#define UNIT_I2C_ADDRESS_0 0x60 /* I2C Address of TDA9950 */
#else
	#define UNIT_I2C_ADDRESS_0 0x37 /* I2C Address of TDA9950 */
#endif /* TMFL_CEC_TDA9996 */

/* Priority of the command task                                               */
/* Command task is an internal task that handles incoming event from the IC   */
/* put there a value that will ensure a response time of ~20ms in your system */
#define COMMAND_TASK_PRIORITY_0  250

/* Stack size of the command tasks */
/* This value depends of the type of CPU used, and also from the length of    */
/* the customer callbacks. Increase this value if you are making a lot of     */
/* processing (function calls & local variables) and that you experience      */
/* stack overflows                                                            */
#define COMMAND_TASK_STACKSIZE_0 128

/* Size of the message queues for command tasks                               */
/* This value defines the size of the message queue used to link the          */
/* the tmdlHdmiTxHandleInterrupt function and the command task. The default   */
/* value below should fit any configuration                                   */
#define COMMAND_TASK_QUEUESIZE_0 128

/* CEC Data Register (Read/Write)                                             */
#define CEC_REG_CDR0 0x07


/*============================================================================*/
/*                       VARIABLES DECLARATIONS                               */
/*============================================================================*/

/*
 *
 * Linux wrapping starts here...............................
 *
 */
/*
 *  Write a byte to a register in Cec device.
 */
int write_cec_reg(UInt8 dev_address, UInt8 reg, UInt8* val)
{
   	int value = 0;

   	//write byte
	value = i2c_write_reg(dev_address, reg, val);
	if (value < 0) {
		PRNT_ARGS("/!\\cec write %d byte(s) dev address 0x%02x first register 0x%02x FAILED\n", 1, dev_address, reg);
		PRNT_ARGS("\terrno = %s\n", strerror(errno));
		return TM_ERR_BAD_PARAMETER;
	}

//    PRNT_ARGS("cec write %d byte(s) dev address 0x%02x first register 0x%02x SUCCEED\n", 1, dev_address, reg);
	return TM_OK;
}

/*
 *  Write CEC data registers in Cec device.
 */
//int write_cec_cdr(UInt8 dev_address, UInt8 reg, UInt8* val)
//{
//   	int value;
//
//   	//write byte
//	value = i2c_write_reg(dev_address, reg, val);
//	if (value < 0) {
//		PRNT_ARGS("/!\\cec write cdr (fbc = %d) dev address 0x%02x first register 0x%02x FAILED\n", val[0], dev_address, reg);
//		PRNT_ARGS("\terrno = %s\n", strerror(errno));
//		return TM_ERR_BAD_PARAMETER;
//	}
//
////    PRNT_ARGS("cec write cdr (fbc = %d) dev address 0x%02x first register 0x%02x SUCCEED\n", val[0], dev_address, reg);
//	return TM_OK;
//}

/*
 *  Read a byte from a register in Cec device.
 */
int read_cec_reg(UInt8 dev_address, UInt8 reg, UInt8* val)
{
   	int value = 0;

	//read byte
	value = i2c_read_reg(dev_address, reg, val);
	if (value < 0) {
		PRNT_ARGS("/!\\cec read %d byte(s) dev address 0x%02x first register 0x%02x FAILED\n", 1, dev_address, reg);
		PRNT_ARGS("\terrno = %s\n", strerror(errno));
		return TM_ERR_BAD_PARAMETER;
	}

	//    PRNT_ARGS("cec read %d byte(s) dev address 0x%02x first register 0x%02x SUCCEED\n", 1, dev_address, reg);
	return TM_OK;
}

/*
 *  Read CEC data registers from Cec device.
 */
//int read_cec_cdr(UInt8 dev_address, UInt8 reg, UInt8* val)
//{
//   	int value;
//   	int i;
//	union i2c_smbus_data data;
//
//	//read bytes
//	value = i2c_read_block(dev_address, reg, val);
//	if (value < 0) {
//		PRNT_ARGS("/!\\cec read cdr (fbc = %d) dev address 0x%02x first register 0x%02x FAILED\n", data.block[0], dev_address, reg);
//		PRNT_ARGS("\terrno = %s\n", strerror(errno));
//		return TM_ERR_BAD_PARAMETER;
//	}
//
////	PRNT_ARGS("cec read cdr (fbc = %d) dev address 0x%02x first register 0x%02x SUCCEED\n", data.block[0], dev_address, reg);
//	return TM_OK;
//}

/*
 *
 * Linux wrapping end...............................
 *
 */

/* The following function must be rewritten by the customer to fit its own    */
/* SW infrastructure. This function allows reading through I2C bus.           */
/* tmdlHdmiCecSysArgs_t definition is located into tmbslHdmiTx_type.h file.   */
tmErrorCode_t CECI2cReadFunction(tmdlHdmiCecSysArgs_t *pSysArgs)
{
	tmErrorCode_t errCode;
	int i;

	for (i = 0; i < pSysArgs->lenData; i++) {
		errCode = read_cec_reg(pSysArgs->slaveAddr, pSysArgs->firstRegister + i, &pSysArgs->pData[i]);
		if (errCode != TM_OK)
			return errCode;
	}

//	if (pSysArgs->lenData == 1)
//	{
//	  //single byte
//		errCode = read_cec_reg(pSysArgs->slaveAddr, pSysArgs->firstRegister, pSysArgs->pData);
//	}
//	else if (pSysArgs->lenData > 1)
//	{
//		//block
//	   	if (pSysArgs->firstRegister == CEC_REG_CDR0)
//	   	{
//	   		//CEC data block
//	   		errCode = read_cec_cdr(pSysArgs->slaveAddr, pSysArgs->firstRegister, pSysArgs->pData);
//	   	}
//	   	else
//	   	{
//			//other data block
//			for (index = 0; index < pSysArgs->lenData; index++)
//			{
//				errCode |= read_cec_reg(pSysArgs->slaveAddr, pSysArgs->firstRegister + index, &pSysArgs->pData[index]);
//			}
//	   	}
//	}
//	else
//	{
//        //bad parameter
//		PRNT_ARGS("/!\\cec read dev address 0x%02x FAILED - bad parameter\n", pSysArgs->slaveAddr);
//		return TM_ERR_BAD_PARAMETER;
//	}

	return errCode;
}

/* The following function must be rewritten by the customer to fit its own    */
/* SW infrastructure. This function allows writing through I2C bus.           */
/* tmdlHdmiCecSysArgs_t definition is located into tmbslHdmiTx_type.h file.   */
tmErrorCode_t CECI2cWriteFunction(tmdlHdmiCecSysArgs_t *pSysArgs)
{
	tmErrorCode_t errCode;
	int i;

	for (i = 0; i < pSysArgs->lenData; i++) {
		errCode = write_cec_reg(pSysArgs->slaveAddr, pSysArgs->firstRegister + i, &pSysArgs->pData[i]);
		if (errCode != TM_OK)
			return errCode;
	}

//	if (pSysArgs->lenData == 1)
//	{
//		//single byte
//		errCode = write_cec_reg(pSysArgs->slaveAddr, pSysArgs->firstRegister, pSysArgs->pData);
//	}
//	else if (pSysArgs->lenData > 1)
//	{
//		//block
//	   	if (pSysArgs->firstRegister == CEC_REG_CDR0)
//	   	{
//	   		//CEC data block
//			errCode = write_cec_cdr(pSysArgs->slaveAddr, pSysArgs->firstRegister, pSysArgs->pData);
//	   	}
//	   	else
//	   	{
//	   		//other data block
//			for (index = 0; index < pSysArgs->lenData; index++)
//	   		{
//	   			errCode |= write_cec_reg(pSysArgs->slaveAddr, pSysArgs->firstRegister + index, &pSysArgs->pData[index]);
//	   		}
//	   	}
//	}
//	else
//	{
//        //bad parameter
//		PRNT_ARGS("/!\\cec write dev address 0x%02x FAILED - bad parameter\n", pSysArgs->slaveAddr);
//		return TM_ERR_BAD_PARAMETER;
//	}

    return errCode;
}

tmdlHdmiCecCapabilities_t CeccapabilitiesList = {TMDL_HDMICEC_DEVICE_UNKNOWN, CEC_VERSION_1_3a};

tmdlHdmiCecDriverConfigTable_t driverConfigTableCec[MAX_UNITS] = {
    {
    COMMAND_TASK_PRIORITY_0,
    COMMAND_TASK_STACKSIZE_0,
    COMMAND_TASK_QUEUESIZE_0,
    UNIT_I2C_ADDRESS_0,
    CECI2cReadFunction,
    CECI2cWriteFunction,
    &CeccapabilitiesList
    }
};

/******************************************************************************
******************************************************************************
*                THIS PART MUST NOT BE MODIFIED BY CUSTOMER                  *
******************************************************************************
*****************************************************************************/

/**
    \brief This function allows to the main driver to retrieve its
           configuration parameters.

    \param pConfig Pointer to the config structure

    \return The call result:
            - TM_OK: the call was successful
            - TMDL_ERR_DLHDMICEC_BAD_UNIT_NUMBER: the unit number is wrong or
              the receiver instance is not initialised
            - TMDL_ERR_DLHDMICEC_INCONSISTENT_PARAMS: an input parameter is
              inconsistent

******************************************************************************/
tmErrorCode_t tmdlHdmiCecCfgGetConfig
(
    tmUnitSelect_t                 unit,
    tmdlHdmiCecDriverConfigTable_t *pConfig
)
{
    /* check if unit number is in range */
    RETIF((unit < 0) || (unit >= MAX_UNITS), TMDL_ERR_DLHDMICEC_BAD_UNIT_NUMBER)

    /* check if pointer is Null */
    RETIF(pConfig == Null, TMDL_ERR_DLHDMICEC_INCONSISTENT_PARAMS)

    *pConfig = driverConfigTableCec[unit];

    return(TM_OK);
};

/**
    \brief This function allows to the main driver to store its
           configuration parameters.

    \param pConfig Pointer to the config structure

    \return The call result:
            - TM_OK: the call was successful
            - TMDL_ERR_DLHDMICEC_BAD_UNIT_NUMBER: the unit number is wrong or
              the receiver instance is not initialised
            - TMDL_ERR_DLHDMICEC_INCONSISTENT_PARAMS: an input parameter is
              inconsistent

******************************************************************************/
tmErrorCode_t tmdlHdmiCecCfgSetConfig
(
    tmUnitSelect_t                 unit,
    tmdlHdmiCecDriverConfigTable_t *pConfig
)
{
    /* check if unit number is in range */
    RETIF((unit < 0) || (unit >= MAX_UNITS), TMDL_ERR_DLHDMICEC_BAD_UNIT_NUMBER)

    /* check if pointer is Null */
    RETIF(pConfig == Null, TMDL_ERR_DLHDMICEC_INCONSISTENT_PARAMS)

    driverConfigTableCec[unit] = *pConfig; 

    return(TM_OK);
};
/*============================================================================*/
/*                            END OF FILE                                     */
/*============================================================================*/

/**
 *******************************************************************************
 *******************************************************************************
 *
 * @file    axidma_uio.c
 * @author  R. Bush
 * @email   bush@krtkl.com
 * @version 0.1
 * @date    Jan 16, 2018
 * @brief   AXI DMA Userspace I/O Driver
 * @license FreeBSD
 *
 *******************************************************************************
 *
 * Copyright (c) 2018, krtkl inc.
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 * 1. Redistributions of source code must retain the above copyright notice,
 *    this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright notice,
 *    this list of conditions and the following disclaimer in the documentation
 *    and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
 * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
 * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
 * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
 * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
 * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
 * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
 * POSSIBILITY OF SUCH DAMAGE.
 *
 * The views and conclusions contained in the software and documentation are
 * those of the authors and should not be interpreted as representing official
 * policies, either expressed or implied, of the FreeBSD Project.
 *
 *******************************************************************************
 */


//#include <stdio.h>
//#include <stdlib.h>
//#include <unistd.h>
//#include <fcntl.h>
//#include <errno.h>


#define AXIVDMA_MM2S_CR			(0x00000000U)	/**< MM2S control register */
#define AXIVDMA_MM2S_SR			(0x00000004U)	/**< MM2S status register */
#define AXIVDMA_MM2S_INDEX		(0x00000014U)	/**< MM2S register index */
#define AXIVDMA_PARK_PTR		(0x00000028U)	/**< Park pointer */
#define AXIVDMA_VERSION			(0x0000002CU)	/**< Video DMA version */
#define AXIVDMA_S2MM_CR			(0x00000030U)	/**< S2MM control register */
#define AXIVDMA_S2MM_SR			(0x00000034U)	/**< S2MM status register */
#define AXIVDMA_S2MM_IRQ_MASK		(0x0000003CU)	/**< S2MM error interrupt mask */
#define AXIVDMA_S2MM_INDEX		(0x00000044U)	/**< S2MM register index */
#define AXIVDMA_MM2S_VSIZE		(0x00000050U)	/**< MM2S vertical size */
#define AXIVDMA_MM2S_HSIZE		(0x00000054U)	/**< MM2S horizontal size */
#define AXIVDMA_MM2S_FRMDLYSTRD		(0x00000058U)	/**< MM2S frame delay and stride */
#define AXIVDMA_MM2S_START_ADDRESS	(0x0000005CU)	/**< MM2S start address */
#define AXIVDMA_S2MM_VSIZE		(0x000000A0U)	/**< S2MM vertical size */
#define AXIVDMA_S2MM_HSIZE		(0x000000A4U)	/**< S2MM horizontal size */
#define AXIVDMA_S2MM_FRMDLYSTRD		(0x000000A8U)	/**< S2MM frame delay and stride */
#define AXIVDMA_S2MM_START_ADDRESS	(0x000000ACU)	/**< S2MM start address */






/**
 * @brief	Reset a DMA Channel
 */
int
axidma_reset(AxiDma *dma)
{
	int ret;

	if (dma == NULL || dma->ctrl == NULL)
		return -EINVAL;

	/* setting the MM2S reset will reset the entire DMA engine */
	ret = uio_write_reg (dma->ctrl, AXIDMA_CR_RESET, AXIDMA_MM2S_OFFSET + AXIDMA_CR_OFFSET);
	if (ret < 0)
		goto out;

	ret = uio_write_reg (dma->ctrl, AXIDMA_CR_RESET, AXIDMA_S2MM_OFFSET + AXIDMA_CR_OFFSET);
	if (ret < 0)
		goto out;

//	ret = uio_read_reg (dma->ctrl, &val, AXIDMA_MM2S_OFFSET + AXIDMA_SR_OFFSET);
//	if (ret < 0)
//		goto out;
//
//	while (!(val & AXIDMA_SR_HALTED)) {
//		if (val & AXIDMA_SR_IDLE)
//			break;
//
//		ret = uio_read_reg (dma->ctrl, &val, AXIDMA_MM2S_OFFSET + AXIDMA_SR_OFFSET);
//		if (ret < 0)
//			goto out;
//	}

	ret = uio_mask_write_reg (dma->ctrl, 0, AXIDMA_CR_RESET, AXIDMA_MM2S_OFFSET + AXIDMA_CR_OFFSET);
	if (ret < 0)
		goto out;

	ret = uio_mask_write_reg (dma->ctrl, 0, AXIDMA_CR_RESET, AXIDMA_S2MM_OFFSET + AXIDMA_CR_OFFSET);
out:
	return ret;
}


int
axidma_ready(AxiDma *dma, AxiDmaChan chan)
{
	int ret;
	unsigned long offset, reg;

	switch (chan) {
	case AXIDMA_MM2S_CHANNEL: offset = AXIDMA_MM2S_OFFSET; break;
	case AXIDMA_S2MM_CHANNEL: offset = AXIDMA_S2MM_OFFSET; break;
	}

	ret = uio_read_reg (dma->ctrl, &reg, offset + AXIDMA_SR_OFFSET);
	if (ret < 0)
		return ret;

	return (reg & AXIDMA_SR_HALTED ? 1 : 0);
}


int
axidma_idle(AxiDma *dma, AxiDmaChan chan)
{
	int ret;
	unsigned long offset, reg;

	switch (chan) {
	case AXIDMA_MM2S_CHANNEL: offset = AXIDMA_MM2S_OFFSET; break;
	case AXIDMA_S2MM_CHANNEL: offset = AXIDMA_S2MM_OFFSET; break;
	}

	ret = uio_read_reg (dma->ctrl, &reg, offset + AXIDMA_SR_OFFSET);
	if (ret < 0)
		return ret;

	return (reg & AXIDMA_SR_IDLE ? 1 : 0);
}


int
axidma_irq_enable(AxiDma *dma, AxiDmaChan chan, unsigned long irq)
{
	unsigned long offset;

	if (dma == NULL || dma->ctrl == NULL)
		return -EINVAL;

	switch (chan) {
	case AXIDMA_MM2S_CHANNEL: offset = AXIDMA_MM2S_OFFSET; break;
	case AXIDMA_S2MM_CHANNEL: offset = AXIDMA_S2MM_OFFSET; break;
	}

	return uio_mask_write_reg (dma->ctrl, irq, AXIDMA_CR_IRQALL, offset + AXIDMA_CR_OFFSET);
}


int
axidma_irq_disable(AxiDma *dma, AxiDmaChan chan, unsigned long irq)
{
	unsigned long offset;

	if (dma == NULL || dma->ctrl == NULL)
		return -EINVAL;

	switch (chan) {
	case AXIDMA_MM2S_CHANNEL: offset = AXIDMA_MM2S_OFFSET; break;
	case AXIDMA_S2MM_CHANNEL: offset = AXIDMA_S2MM_OFFSET; break;
	}

	return uio_mask_write_reg (dma->ctrl, 0, irq, offset + AXIDMA_CR_OFFSET);
}


int
axidma_init(AxiDma *dma)
{
	int ret;

	if (dma == NULL)
		return -EINVAL;

	/* DMA engine control device */
	dma->ctrl = uio_new (0);
	if (dma->ctrl == NULL)
		return -ENOMEM;

	ret = uio_dev_open (dma->ctrl);
	if (ret < 0)
		return ret;

	ret = uio_init_maps (dma->ctrl);
	if (ret < 0)
		return ret;

	/* memory to stream interrupt and memory region device */
	dma->mm2s = uio_new (1);
	if (dma->mm2s == NULL)
		return -ENOMEM;

	ret = uio_dev_open (dma->mm2s);
	if (ret < 0)
		return ret;

	ret = uio_init_maps (dma->mm2s);
	if (ret < 0)
		return ret;

	/* stream to memory interrupt and memory region device */
	dma->s2mm = uio_new (2);
	if (dma->s2mm == NULL)
		return -ENOMEM;

	ret = uio_dev_open (dma->s2mm);
	if (ret < 0)
		return ret;

	ret = uio_init_maps (dma->s2mm);
	if (ret < 0)
		return ret;

	return 0;
}


int
axidma_transfer(AxiDma *dma, AxiDmaXfer *xfer)
{
	int ret;
	unsigned long offset;

	if (dma == NULL || dma->ctrl == NULL || xfer == NULL)
		return -EINVAL;

	if (xfer->len > AXIDMA_MAX_LENGTH)
		return -EINVAL;

	/* which channel is it for? */
	switch (xfer->chan) {
	case AXIDMA_MM2S_CHANNEL: offset = AXIDMA_MM2S_OFFSET; break;
	case AXIDMA_S2MM_CHANNEL: offset = AXIDMA_S2MM_OFFSET; break;
	}

	/* set source/destination address */
	ret = uio_write_reg (dma->ctrl, xfer->addr, offset + AXIDMA_SRCDEST_OFFSET);
	if (ret < 0)
		goto out;

	if (xfer->addr_width > 32) {
		ret = uio_write_reg (dma->ctrl, xfer->addr_msb, offset + AXIDMA_SRCDEST_MSB_OFFSET);
		if (ret < 0)
			goto out;
	} else {
		ret = uio_write_reg (dma->ctrl, 0, offset + AXIDMA_SRCDEST_MSB_OFFSET);
		if (ret < 0)
			goto out;
	}

	/* run the channel */
	ret = uio_mask_write_reg (dma->ctrl, AXIDMA_CR_RUN, AXIDMA_CR_RUN, offset + AXIDMA_CR_OFFSET);
	if (ret < 0)
		goto out;

	/* set the length (this will start the transfer) */
	ret = uio_write_reg (dma->ctrl, xfer->len, offset + AXIDMA_LENGTH_OFFSET);
out:
	return ret;
}


int
axidma_transfer_end(AxiDma *dma, AxiDmaChan chan)
{
	int ret;
	unsigned long reg_val, offset;
	UioDevice *dev;

	if (dma == NULL || dma->mm2s == NULL || dma->s2mm == NULL)
		return -EINVAL;

	switch (chan) {
	case AXIDMA_MM2S_CHANNEL:
		dev = dma->mm2s;
		offset = AXIDMA_MM2S_OFFSET;
		break;
	case AXIDMA_S2MM_CHANNEL:
		dev = dma->s2mm;
		offset = AXIDMA_S2MM_OFFSET;
		break;
	default:
		return -EINVAL;
	}

	printf ("finishing DMA transfer\n");

	ret = uio_wait_on_irq (dev);
	if (ret < 0)
		return ret;

	printf ("waiting for DMA channel to be halted");

	ret = uio_read_reg (dma->ctrl, &reg_val, offset + AXIDMA_SR_OFFSET);
	if (ret < 0)
		return ret;

	while (!(reg_val & AXIDMA_SR_HALTED)) {
		if (reg_val & AXIDMA_SR_HALTED)
			break;

		ret = uio_read_reg (dma->ctrl, &reg_val, offset + AXIDMA_SR_OFFSET);
		if (ret < 0)
			return ret;
	}

	return 0;
}




